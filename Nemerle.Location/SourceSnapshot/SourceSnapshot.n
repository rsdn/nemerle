using System;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Utility;

using SCG = System.Collections.Generic;

namespace Nemerle.Compiler
{
  public abstract class SourceSnapshot
  {
    protected mutable _lineIndexes : array[int];
    protected _textOffset  : int;
    protected _hashCode    : int;

    protected this(textOffset : int, hashCode : int)
    {
      _hashCode   = hashCode;
      _textOffset = textOffset;
    }
    
    //public static @:(text : string) : SourceSnapshot { SourceSnapshot(text) }
    public static Default : SourceSnapshot
    {
      get;
      default FakeSourceSnapshot(File.NoFile)
    }

    public abstract OriginalText : string { get; }
    public abstract Text         : string { get; }
    public abstract File         : File   { get; }
    public abstract Version      : int    { get; }

    public virtual  FileIndex             : int  { get File.Id }
    public abstract IsGenerated           : bool { get; }
    /// Handwritten code not available
    public abstract IsFake                : bool { get; }
    /// Handwritten or generated code available
    public virtual  IsSourceFileAvailable : bool { get this.File.IsSourceFileAvailable }
    /// Handwritten code is available
    public virtual  IsSourceAvailable     : bool { get !IsFake && IsSourceFileAvailable }

    public virtual Reload() : SourceSnapshot { this }
    
    public PositionToLineColumn(pos : int) : LineColumn
    {
      when (_lineIndexes == null)
        UpdateLineIndexes();
      
      def pos2 = _textOffset + pos;

      match (Array.BinarySearch(_lineIndexes, pos2))
      {
        | result when result < 0 =>
          def index = ~result;
          if (index > 0 && index <= _lineIndexes.Length)
            LineColumn(index, pos2 - _lineIndexes[index - 1] + 1)
          else 
            LineColumn(1, 1)

        | index => LineColumn(index + 1, pos2 - _lineIndexes[index] + 1)
      }
    }

    public LineColumnToPosition(lineColumn : LineColumn) : int
    {
      when (_lineIndexes == null)
        UpdateLineIndexes();
      
      if (lineColumn.Line <= _lineIndexes.Length)
        Math.Min(_lineIndexes[lineColumn.Line - 1] + lineColumn.Column - 1, Text.Length)
      else
        Text.Length
    }

    public GetSourceLine(pos : int) : Location
    {
      when (_lineIndexes == null)
        UpdateLineIndexes();
      
      def pos = _textOffset + pos;
      def (line, col) = PositionToLineColumn(pos);
      def startPos = pos - col + 1;
      def endPos =
        if(line == _lineIndexes.Length)
          Text.Length
        else
          _lineIndexes[line];
      Location(this, startPos, endPos)
    }

    //public WithText([NotNull] text : string) : SourceSnapshot
    //{
    //  WithText(text, 0)
    //}
    //
    //public WithText([NotNull] text : string, textOffset : int) : SourceSnapshot
    //  requires OriginalText.Length >= text.Length + textOffset
    //{
    //  SourceSnapshot(OriginalText, text, _lineIndexes, textOffset, File, null)
    //}
    //
    //public WithTextSubstring(pos : int, length : int) : SourceSnapshot
    //{
    //  WithText(Text.Substring(pos, length), _textOffset + pos)
    //}

    public override ToString() : string { File.FullName }
    
    protected UpdateLineIndexes() : void
    {
      assert(OriginalText != null);
      _lineIndexes = MakeLineIndexes(OriginalText);
    }
    

    protected static MakeLineIndexes(text : string) : array[int]
    {
      unchecked
      {
        def lineIndexesBuffer = SCG.List(text.Length / 25);
        lineIndexesBuffer.Add(0);
        mutable pos;
        while (pos < text.Length)
        {
          match (text[pos])
          {
            | '\r' =>
              ++pos;
              when (pos < text.Length && text[pos] == '\n')
                ++pos;
              lineIndexesBuffer.Add(pos);
            | '\n'
            | '\u2028'    //  line separator
            | '\u2029' => ++pos; lineIndexesBuffer.Add(pos); //  paragraph separator
            | _ => ++pos;
          }
        }
        lineIndexesBuffer.ToArray()
      }
    }

    #region Nitra.SourceSnapshot  Members

    public static @==(a : SourceSnapshot, b : SourceSnapshot) : bool { object.Equals(a, b) }
    public static @!=(a : SourceSnapshot, b : SourceSnapshot) : bool { !object.Equals(a, b) }

    [OverrideObjectEquals]
    public Equals(other : SourceSnapshot) : bool
    {
      when (ReferenceEquals(other, this))
        return true;

      other != null && _hashCode == other._hashCode && other.File == this.File && this.Text.Equals(other.Text, StringComparison.Ordinal)
    }

    public override GetHashCode() : int
    {
      _hashCode
    }

    #endregion

    public GetText() : string { Text }
  }
}
