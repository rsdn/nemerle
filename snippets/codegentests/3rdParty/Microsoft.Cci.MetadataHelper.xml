<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Cci.MetadataHelper</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Cci.GlobalAssemblyCache">
            <summary>
            Contains helper routines to query the GAC for the presence and locations of assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GlobalAssemblyCache.Contains(System.Uri)">
            <summary>
            Determines whether the GAC contains the specified code base URI.
            </summary>
            <param name="codeBaseUri">The code base URI.</param>
        </member>
        <member name="M:Microsoft.Cci.GlobalAssemblyCache.GetLocation(Microsoft.Cci.AssemblyIdentity,Microsoft.Cci.IMetadataHost)">
            <summary>
            Returns the original location of the corresponding assembly if available, otherwise returns the location of the shadow copy.
            If the corresponding assembly is not in the GAC, null is returned.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.BaseMetadataTraverser">
            <summary>
            A visitor base class that traverses the object model in depth first, left to right order.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Cci.BaseMetadataTraverser.path">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Cci.BaseMetadataTraverser.stopTraversal">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IAliasForType})">
            <summary>
            Visits the specified aliases for types.
            </summary>
            <param name="aliasesForTypes">The aliases for types.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IAliasForType)">
            <summary>
            Visits the specified alias for type.
            </summary>
            <param name="aliasForType">Type of the alias for.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Performs some computation with the given array type reference.
            </summary>
            <param name="arrayTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IAssembly)">
            <summary>
            Performs some computation with the given assembly.
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IAssemblyReference})">
            <summary>
            Visits the specified assembly references.
            </summary>
            <param name="assemblyReferences">The assembly references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Performs some computation with the given assembly reference.
            </summary>
            <param name="assemblyReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICustomAttribute})">
            <summary>
            Visits the specified custom attributes.
            </summary>
            <param name="customAttributes">The custom attributes.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ICustomAttribute)">
            <summary>
            Performs some computation with the given custom attribute.
            </summary>
            <param name="customAttribute"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICustomModifier})">
            <summary>
            Visits the specified custom modifiers.
            </summary>
            <param name="customModifiers">The custom modifiers.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ICustomModifier)">
            <summary>
            Performs some computation with the given custom modifier.
            </summary>
            <param name="customModifier"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IEventDefinition})">
            <summary>
            Visits the specified events.
            </summary>
            <param name="events">The events.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IEventDefinition)">
            <summary>
            Performs some computation with the given event definition.
            </summary>
            <param name="eventDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IFieldDefinition})">
            <summary>
            Visits the specified fields.
            </summary>
            <param name="fields">The fields.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IFieldDefinition)">
            <summary>
            Performs some computation with the given field definition.
            </summary>
            <param name="fieldDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IFieldReference)">
            <summary>
            Performs some computation with the given field reference.
            </summary>
            <param name="fieldReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IFileReference})">
            <summary>
            Visits the specified file references.
            </summary>
            <param name="fileReferences">The file references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IFileReference)">
            <summary>
            Performs some computation with the given file reference.
            </summary>
            <param name="fileReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IFunctionPointerTypeReference)">
            <summary>
            Performs some computation with the given function pointer type reference.
            </summary>
            <param name="functionPointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericMethodInstanceReference)">
            <summary>
            Performs some computation with the given generic method instance reference.
            </summary>
            <param name="genericMethodInstanceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IGenericMethodParameter})">
            <summary>
            Visits the specified generic parameters.
            </summary>
            <param name="genericParameters">The generic parameters.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericMethodParameter)">
            <summary>
            Performs some computation with the given generic method parameter.
            </summary>
            <param name="genericMethodParameter"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericMethodParameterReference)">
            <summary>
            Performs some computation with the given generic method parameter reference.
            </summary>
            <param name="genericMethodParameterReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericParameter)">
            <summary>
            Visits the specified generic parameter.
            </summary>
            <param name="genericParameter">The generic parameter.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericTypeInstanceReference)">
            <summary>
            Performs some computation with the given generic type instance reference.
            </summary>
            <param name="genericTypeInstanceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IGenericTypeParameter})">
            <summary>
            Visits the specified generic parameters.
            </summary>
            <param name="genericParameters">The generic parameters.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericTypeParameter)">
            <summary>
            Performs some computation with the given generic parameter.
            </summary>
            <param name="genericTypeParameter"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericTypeParameterReference)">
            <summary>
            Performs some computation with the given generic type parameter reference.
            </summary>
            <param name="genericTypeParameterReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGlobalFieldDefinition)">
            <summary>
            Performs some computation with the given global field definition.
            </summary>
            <param name="globalFieldDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGlobalMethodDefinition)">
            <summary>
            Performs some computation with the given global method definition.
            </summary>
            <param name="globalMethodDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ILocalDefinition})">
            <summary>
            Visits the specified local definitions.
            </summary>
            <param name="localDefinitions">The local definitions.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ILocalDefinition)">
            <summary>
            Visits the specified local definition.
            </summary>
            <param name="localDefinition">The local definition.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IManagedPointerTypeReference)">
            <summary>
            Performs some computation with the given managed pointer type reference.
            </summary>
            <param name="managedPointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMarshallingInformation)">
            <summary>
            Performs some computation with the given marshalling information.
            </summary>
            <param name="marshallingInformation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataConstant)">
            <summary>
            Performs some computation with the given metadata constant.
            </summary>
            <param name="constant"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataCreateArray)">
            <summary>
            Performs some computation with the given metadata array creation expression.
            </summary>
            <param name="createArray"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMetadataExpression})">
            <summary>
            Visits the specified expressions.
            </summary>
            <param name="expressions">The expressions.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataExpression)">
            <summary>
            Performs some computation with the given metadata expression.
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMetadataNamedArgument})">
            <summary>
            Visits the specified named arguments.
            </summary>
            <param name="namedArguments">The named arguments.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataNamedArgument)">
            <summary>
            Performs some computation with the given metadata named argument expression.
            </summary>
            <param name="namedArgument"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataTypeOf)">
            <summary>
            Performs some computation with the given metadata typeof expression.
            </summary>
            <param name="typeOf"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMethodBody)">
            <summary>
            Performs some computation with the given method body.
            </summary>
            <param name="methodBody"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMethodDefinition})">
            <summary>
            Visits the specified methods.
            </summary>
            <param name="methods">The methods.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMethodDefinition)">
            <summary>
            Performs some computation with the given method definition.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMethodImplementation})">
            <summary>
            Visits the specified method implementations.
            </summary>
            <param name="methodImplementations">The method implementations.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMethodImplementation)">
            <summary>
            Performs some computation with the given method implementation.
            </summary>
            <param name="methodImplementation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMethodReference})">
            <summary>
            Visits the specified method references.
            </summary>
            <param name="methodReferences">The method references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMethodReference)">
            <summary>
            Performs some computation with the given method reference.
            </summary>
            <param name="methodReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IModifiedTypeReference)">
            <summary>
            Performs some computation with the given modified type reference.
            </summary>
            <param name="modifiedTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IModule)">
            <summary>
            Performs some computation with the given module.
            </summary>
            <param name="module"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IModule})">
            <summary>
            Visits the specified modules.
            </summary>
            <param name="modules">The modules.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IModuleReference})">
            <summary>
            Visits the specified module references.
            </summary>
            <param name="moduleReferences">The module references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IModuleReference)">
            <summary>
            Performs some computation with the given module reference.
            </summary>
            <param name="moduleReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.INamedTypeDefinition})">
            <summary>
            Visits the specified types.
            </summary>
            <param name="types">The types.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.INamespaceMember})">
            <summary>
            Visits the specified namespace members.
            </summary>
            <param name="namespaceMembers">The namespace members.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INamespaceAliasForType)">
            <summary>
            Performs some computation with the given alias for a namespace type definition.
            </summary>
            <param name="namespaceAliasForType"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INamespaceMember)">
            <summary>
            Visits the specified namespace member.
            </summary>
            <param name="namespaceMember">The namespace member.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INamespaceTypeDefinition)">
            <summary>
            Performs some computation with the given namespace type definition.
            </summary>
            <param name="namespaceTypeDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INamespaceTypeReference)">
            <summary>
            Performs some computation with the given namespace type reference.
            </summary>
            <param name="namespaceTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INestedAliasForType)">
            <summary>
            Performs some computation with the given alias to a nested type definition.
            </summary>
            <param name="nestedAliasForType"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INestedUnitNamespaceReference)">
            <summary>
            Performs some computation with the given nested unit namespace reference.
            </summary>
            <param name="nestedUnitNamespaceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.INestedTypeDefinition})">
            <summary>
            Visits the specified nested types.
            </summary>
            <param name="nestedTypes">The nested types.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INestedTypeDefinition)">
            <summary>
            Performs some computation with the given nested type definition.
            </summary>
            <param name="nestedTypeDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INestedTypeReference)">
            <summary>
            Performs some computation with the given nested type reference.
            </summary>
            <param name="nestedTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INestedUnitNamespace)">
            <summary>
            Performs some computation with the given nested unit namespace.
            </summary>
            <param name="nestedUnitNamespace"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INestedUnitSetNamespace)">
            <summary>
            Performs some computation with the given nested unit set namespace.
            </summary>
            <param name="nestedUnitSetNamespace"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IOperation})">
            <summary>
            Visits the specified operations.
            </summary>
            <param name="operations">The operations.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IOperation)">
            <summary>
            Visits the specified operation.
            </summary>
            <param name="operation">The operation.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IOperationExceptionInformation})">
            <summary>
            Visits the specified operation exception informations.
            </summary>
            <param name="operationExceptionInformations">The operation exception informations.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IOperationExceptionInformation)">
            <summary>
            Visits the specified operation exception information.
            </summary>
            <param name="operationExceptionInformation">The operation exception information.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterDefinition})">
            <summary>
            Visits the specified parameters.
            </summary>
            <param name="parameters">The parameters.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IParameterDefinition)">
            <summary>
            Performs some computation with the given parameter definition.
            </summary>
            <param name="parameterDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterTypeInformation})">
            <summary>
            Visits the specified parameter type informations.
            </summary>
            <param name="parameterTypeInformations">The parameter type informations.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IParameterTypeInformation)">
            <summary>
            Performs some computation with the given parameter type information.
            </summary>
            <param name="parameterTypeInformation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IPlatformInvokeInformation)">
            <summary>
            Visits the specified platform invoke information.
            </summary>
            <param name="platformInvokeInformation">The platform invoke information.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IPointerTypeReference)">
            <summary>
            Performs some computation with the given pointer type reference.
            </summary>
            <param name="pointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IPropertyDefinition})">
            <summary>
            Visits the specified properties.
            </summary>
            <param name="properties">The properties.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IPropertyDefinition)">
            <summary>
            Performs some computation with the given property definition.
            </summary>
            <param name="propertyDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IResourceReference})">
            <summary>
            Visits the specified resource references.
            </summary>
            <param name="resourceReferences">The resource references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IResourceReference)">
            <summary>
            Performs some computation with the given reference to a manifest resource.
            </summary>
            <param name="resourceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IRootUnitNamespace)">
            <summary>
            Performs some computation with the given root unit namespace.
            </summary>
            <param name="rootUnitNamespace"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IRootUnitSetNamespace)">
            <summary>
            Performs some computation with the given root unit set namespace.
            </summary>
            <param name="rootUnitSetNamespace"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ISecurityAttribute)">
            <summary>
            Performs some computation with the given security attribute.
            </summary>
            <param name="securityAttribute"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ISecurityAttribute})">
            <summary>
            Visits the specified security attributes.
            </summary>
            <param name="securityAttributes">The security attributes.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeDefinitionMember})">
            <summary>
            Visits the specified type members.
            </summary>
            <param name="typeMembers">The type members.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeDefinition})">
            <summary>
            Visits the specified types.
            </summary>
            <param name="types">The types.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Visits the specified type definition.
            </summary>
            <param name="typeDefinition">The type definition.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ITypeDefinitionMember)">
            <summary>
            Visits the specified type member.
            </summary>
            <param name="typeMember">The type member.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ITypeMemberReference)">
            <summary>
            Visits the specified type member reference.
            </summary>
            <param name="typeMemberReference">The type member reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeReference})">
            <summary>
            Visits the specified type references.
            </summary>
            <param name="typeReferences">The type references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ITypeReference)">
            <summary>
            Visits the specified type reference.
            </summary>
            <param name="typeReference">The type reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.DispatchAsReference(Microsoft.Cci.ITypeReference)">
            <summary>
            Use this routine, rather than ITypeReference.Dispatch, to call the appropriate derived overload of an ITypeReference.
            The former routine will call Visit(INamespaceTypeDefinition) rather than Visit(INamespaceTypeReference), etc., 
            in the case where a definition is used as a reference to itself.
            </summary>
            <param name="typeReference">A reference to a type definition. Note that a type definition can serve as a reference to itself.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IUnit)">
            <summary>
            Visits the specified unit.
            </summary>
            <param name="unit">The unit.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IUnitReference})">
            <summary>
            Visits the specified unit references.
            </summary>
            <param name="unitReferences">The unit references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IUnitReference)">
            <summary>
            Visits the specified unit reference.
            </summary>
            <param name="unitReference">The unit reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.DispatchAsReference(Microsoft.Cci.IUnitReference)">
            <summary>
            Use this routine, rather than IUnitReference.Dispatch, to call the appropriate derived overload of an IUnitReference.
            The former routine will call Visit(IAssembly) rather than Visit(IAssemblyReference), etc.
            in the case where a definition is used as the reference to itself.
            </summary>
            <param name="unitReference">A reference to a unit. Note that a unit can serve as a reference to itself.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INamespaceDefinition)">
            <summary>
            Visits the specified namespace definition.
            </summary>
            <param name="namespaceDefinition">The namespace definition.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IRootUnitNamespaceReference)">
            <summary>
            Performs some computation with the given root unit namespace reference.
            </summary>
            <param name="rootUnitNamespaceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IUnitNamespaceReference)">
            <summary>
            Visits the specified unit namespace reference.
            </summary>
            <param name="unitNamespaceReference">The unit namespace reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IUnitSet)">
            <summary>
            Performs some computation with the given unit set.
            </summary>
            <param name="unitSet"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IUnitSetNamespace)">
            <summary>
            Visits the specified unit set namespace.
            </summary>
            <param name="unitSetNamespace">The unit set namespace.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IWin32Resource)">
            <summary>
            Performs some computation with the given Win32 resource.
            </summary>
            <param name="win32Resource"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.VisitMethodReturnAttributes(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICustomAttribute})">
            <summary>
            Visits the method return attributes.
            </summary>
            <param name="customAttributes">The custom attributes.</param>
        </member>
        <member name="T:Microsoft.Cci.BaseMetadataVisitor">
            <summary>
            A visitor base class that provides a dummy body for each method of IVisit.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IAliasForType)">
            <summary>
            Visits the specified alias for type.
            </summary>
            <param name="aliasForType">Type of the alias for.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Performs some computation with the given array type reference.
            </summary>
            <param name="arrayTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IAssembly)">
            <summary>
            Performs some computation with the given assembly.
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Performs some computation with the given assembly reference.
            </summary>
            <param name="assemblyReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.ICustomAttribute)">
            <summary>
            Performs some computation with the given custom attribute.
            </summary>
            <param name="customAttribute"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.ICustomModifier)">
            <summary>
            Performs some computation with the given custom modifier.
            </summary>
            <param name="customModifier"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IEventDefinition)">
            <summary>
            Performs some computation with the given event definition.
            </summary>
            <param name="eventDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IFieldDefinition)">
            <summary>
            Performs some computation with the given field definition.
            </summary>
            <param name="fieldDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IFieldReference)">
            <summary>
            Performs some computation with the given field reference.
            </summary>
            <param name="fieldReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IFileReference)">
            <summary>
            Performs some computation with the given file reference.
            </summary>
            <param name="fileReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IFunctionPointerTypeReference)">
            <summary>
            Performs some computation with the given function pointer type reference.
            </summary>
            <param name="functionPointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IGenericMethodInstanceReference)">
            <summary>
            Performs some computation with the given generic method instance reference.
            </summary>
            <param name="genericMethodInstanceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IGenericMethodParameter)">
            <summary>
            Performs some computation with the given generic method parameter.
            </summary>
            <param name="genericMethodParameter"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IGenericMethodParameterReference)">
            <summary>
            Performs some computation with the given generic method parameter reference.
            </summary>
            <param name="genericMethodParameterReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IGenericTypeInstanceReference)">
            <summary>
            Performs some computation with the given generic type instance reference.
            </summary>
            <param name="genericTypeInstanceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IGenericTypeParameter)">
            <summary>
            Performs some computation with the given generic parameter.
            </summary>
            <param name="genericTypeParameter"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IGenericTypeParameterReference)">
            <summary>
            Performs some computation with the given generic type parameter reference.
            </summary>
            <param name="genericTypeParameterReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IGlobalFieldDefinition)">
            <summary>
            Performs some computation with the given global field definition.
            </summary>
            <param name="globalFieldDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IGlobalMethodDefinition)">
            <summary>
            Performs some computation with the given global method definition.
            </summary>
            <param name="globalMethodDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IManagedPointerTypeReference)">
            <summary>
            Performs some computation with the given managed pointer type reference.
            </summary>
            <param name="managedPointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMarshallingInformation)">
            <summary>
            Performs some computation with the given marshalling information.
            </summary>
            <param name="marshallingInformation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMetadataConstant)">
            <summary>
            Performs some computation with the given metadata constant.
            </summary>
            <param name="constant"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMetadataCreateArray)">
            <summary>
            Performs some computation with the given metadata array creation expression.
            </summary>
            <param name="createArray"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMetadataExpression)">
            <summary>
            Performs some computation with the given metadata expression.
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMetadataNamedArgument)">
            <summary>
            Performs some computation with the given metadata named argument expression.
            </summary>
            <param name="namedArgument"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMetadataTypeOf)">
            <summary>
            Performs some computation with the given metadata typeof expression.
            </summary>
            <param name="typeOf"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMethodBody)">
            <summary>
            Performs some computation with the given method body.
            </summary>
            <param name="methodBody"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMethodDefinition)">
            <summary>
            Performs some computation with the given method definition.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMethodImplementation)">
            <summary>
            Performs some computation with the given method implementation.
            </summary>
            <param name="methodImplementation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IMethodReference)">
            <summary>
            Performs some computation with the given method reference.
            </summary>
            <param name="methodReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IModifiedTypeReference)">
            <summary>
            Performs some computation with the given modified type reference.
            </summary>
            <param name="modifiedTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IModule)">
            <summary>
            Performs some computation with the given module.
            </summary>
            <param name="module"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IModuleReference)">
            <summary>
            Performs some computation with the given module reference.
            </summary>
            <param name="moduleReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INamespaceAliasForType)">
            <summary>
            Performs some computation with the given alias for a namespace type definition.
            </summary>
            <param name="namespaceAliasForType"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INamespaceDefinition)">
            <summary>
            Visits the specified namespace definition.
            </summary>
            <param name="namespaceDefinition">The namespace definition.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INamespaceMember)">
            <summary>
            Visits the specified namespace member.
            </summary>
            <param name="namespaceMember">The namespace member.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INamespaceTypeDefinition)">
            <summary>
            Performs some computation with the given namespace type definition.
            </summary>
            <param name="namespaceTypeDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INamespaceTypeReference)">
            <summary>
            Performs some computation with the given namespace type reference.
            </summary>
            <param name="namespaceTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INestedAliasForType)">
            <summary>
            Performs some computation with the given alias to a nested type definition.
            </summary>
            <param name="nestedAliasForType"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INestedTypeDefinition)">
            <summary>
            Performs some computation with the given nested type definition.
            </summary>
            <param name="nestedTypeDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INestedTypeReference)">
            <summary>
            Performs some computation with the given nested type reference.
            </summary>
            <param name="nestedTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INestedUnitNamespace)">
            <summary>
            Performs some computation with the given nested unit namespace.
            </summary>
            <param name="nestedUnitNamespace"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INestedUnitNamespaceReference)">
            <summary>
            Performs some computation with the given nested unit namespace reference.
            </summary>
            <param name="nestedUnitNamespaceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.INestedUnitSetNamespace)">
            <summary>
            Performs some computation with the given nested unit set namespace.
            </summary>
            <param name="nestedUnitSetNamespace"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IParameterDefinition)">
            <summary>
            Performs some computation with the given parameter definition.
            </summary>
            <param name="parameterDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IPropertyDefinition)">
            <summary>
            Performs some computation with the given property definition.
            </summary>
            <param name="propertyDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IParameterTypeInformation)">
            <summary>
            Performs some computation with the given parameter type information.
            </summary>
            <param name="parameterTypeInformation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IPointerTypeReference)">
            <summary>
            Performs some computation with the given pointer type reference.
            </summary>
            <param name="pointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IResourceReference)">
            <summary>
            Performs some computation with the given reference to a manifest resource.
            </summary>
            <param name="resourceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IRootUnitNamespace)">
            <summary>
            Performs some computation with the given root unit namespace.
            </summary>
            <param name="rootUnitNamespace"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IRootUnitNamespaceReference)">
            <summary>
            Performs some computation with the given root unit namespace reference.
            </summary>
            <param name="rootUnitNamespaceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IRootUnitSetNamespace)">
            <summary>
            Performs some computation with the given root unit set namespace.
            </summary>
            <param name="rootUnitSetNamespace"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.ISecurityAttribute)">
            <summary>
            Performs some computation with the given security attribute.
            </summary>
            <param name="securityAttribute"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.ITypeDefinitionMember)">
            <summary>
            Visits the specified type member.
            </summary>
            <param name="typeMember">The type member.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.ITypeReference)">
            <summary>
            Visits the specified type reference.
            </summary>
            <param name="typeReference">The type reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IUnit)">
            <summary>
            Visits the specified unit.
            </summary>
            <param name="unit">The unit.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IUnitReference)">
            <summary>
            Visits the specified unit reference.
            </summary>
            <param name="unitReference">The unit reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IUnitNamespaceReference)">
            <summary>
            Visits the specified unit namespace reference.
            </summary>
            <param name="unitNamespaceReference">The unit namespace reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IUnitSet)">
            <summary>
            Performs some computation with the given unit set.
            </summary>
            <param name="unitSet"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IUnitSetNamespace)">
            <summary>
            Visits the specified unit set namespace.
            </summary>
            <param name="unitSetNamespace">The unit set namespace.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataVisitor.Visit(Microsoft.Cci.IWin32Resource)">
            <summary>
            Performs some computation with the given Win32 resource.
            </summary>
            <param name="win32Resource"></param>
        </member>
        <member name="T:Microsoft.Cci.GenericMethodInstance">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodInstance.#ctor(Microsoft.Cci.IMethodDefinition,System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeReference},Microsoft.Cci.IInternFactory)">
            <summary>
            
            </summary>
            <param name="genericMethod"></param>
            <param name="genericArguments"></param>
            <param name="internFactory"></param>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodInstance.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodInstance.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.Body">
            <summary>
            A container for a list of IL instructions providing the implementation (if any) of this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.CallingConvention">
            <summary>
            Calling convention of the signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ContainingTypeDefinition">
            <summary>
            The type definition that contains this member.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.GenericArguments">
            <summary>
            The type arguments that were used to instantiate this.GenericMethod in order to create this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.GenericMethod">
            <summary>
            Returns the generic method of which this method is an instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.GenericParameters">
            <summary>
            If the method is generic then this list contains the type parameters.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.GenericParameterCount">
            <summary>
            The number of generic parameters of the method. Zero if the referenced method is not generic.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ParameterCount">
            <summary>
            The number of required parameters of the method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ReturnValueAttributes">
            <summary>
            Custom attributes associated with the method's return value.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ReturnValueCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. Evaluate this property only if ReturnValueIsModified is true.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ReturnValueIsByRef">
            <summary>
            True if the return value is passed by reference (using a managed pointer).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ReturnValueIsMarshalledExplicitly">
            <summary>
            The return value has associated marshalling information.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ReturnValueIsModified">
            <summary>
            True if the return value has one or more custom modifiers associated with it.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ReturnValueMarshallingInformation">
            <summary>
            Specifies how the return value is marshalled when the method is called from unmanaged code.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.Type">
            <summary>
            The return type of the method or type of the property.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.Visibility">
            <summary>
            Indicates if the member is public or confined to its containing type, derived types and/or declaring assembly.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.PlatformInvokeData">
            <summary>
            Detailed information about the PInvoke stub. Identifies which method to call, which module has the method and the calling convention among other things.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.AcceptsExtraArguments">
            <summary>
            True if the call sites that references the method with this object supply extra arguments.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.HasDeclarativeSecurity">
            <summary>
            True if this method has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.HasExplicitThisParameter">
            <summary>
            True if this an instance method that explicitly declares the type and name of its first parameter (the instance).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.InternFactory">
            <summary>
            A collection of methods that associate unique integers with metadata model entities.
            The association is based on the identities of the entities and the factory does not retain
            references to the given metadata model objects.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsAbstract">
            <summary>
            True if the method does not provide an implementation.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsAccessCheckedOnOverride">
            <summary>
            True if the method can only be overridden when it is also accessible.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsCil">
            <summary>
            True if the method is implemented in the CLI Common Intermediate Language.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsExternal">
            <summary>
            True if the method has an external implementation (i.e. not supplied by this definition).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsForwardReference">
            <summary>
            True if the method implementation is defined by another method definition (to be supplied at a later time).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsGeneric">
            <summary>
            True if the method has generic parameters;
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsHiddenBySignature">
            <summary>
            True if this method is hidden if a derived type declares a method with the same name and signature.
            If false, any method with the same name hides this method. This flag is ignored by the runtime and is only used by compilers.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsNativeCode">
            <summary>
            True if the method is implemented in native (platform-specific) code.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsNewSlot">
            <summary>
            The method always gets a new slot in the virtual method table.
            This means the method will hide (not override) a base type method with the same name and signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsNeverInlined">
            <summary>
            True if the the runtime is not allowed to inline this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsNeverOptimized">
            <summary>
            True if the runtime is not allowed to optimize this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsPlatformInvoke">
            <summary>
            True if the method is implemented via the invocation of an underlying platform method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsRuntimeImplemented">
            <summary>
            True if the implementation of this method is supplied by the runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsRuntimeInternal">
            <summary>
            True if the method is an internal part of the runtime and must be called in a special way.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsRuntimeSpecial">
            <summary>
            True if the method gets special treatment from the runtime. For example, it might be a constructor.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsSealed">
            <summary>
            True if the method may not be overridden.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsSpecialName">
            <summary>
            True if the method is special in some way for tools. For example, it might be a property getter or setter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsStatic">
            <summary>
            True if the method does not require an instance of its declaring type as its first argument.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsSynchronized">
            <summary>
            True if only one thread at a time may execute this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsUnmanaged">
            <summary>
            True if the implementation of this method is not managed by the runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsVirtual">
            <summary>
            True if the method may be overridden (or if it is an override).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.PreserveSignature">
            <summary>
            True if the method signature must not be mangled during the interoperation with COM code.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.RequiresSecurityObject">
            <summary>
            True if the method calls another method containing security code. If this flag is set, the method
            should have System.Security.DynamicSecurityMethodAttribute present in its list of custom attributes.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.SecurityAttributes">
            <summary>
            Declarative security actions for this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.Container">
            <summary>
            The container instance with a Members collection that includes this instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.Name">
            <summary>
            The name of the entity.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ContainingScope">
            <summary>
            The scope instance with a Members collection that includes this instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsConstructor">
            <summary>
            True if the method is a constructor.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.IsStaticConstructor">
            <summary>
            True if the method is a static constructor.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ResolvedMethod">
            <summary>
            The method being referred to.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.InternedKey">
            <summary>
            Returns a key that is computed from the information in this reference and that uniquely identifies
            this.ResolvedMethod.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ExtraParameters">
            <summary>
            Information about this types of the extra arguments supplied at the call sites that references the method with this object.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ContainingType">
            <summary>
            A reference to the containing type of the referenced type member.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstance.ResolvedTypeDefinitionMember">
            <summary>
            The type definition member this reference resolves to.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.GenericMethodInstanceReference">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodInstanceReference.#ctor(Microsoft.Cci.IMethodReference,System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeReference},Microsoft.Cci.IInternFactory)">
            <summary>
            
            </summary>
            <param name="genericMethod"></param>
            <param name="genericArguments"></param>
            <param name="internFactory"></param>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodInstanceReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodInstanceReference.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.AcceptsExtraArguments">
            <summary>
            True if the call sites that references the method with this object supply extra arguments.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.CallingConvention">
            <summary>
            Calling convention of the signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.ContainingType">
            <summary>
            A reference to the containing type of the referenced type member.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.GenericArguments">
            <summary>
            The type arguments that were used to instantiate this.GenericMethod in order to create this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.GenericMethod">
            <summary>
            Returns the generic method of which this method is an instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.GenericParameterCount">
            <summary>
            The number of generic parameters of the method. Zero if the referenced method is not generic.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.ParameterCount">
            <summary>
            The number of required parameters of the method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.ReturnValueCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. Evaluate this property only if ReturnValueIsModified is true.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.ReturnValueIsByRef">
            <summary>
            True if the return value is passed by reference (using a managed pointer).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.ReturnValueIsModified">
            <summary>
            True if the return value has one or more custom modifiers associated with it.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.Type">
            <summary>
            The return type of the method or type of the property.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.InternFactory">
            <summary>
            A collection of methods that associate unique integers with metadata model entities.
            The association is based on the identities of the entities and the factory does not retain
            references to the given metadata model objects.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.IsGeneric">
            <summary>
            True if the method has generic parameters;
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.Name">
            <summary>
            The name of the entity.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.ResolvedMethod">
            <summary>
            The method being referred to.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.InternedKey">
            <summary>
            Returns a key that is computed from the information in this reference and that uniquely identifies
            this.ResolvedMethod.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.ExtraParameters">
            <summary>
            Information about this types of the extra arguments supplied at the call sites that references the method with this object.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodInstanceReference.ResolvedTypeDefinitionMember">
            <summary>
            The type definition member this reference resolves to.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.GenericMethodParameterReference">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodParameterReference.#ctor(Microsoft.Cci.IName,System.UInt16,Microsoft.Cci.IMetadataHost)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="index"></param>
            <param name="host"></param>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodParameterReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.DefiningMethod">
            <summary>
            A reference to the generic method that defines the referenced type parameter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.ResolvedType">
            <summary>
            The generic method parameter this reference resolves to.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.AliasForType">
            <summary>
            Gives the alias for the type
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.InternedKey">
            <summary>
            Returns the unique interned key associated with the type. This takes unification/aliases/custom modifiers into account.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.IsAlias">
            <summary>
            Indicates if this type reference resolved to an alias rather than a type
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.IsEnum">
            <summary>
            True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.IsValueType">
            <summary>
            True if the type is a value type. 
            Value types are sealed and extend System.ValueType or System.Enum.
            A type parameter for which MustBeValueType (the struct constraint in C#) is true also returns true for this property.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.PlatformType">
            <summary>
            A way to get to platform types such as System.Object.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.TypeCode">
            <summary>
            Unless the value of TypeCode is PrimitiveTypeCode.NotPrimitive, the type corresponds to a "primitive" CLR type (such as System.Int32) and
            the type code identifies which of the primitive types it corresponds to.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.Name">
            <summary>
            The name of the entity.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.GenericMethodParameterReference.Index">
            <summary>
            The position in the parameter list where this instance can be found.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.SpecializedEventDefinition">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SpecializedTypeDefinitionMember`1">
            <summary>
            
            </summary>
            <typeparam name="MemberType"></typeparam>
        </member>
        <member name="M:Microsoft.Cci.SpecializedTypeDefinitionMember`1.#ctor(`0,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.GenericTypeInstance)">
            <summary>
            
            </summary>
            <param name="unspecializedVersion"></param>
            <param name="containingTypeDefinition"></param>
            <param name="containingGenericTypeInstance"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedTypeDefinitionMember`1.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDoubleDispatcher. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.ContainingGenericTypeInstance">
            <summary>
            Gets the containing generic type instance.
            </summary>
            <value>The containing generic type instance.</value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.Visibility">
            <summary>
            Indicates if the member is public or confined to its containing type, derived types and/or declaring assembly.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.UnspecializedVersion">
            <summary>
            The corresponding (unspecialized) member from the generic type (template) that was instantiated to obtain the containing type
            of this member.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.ContainingTypeDefinition">
            <summary>
            The type definition that contains this member.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.ContainingType">
            <summary>
            A reference to the containing type of the referenced type member.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.ResolvedTypeDefinitionMember">
            <summary>
            The type definition member this reference resolves to.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.Container">
            <summary>
            The container instance with a Members collection that includes this instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.Name">
            <summary>
            The name of the entity.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedTypeDefinitionMember`1.ContainingScope">
            <summary>
            The scope instance with a Members collection that includes this instance.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Cci.SpecializedEventDefinition.#ctor(Microsoft.Cci.IEventDefinition,Microsoft.Cci.IEventDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.GenericTypeInstance)">
            <summary>
            
            </summary>
            <param name="unspecializedVersion"></param>
            <param name="containingTypeDefinition"></param>
            <param name="partiallySpecializedVersion"></param>
            <param name="containingGenericTypeInstance"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedEventDefinition.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(IEventDefinition) method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedEventDefinition.SpecializeIfConstructed(Microsoft.Cci.ITypeReference)">
            <summary>
            Makes a copy of the given type reference, making sure that any references to this.partiallySpecializedVersion.ContainingType or something defined, directly or indirectly,
            by this.partiallySpecializedVersion.Containing type are replaced with the equivalent reference to this.ContainingType or something defined, directly or indirectly
            by this.ContainingType. Also replaces all references to type parameters of this.ContainingGenericTypeInstance with the corresponding type arguments.
            </summary>
            <param name="partiallySpecializedTypeReference">A type reference obtained from some part of this.unspecializedVersion.</param>
        </member>
        <member name="P:Microsoft.Cci.SpecializedEventDefinition.Accessors">
            <summary>
            A list of methods that are associated with the event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedEventDefinition.Adder">
            <summary>
            The method used to add a handler to the event.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedEventDefinition.Caller">
            <summary>
            The method used to call the event handlers when the event occurs. May be null.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedEventDefinition.Remover">
            <summary>
            The method used to add a handler to the event.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedEventDefinition.Type">
            <summary>
            The (delegate) type of the handlers that will handle the event.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedEventDefinition.IsRuntimeSpecial">
            <summary>
            True if the event gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedEventDefinition.IsSpecialName">
            <summary>
            This event is special in some way, as specified by the name.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.SpecializedFieldDefinition">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedFieldDefinition.#ctor(Microsoft.Cci.IFieldDefinition,Microsoft.Cci.IFieldDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.GenericTypeInstance)">
            <summary>
            
            </summary>
            <param name="unspecializedVersion"></param>
            <param name="partiallySpecializedVersion"></param>
            <param name="containingTypeDefinition"></param>
            <param name="containingGenericTypeInstance"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedFieldDefinition.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(IFieldDefinition) method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedFieldDefinition.CopyAndSpecialize(Microsoft.Cci.ITypeReference)">
            <summary>
            Makes a copy of the given type reference, making sure that any references to this.partiallySpecializedVersion.ContainingType or something defined, directly or indirectly,
            by this.partiallySpecializedVersion.Containing type are replaced with the equivalent reference to this.ContainingType or something defined, directly or indirectly
            by this.ContainingType. Also replaces all references to type parameters of this.ContainingGenericTypeInstance with the corresponding type arguments.
            </summary>
            <param name="partiallySpecializedTypeReference">A type reference obtained from some part of this.unspecializedVersion.</param>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.Type">
            <summary>
            The type of value that is stored in this field.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.BitLength">
            <summary>
            The number of bits that form part of the value of the field.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsBitField">
            <summary>
            The field is aligned on a bit boundary and uses only the BitLength number of least significant bits of the representation of a Type value.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsCompileTimeConstant">
            <summary>
            This field is a compile-time constant. The field has no runtime location and cannot be directly addressed from IL.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsMapped">
            <summary>
            This field is mapped to an explicitly initialized (static) memory location.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsMarshalledExplicitly">
            <summary>
            This field has associated field marshalling information.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsNotSerialized">
            <summary>
            The field does not have to be serialized when its containing instance is serialized.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsReadOnly">
            <summary>
            This field can only be read. Initialization takes place in a constructor.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsRuntimeSpecial">
            <summary>
            True if the field gets special treatment from the runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsSpecialName">
            <summary>
            This field is special in some way, as specified by the name.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.IsStatic">
            <summary>
            This field is static (shared by all instances of its declaring type).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.Offset">
            <summary>
            Offset of the field.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.SequenceNumber">
            <summary>
            The position of the field starting from 0 within the class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.CompileTimeValue">
            <summary>
            The compile time value of the field. This value should be used directly in IL, rather than a reference to the field.
            If the field does not have a valid compile time value, Dummy.Constant is returned.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.MarshallingInformation">
            <summary>
            Specifies how this field is marshalled when it is accessed from unmanaged code.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.FieldMapping">
            <summary>
            Information of the location where this field is mapped to
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedFieldDefinition.ResolvedField">
            <summary>
            The Field being referred to.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.SpecializedGenericMethodParameter">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SpecializedGenericParameter`1">
            <summary>
            
            </summary>
            <typeparam name="ParameterType"></typeparam>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericParameter`1.#ctor(`0,Microsoft.Cci.IInternFactory)">
            <summary>
            
            </summary>
            <param name="partiallySpecializedParameter"></param>
            <param name="internFactory"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericParameter`1.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDoubleDispatcher. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericParameter`1.Contains(Microsoft.Cci.ITypeDefinitionMember)">
            <summary>
            Return true if the given member instance is a member of this scope.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericParameter`1.GetMatchingMembersNamed(Microsoft.Cci.IName,System.Boolean,Microsoft.Cci.Function{Microsoft.Cci.ITypeDefinitionMember,System.Boolean})">
            <summary>
            Returns the list of members with the given name that also satisfy the given predicate.
            </summary>
            <param name="name"></param>
            <param name="ignoreCase"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericParameter`1.GetMatchingMembers(Microsoft.Cci.Function{Microsoft.Cci.ITypeDefinitionMember,System.Boolean})">
            <summary>
            Returns the list of members that satisfy the given predicate.
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericParameter`1.GetMembersNamed(Microsoft.Cci.IName,System.Boolean)">
            <summary>
            Returns the list of members with the given name.
            </summary>
            <param name="name"></param>
            <param name="ignoreCase"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.BaseClasses">
            <summary>
            Zero or more classes from which this type is derived.
            For CLR types this collection is empty for interfaces and System.Object and populated with exactly one base type for all other types.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Constraints">
            <summary>
            A list of classes or interfaces. All type arguments matching this parameter must be derived from all of the classes and implement all of the interfaces.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.GenericParameters">
            <summary>
            Zero or more parameters that can be used as type annotations.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Interfaces">
            <summary>
            Zero or more interfaces implemented by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.InstanceType">
            <summary>
            An instance of this generic type that has been obtained by using the generic parameters as the arguments.
            Use this instance to look up members
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.PlatformType">
            <summary>
            A way to get to platform types such as System.Object.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.ExplicitImplementationOverrides">
            <summary>
            Zero or more implementation overrides provided by the class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.MustBeReferenceType">
            <summary>
            True if all type arguments matching this parameter are constrained to be reference types.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.MustBeValueType">
            <summary>
            True if all type arguments matching this parameter are constrained to be value types.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.MustHaveDefaultConstructor">
            <summary>
            True if all type arguments matching this parameter are constrained to be value types or concrete classes with visible default constructors.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Variance">
            <summary>
            Indicates if the generic type or method with this type parameter is co-, contra-, or non variant with respect to this type parameter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Alignment">
            <summary>
            The byte alignment that values of the given type ought to have. Must be a power of 2. If zero, the alignment is decided at runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Events">
            <summary>
            Zero or more events defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Fields">
            <summary>
            Zero or more fields defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsAbstract">
            <summary>
            True if the type may not be instantiated.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsClass">
            <summary>
            True if the type is a class (it is not an interface or type parameter and does not extend a special base class).
            Corresponds to C# class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsDelegate">
            <summary>
            True if the type is a delegate (it extends System.MultiCastDelegate). Corresponds to C# delegate
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsEnum">
            <summary>
            True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsGeneric">
            <summary>
            True if this type is parameterized (this.GenericParameters is a non empty collection).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsInterface">
            <summary>
            True if the type is an interface.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsReferenceType">
            <summary>
            True if the type is a reference type. A reference type is non static class or interface or a suitably constrained type parameter.
            A type parameter for which MustBeReferenceType (the class constraint in C#) is true returns true for this property
            as does a type parameter with a constraint that is a class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsSealed">
            <summary>
            True if the type may not be subtyped.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsStatic">
            <summary>
            True if the type is an abstract sealed class that directly extends System.Object and declares no constructors.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsValueType">
            <summary>
            True if the type is a value type.
            Value types are sealed and extend System.ValueType or System.Enum.
            A type parameter for which MustBeValueType (the struct constraint in C#) is true also returns true for this property.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsStruct">
            <summary>
            True if the type is a struct (its not Primitive, is sealed and base is System.ValueType).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Members">
            <summary>
            The collection of member instances that are members of this scope.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Methods">
            <summary>
            Zero or more methods defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.NestedTypes">
            <summary>
            Zero or more nested types defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Properties">
            <summary>
            Zero or more properties defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.SizeOf">
            <summary>
            Size of an object of this type. In bytes. If zero, the size is unspecified and will be determined at runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.SecurityAttributes">
            <summary>
            Declarative security actions for this type. Will be empty if this.HasSecurity is false.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.UnderlyingType">
            <summary>
            Returns a reference to the underlying (integral) type on which this (enum) type is based.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.TypeCode">
            <summary>
            Unless the value of TypeCode is PrimitiveTypeCode.NotPrimitive, the type corresponds to a "primitive" CLR type (such as System.Int32) and
            the type code identifies which of the primitive types it corresponds to.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Layout">
            <summary>
            Layout of the type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsSpecialName">
            <summary>
            True if the type has special name.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsComObject">
            <summary>
            Is this imported from COM type library
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsSerializable">
            <summary>
            True if this type is serializable.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsBeforeFieldInit">
            <summary>
            Is type initialized anytime before first access to static field
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.StringFormat">
            <summary>
            Default marshalling of the Strings in this class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsRuntimeSpecial">
            <summary>
            True if this type gets special treatment from the runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.HasDeclarativeSecurity">
            <summary>
            True if this type has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.PrivateHelperMembers">
            <summary>
            Zero or more private type members generated by the compiler for implementation purposes. These members
            are only available after a complete visit of all of the other members of the type, including the bodies of methods.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Index">
            <summary>
            The position in the parameter list where this instance can be found.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Name">
            <summary>
            The name of the entity.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.IsAlias">
            <summary>
            Indicates if this type reference resolved to an alias rather than a type
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.AliasForType">
            <summary>
            Gives the alias for the type
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.Microsoft#Cci#ITypeReference#ResolvedType">
            <summary>
            The type definition being referred to.
            In case this type was alias, this is also the type of the aliased type
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.InternFactory">
            <summary>
            A collection of methods that associate unique integers with metadata model entities.
            The association is based on the identities of the entities and the factory does not retain
            references to the given metadata model objects.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.InternedKey">
            <summary>
            Returns the unique interned key associated with the type. This takes unification/aliases/custom modifiers into account.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.MangleName">
            <summary>
            If true, the persisted type name is mangled by appending "`n" where n is the number of type parameters, if the number of type parameters is greater than 0.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericParameter`1.ResolvedType">
            <summary>
            The type definition being referred to.
            In case this type was alias, this is also the type of the aliased type
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericMethodParameter.#ctor(Microsoft.Cci.IGenericMethodParameter,Microsoft.Cci.SpecializedMethodDefinition)">
            <summary>
            
            </summary>
            <param name="partiallySpecializedParameter"></param>
            <param name="definingMethod"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericMethodParameter.CopyAndSpecialize(Microsoft.Cci.ITypeReference)">
            <summary>
            Makes a copy of the given type reference, making sure that any references to this.partiallySpecializedVersion.ContainingType or something defined, directly or indirectly,
            by this.partiallySpecializedVersion.Containing type are replaced with the equivalent reference to this.ContainingType or something defined, directly or indirectly
            by this.ContainingType. Also replaces all references to type parameters of this.ContainingGenericTypeInstance with the corresponding type arguments.
            </summary>
            <param name="partiallySpecializedTypeReference">A type reference obtained from some part of this.unspecializedVersion.</param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericMethodParameter.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(IGenericMethodParameter) method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericMethodParameter.Constraints">
            <summary>
            A list of classes or interfaces. All type arguments matching this parameter must be derived from all of the classes and implement all of the interfaces.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericMethodParameter.DefiningMethod">
            <summary>
            The generic method that defines this type parameter.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.SpecializedMethodDefinition">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedMethodDefinition.#ctor(Microsoft.Cci.IMethodDefinition,Microsoft.Cci.IMethodDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.GenericTypeInstance)">
            <summary>
            
            </summary>
            <param name="unspecializedVersion"></param>
            <param name="partiallySpecializedVersion"></param>
            <param name="containingTypeDefinition"></param>
            <param name="containingGenericTypeInstance"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedMethodDefinition.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(IMethodDefinition) method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedMethodDefinition.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.SpecializedMethodDefinition.CopyAndSpecialize(Microsoft.Cci.ITypeReference)">
            <summary>
            Makes a copy of the given type reference, making sure that any references to this.partiallySpecializedVersion.ContainingType or something defined, directly or indirectly,
            by this.partiallySpecializedVersion.Containing type are replaced with the equivalent reference to this.ContainingType or something defined, directly or indirectly
            by this.ContainingType. Replaces all references to type parameters of this.ContainingGenericTypeInstance with the corresponding type arguments.
            </summary>
            <param name="partiallySpecializedTypeReference">A type reference obtained from some part of this.unspecializedVersion.</param>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.Body">
            <summary>
            A container for a list of IL instructions providing the implementation (if any) of this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.CallingConvention">
            <summary>
            Calling convention of the signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.GenericParameters">
            <summary>
            If the method is generic then this list contains the type parameters.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.GenericParameterCount">
            <summary>
            The number of generic parameters of the method. Zero if the referenced method is not generic.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsConstructor">
            <summary>
            True if the method is a constructor.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsStaticConstructor">
            <summary>
            True if the method is a static constructor.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ParameterCount">
            <summary>
            The number of required parameters of the method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.PartiallySpecializedVersion">
            <summary>
            Partially specialized version of this method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.PlatformInvokeData">
            <summary>
            Detailed information about the PInvoke stub. Identifies which method to call, which module has the method and the calling convention among other things.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.Type">
            <summary>
            The return type of the method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.AcceptsExtraArguments">
            <summary>
            True if the call sites that references the method with this object supply extra arguments.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.HasDeclarativeSecurity">
            <summary>
            True if this method has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.HasExplicitThisParameter">
            <summary>
            True if this an instance method that explicitly declares the type and name of its first parameter (the instance).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsAbstract">
            <summary>
            True if the method does not provide an implementation.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsAccessCheckedOnOverride">
            <summary>
            True if the method can only be overridden when it is also accessible.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsCil">
            <summary>
            True if the method is implemented in the CLI Common Intermediate Language.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsExternal">
            <summary>
            True if the method has an external implementation (i.e. not supplied by this definition).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsForwardReference">
            <summary>
            True if the method implementation is defined by another method definition (to be supplied at a later time).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsGeneric">
            <summary>
            True if the method has generic parameters;
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsHiddenBySignature">
            <summary>
            True if this method is hidden if a derived type declares a method with the same name and signature.
            If false, any method with the same name hides this method. This flag is ignored by the runtime and is only used by compilers.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsNativeCode">
            <summary>
            True if the method is implemented in native (platform-specific) code.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsNewSlot">
            <summary>
            The method always gets a new slot in the virtual method table.
            This means the method will hide (not override) a base type method with the same name and signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsNeverInlined">
            <summary>
            True if the the runtime is not allowed to inline this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsNeverOptimized">
            <summary>
            True if the runtime is not allowed to optimize this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsPlatformInvoke">
            <summary>
            True if the method is implemented via the invocation of an underlying platform method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsRuntimeImplemented">
            <summary>
            True if the implementation of this method is supplied by the runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsRuntimeInternal">
            <summary>
            True if the method is an internal part of the runtime and must be called in a special way.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsRuntimeSpecial">
            <summary>
            True if the method gets special treatment from the runtime. For example, it might be a constructor.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsSealed">
            <summary>
            True if the method may not be overridden.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsSpecialName">
            <summary>
            True if the method is special in some way for tools. For example, it might be a property getter or setter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsStatic">
            <summary>
            True if the method does not require an instance of its declaring type as its first argument.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsSynchronized">
            <summary>
            True if only one thread at a time may execute this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsUnmanaged">
            <summary>
            True if the implementation of this method is not managed by the runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.IsVirtual">
            <summary>
            True if the method may be overridden (or if it is an override).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.PreserveSignature">
            <summary>
            True if the method signature must not be mangled during the interoperation with COM code.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.RequiresSecurityObject">
            <summary>
            True if the method calls another method containing security code. If this flag is set, the method
            should have System.Security.DynamicSecurityMethodAttribute present in its list of custom attributes.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.SecurityAttributes">
            <summary>
            Declarative security actions for this method.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.InternedKey">
            <summary>
            Returns a key that is computed from the information in this reference and that uniquely identifies
            this.ResolvedMethod.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ResolvedMethod">
            <summary>
            The method being referred to.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ExtraParameters">
            <summary>
            Information about this types of the extra arguments supplied at the call sites that references the method with this object.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ReturnValueAttributes">
            <summary>
            Custom attributes associated with the method's return value.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ReturnValueCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. Evaluate this property only if ReturnValueIsModified is true.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ReturnValueIsByRef">
            <summary>
            True if the return value is passed by reference (using a managed pointer).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ReturnValueIsMarshalledExplicitly">
            <summary>
            The return value has associated marshalling information.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ReturnValueIsModified">
            <summary>
            True if the return value has one or more custom modifiers associated with it.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedMethodDefinition.ReturnValueMarshallingInformation">
            <summary>
            Specifies how the return value is marshalled when the method is called from unmanaged code.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.SpecializedParameterDefinition">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedParameterDefinition.#ctor(Microsoft.Cci.IParameterDefinition,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            
            </summary>
            <param name="partiallySpecializedParameter"></param>
            <param name="containingSignature"></param>
            <param name="internFactory"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedParameterDefinition.#ctor(Microsoft.Cci.IParameterDefinition,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            
            </summary>
            <param name="partiallySpecializedParameter"></param>
            <param name="containingSignature"></param>
            <param name="internFactory"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedParameterDefinition.#ctor(Microsoft.Cci.IParameterDefinition,Microsoft.Cci.SpecializedPropertyDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            
            </summary>
            <param name="partiallySpecializedParameter"></param>
            <param name="containingSignature"></param>
            <param name="internFactory"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedParameterDefinition.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedParameterDefinition.CopyAndSpecialize(Microsoft.Cci.ITypeReference)">
            <summary>
            Replace the references to type and generic method parameters in partiallySpecializedType with matching type and generic
            method arguments. 
            </summary>
            <remarks>
            For example: method Outer[A->int].Mid[T1 => T1+].bar1[T=>T+](T p1, T1 p2, A p3), where Outer[A->int] means a generic type
            instance obtained from Outer by substituting A with int, Outer[A->int].Mid[T1 => T1+] means a specialized nested type 
            definition obtained from Outer[A->int].Mid by specializing Mid within Outer[A->int], in the process T1 is specialized to T1+. 
            
            T, type of p1, needs to be specialized to T+;
            T1, type of p2, needs to be specialized to T1+, and A needs to be instantiated to int. 
            
            Implementation involves a step of replacing references to type and generic method parameters with their matching specialized
            version for the aboved mentioned substitution to work. 
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.ContainingSignature">
            <summary>
            The method or property that defines this parameter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.ParamArrayElementType">
            <summary>
            The element type of the parameter array.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.Type">
            <summary>
            The type of argument value that corresponds to this parameter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.CustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.DefaultValue">
            <summary>
            A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.HasDefaultValue">
            <summary>
            True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.Index">
            <summary>
            The position in the parameter list where this instance can be found.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.InternFactory">
            <summary>
            A collection of methods that associate unique integers with metadata model entities.
            The association is based on the identities of the entities and the factory does not retain
            references to the given metadata model objects.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.IsByReference">
            <summary>
            True if the parameter is passed by reference (using a managed pointer).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.IsIn">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.IsMarshalledExplicitly">
            <summary>
            This parameter has associated marshalling information.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.IsModified">
            <summary>
            This parameter has one or more custom modifiers associated with it.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.IsOptional">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.IsOut">
            <summary>
            True if the final value assigned to the parameter will be marshalled with the return values passed back from a remote callee.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.MarshallingInformation">
            <summary>
            Specifies how this parameter is marshalled when it is accessed from unmanaged code.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.IsParameterArray">
            <summary>
            True if the parameter has the ParamArrayAttribute custom attribute.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.Name">
            <summary>
            The name of the entity.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterDefinition.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.SpecializedParameterTypeInformation">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedParameterTypeInformation.#ctor(Microsoft.Cci.IParameterTypeInformation,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            
            </summary>
            <param name="partiallySpecializedParameter"></param>
            <param name="containingSignature"></param>
            <param name="internFactory"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedParameterTypeInformation.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterTypeInformation.ContainingSignature">
            <summary>
            The method or property that defines this parameter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterTypeInformation.Type">
            <summary>
            The type of argument value that corresponds to this parameter.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterTypeInformation.CustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterTypeInformation.Index">
            <summary>
            The position in the parameter list where this instance can be found.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterTypeInformation.InternFactory">
            <summary>
            A collection of methods that associate unique integers with metadata model entities.
            The association is based on the identities of the entities and the factory does not retain
            references to the given metadata model objects.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterTypeInformation.IsByReference">
            <summary>
            True if the parameter is passed by reference (using a managed pointer).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedParameterTypeInformation.IsModified">
            <summary>
            This parameter has one or more custom modifiers associated with it.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.SpecializedPropertyDefinition">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedPropertyDefinition.#ctor(Microsoft.Cci.IPropertyDefinition,Microsoft.Cci.IPropertyDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.GenericTypeInstance)">
            <summary>
            
            </summary>
            <param name="unspecializedVersion"></param>
            <param name="partiallySpecializedVersion"></param>
            <param name="containingTypeDefinition"></param>
            <param name="containingGenericTypeInstance"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedPropertyDefinition.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(IPropertyDefinition) method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedPropertyDefinition.CopyAndSpecialize(Microsoft.Cci.ITypeReference)">
            <summary>
            Makes a copy of the given type reference, making sure that any references to this.partiallySpecializedVersion.ContainingType or something defined, directly or indirectly,
            by this.partiallySpecializedVersion.Containing type are replaced with the corresponding reference to this.ContainingType or something defined, directly or indirectly
            by this.ContainingType. Also replaces all references to type parameters of this.ContainingGenericTypeInstance with the corresponding type arguments.
            </summary>
            <param name="partiallySpecializedTypeReference">A type reference obtained from some part of this.unspecializedVersion.</param>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.Accessors">
            <summary>
            A list of methods that are associated with the property.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.Getter">
            <summary>
            The method used to get the value of this property. May be absent (null).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.Setter">
            <summary>
            The method used to set the value of this property. May be absent (null).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.Type">
            <summary>
            The return type of the method or type of the property.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.DefaultValue">
            <summary>
            A compile time constant value that provides the default value for the property. (Who uses this and why?)
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.HasDefaultValue">
            <summary>
            True if this property has a compile time constant associated with it that serves as a default value for the property. (Who uses this and why?)
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.IsRuntimeSpecial">
            <summary>
            True if the property gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.IsSpecialName">
            <summary>
            True if this property is special in some way, as specified by the name.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.ReturnValueAttributes">
            <summary>
            Custom attributes associated with the property's return value.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.ReturnValueCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. Evaluate this property only if ReturnValueIsModified is true.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.ReturnValueIsByRef">
            <summary>
            True if the return value is passed by reference (using a managed pointer).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.ReturnValueIsModified">
            <summary>
            True if the return value has one or more custom modifiers associated with it.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedPropertyDefinition.CallingConvention">
            <summary>
            Calling convention of the signature.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SystemDefinedStructuralType.InternFactory">
            <summary>
            A collection of methods that associate unique integers with metadata model entities.
            The association is based on the identities of the entities and the factory does not retain
            references to the given metadata model objects.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ArrayType.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IArrayTypeReference)
            </summary>
        </member>
        <member name="M:Microsoft.Cci.CustomModifier.CopyModifierToNewContainer(Microsoft.Cci.ICustomModifier,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a deep copy of a customer modifier. In the copy, every reference to a partially specialized type parameter defined by
            the partially specialized version of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition 
            and generic) will be replaced with the specialized type parameter, defined by targetContainer or its parents.
            </summary>
            <param name="customModifier">An array type reference to be deep copied. </param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in <paramref name="customModifier"/>.</param>
            <param name="internFactory">An intern factory. </param>
        </member>
        <member name="M:Microsoft.Cci.CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.ICustomModifier,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given custom modifier has a modifier that involves a type parameter from the generic method from which the given method was instantiated,
            then return a new custom modifier using a modifier type that has been specialized with the type arguments of the given generic method instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.ICustomModifier,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given custom modifier has a modifier that involves a type parameter from the generic type from which the given type was instantiated,
            then return a new custom modifier using a modifier type that has been specialized with the type arguments of the given generic type instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.CustomModifier.SpecializeIfConstructedFromApplicableMethodTypeParameter(Microsoft.Cci.ICustomModifier,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given custom modifier has a modifier that involves a method type parameter of the unspecialized version of specializedMethodDefinition,
            then return a new custom modifier using a modifier type that is the corresponding method type parameter from specializedMethodDefinition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.FunctionPointerType.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IFunctionPointerTypeReference)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Scope`1">
            <summary>
            A collection of named members, with routines to search and maintain the collection. The search routines have sublinear complexity, typically close to constant time.
            </summary>
            <typeparam name="MemberType">The type of the members of this scope.</typeparam>
        </member>
        <member name="M:Microsoft.Cci.Scope`1.AddMemberToCache(`0)">
            <summary>
            Adds a member to the scope. Does nothing if the member is already in the scope.
            </summary>
            <param name="member">The member to add to the scope.</param>
        </member>
        <member name="M:Microsoft.Cci.Scope`1.Contains(`0)">
            <summary>
            Return true if the given member instance is a member of this scope.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Scope`1.GetMatchingMembersNamed(Microsoft.Cci.IName,System.Boolean,Microsoft.Cci.Function{`0,System.Boolean})">
            <summary>
            Returns the list of members with the given name that also satisfy the given predicate.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Scope`1.GetMatchingMembers(Microsoft.Cci.Function{`0,System.Boolean})">
            <summary>
            Returns the list of members that satisfy the given predicate.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Scope`1.GetMembersNamed(Microsoft.Cci.IName,System.Boolean)">
            <summary>
            Returns the list of members with the given name.
            </summary>
            <param name="name">The name of the members to retrieve.</param>
            <param name="ignoreCase">True if the case of the name must be ignored when retrieving the members.</param>
        </member>
        <member name="M:Microsoft.Cci.Scope`1.InitializeIfNecessary">
            <summary>
            Provides a derived class with an opportunity to lazily initialize the scope's data structures via calls to AddMemberToCache.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Scope`1.Members">
            <summary>
            The collection of member instances that are members of this scope.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericTypeInstance.DeepCopyTypeReference(Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a deep copy of a generic type instance reference. In the copy, every reference to a partially specialized type parameter defined by
            the partially specialized version of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition 
            and generic) will be replaced with the specialized type parameter, defined by targetContainer or its parents.
            </summary>
            <param name="genericTypeInstance">An array type reference to be deep copied. </param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in <paramref name="genericTypeInstance"/>.</param>
             /// <param name="internFactory">An intern factory. </param>
        </member>
        <member name="M:Microsoft.Cci.GenericTypeInstance.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            Specialize component type references of genericTypeInstance and (if necessary) return a new instance of the 
            specialized version of genericTypeInstance.GenericType using the specialized type arguments. Specialization here
            means replacing any references to the generic type parameters of containingMethodInstance.GenericMethod with the
            corresponding values of containingMethodInstance.GenericArguments.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericTypeInstance.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            Specialize the type arguments of genericTypeIntance and (if necessary) return a new instance of containingTypeInstance.GenericType using
            the specialized type arguments. Specialization means replacing any references to the type parameters of containingTypeInstance.GenericType with the
            corresponding values of containingTypeInstance.GenericArguments.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericTypeInstance.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Specialize the type arguments of genericTypeIntance and (if necessary) return a new instance of containingTypeInstance.GenericType using
            the specialized type arguments. Specialization means replacing any references to the method type parameters of 
            specializedMethodDefinition.UnspecializedVersion with the corresponding values of specializedMethodDefinition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.GenericTypeInstance.InternFactory">
            <summary>
            A collection of methods that associate unique integers with metadata model entities.
            The association is based on the identities of the entities and the factory does not retain
            references to the given metadata model objects.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericParameter.DeepCopyTypeReference(Microsoft.Cci.IGenericTypeParameterReference,Microsoft.Cci.SpecializedNestedTypeDefinition)">
            <summary>
            If the genericTypeParameter is a type parameter of the targetContainer, or a type parameter of a containing, generic, specialized
            nested type of the targetContainer, return the specialized version of the type parameter. 
            </summary>
            <remarks>: 
            Example of how a type parameter is from the containing type of the targetContainer:
            class Outer[A] {
              class Mid[T] {
                class Inner {
                  T f;
                }
              }
            }
            Consider Outer[char].Mid[int].Inner.f. It is a specialized field, whose ContainingGenericTypeInstance = Outer[char].Mid[int]
            and whose partiallySpecializedVersion is another specialized field, which we call SF1.
            
            SF1's ContainingGenericTypeInstance is Outer[char]; its ContainingTypeDefinition is Outer[char].Mid.Inner. Its type should be 
            a (specialized) copy of T defined by Outer[char].Mid, which is a specialized nested type definition. Note that the targetContainer
            for SF1 is Outer[char].Mid.Inner. To look for specialized version of T, we need to go to the parent of the targetContainer.
            </remarks>
            <param name="genericTypeParameter">A reference to a generic type parameter that occurs inside orginal container.</param>
            <param name="targetContainer">A specialized nested type definition whose or whose parent's (specialized) type parameters
            are used to replace <paramref name="genericTypeParameter"/>. </param>
        </member>
        <member name="M:Microsoft.Cci.GenericParameter.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IGenericMethodParameterReference,Microsoft.Cci.IGenericMethodInstanceReference)">
            <summary>
            If the given generic parameter is a generic parameter of the generic method of which the given method is an instance, then return the corresponding type argument that
            was used to create the method instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericParameter.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IGenericTypeParameterReference,Microsoft.Cci.IGenericTypeInstanceReference)">
            <summary>
            If the given generic parameter is a generic parameter of the generic type of which the given type is an instance, then return the corresponding type argument that
            was used to create the type instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericParameter.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.IGenericParameterReference,Microsoft.Cci.SpecializedMethodDefinition)">
            <summary>
            If the given genericParameter is a generic method parameter of the unspecialized version of specializedMethodDefinition,
            then return the corresponding generic method parameter of specializedMethodDefinition. If it is a generic type parameter
            of a containing specialized nested type definition of the specializedMethodDefinition, then return the specialized version 
            of the type parameter. 
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ManagedPointerType.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IManagedPointerTypeReference)
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ManagedPointerType.DeepCopyTypeReference(Microsoft.Cci.IManagedPointerTypeReference,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a deep copy of a managed pointer type reference. In the copy, every reference to a partially specialized type parameter defined by
            the partially specialized version of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition 
            and generic) will be replaced with the specialized type parameter, defined by targetContainer or its parents.
            </summary>
            <param name="pointer">An array type reference to be deep copied. </param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in <paramref name="pointer"/>.</param>
             /// <param name="internFactory">An intern factory. </param>
        </member>
        <member name="M:Microsoft.Cci.ManagedPointerType.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IManagedPointerTypeReference,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given managed pointer has a target type that involves a type parameter from the generic method from which the given method was instantiated,
            then return a new pointer using a target type that has been specialized with the type arguments of the given generic method instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ManagedPointerType.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IManagedPointerTypeReference,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given managed pointer has a target type that involves a type parameter from the generic type from which the given type was instantiated,
            then return a new pointer using a target type that has been specialized with the type arguments of the given generic type instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ManagedPointerType.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.IManagedPointerTypeReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given managed pointer has a target type that involves a method type parameter of the unspecialized version of specializedMethodDefinition,
            then return a new pointer using a target type that is the corresponding method type parameter from specializedMethodDefinition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Matrix.DeepCopyTypeReference(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a deep copy of an array type (a vector). In the copy, every reference to a partially specialized type parameter defined by
            the partially specialized version of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition 
            and generic) will be replaced with the specialized type parameter, defined by targetContainer or its parents.
            </summary>
            <param name="array">An array type reference to be deep copied. </param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in <paramref name="array"/>.</param>
             /// <param name="internFactory">An intern factory. </param>
        </member>
        <member name="M:Microsoft.Cci.Matrix.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given matrix has an element type that involves a type parameter from the generic method from which the given method was instantiated,
            then return a new matrix using an element type that has been specialized with the type arguments of the given generic method instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Matrix.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given matrix has an element type that involves a type parameter from the generic type from which the given type was instantiated,
            then return a new matrix using an element type that has been specialized with the type arguments of the given generic type instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Matrix.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given matrix has an element type that involves a method type parameter from the unspecialized version of specializedMethodDefinition,
            then return a new matrix using an element type that has been specialized with the corresponding method type parameter from specializedMethodDefinition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PointerType.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IPointerTypeReference)
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PointerType.DeepCopyTypeReference(Microsoft.Cci.IPointerTypeReference,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a deep copy of a pointer type reference. In the copy, every reference to a partially specialized type parameter defined by
            the partially specialized version of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition 
            and generic) will be replaced with the specialized type parameter, defined by targetContainer or its parents.
            </summary>
            <param name="pointer">An array type reference to be deep copied. </param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in <paramref name="pointer"/>.</param>
             /// <param name="internFactory">An intern factory. </param>
        </member>
        <member name="M:Microsoft.Cci.PointerType.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IPointerTypeReference,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given pointer has a target type that involves a type parameter from the generic method from which the given method was instantiated,
            then return a new pointer using a target type that has been specialized with the type arguments of the given generic method instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PointerType.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IPointerTypeReference,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given pointer has a target type that involves a type parameter from the generic type from which the given type was instantiated,
            then return a new pointer using a target type that has been specialized with the type arguments of the given generic type instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PointerType.DeepCopyTypeReferenceReplacingGenericMethodParamter(Microsoft.Cci.IPointerTypeReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given pointer has a target type that involves a method type parameter of the unspecialized version of specializedMethodDefinition,
            then return a new pointer using a target type that is the corresponding method type parameter from specializedMethodDefinition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ModifiedPointerType.DeepCopyTypeReference(Microsoft.Cci.ModifiedPointerType,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a deep copy of a modified pointer type. In the copy, every reference to a partially specialized type parameter defined by
            the partially specialized version of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition 
            and generic) will be replaced with the specialized type parameter, defined by targetContainer or its parents.
            </summary>
            <param name="modifiedPointer">An array type reference to be deep copied. </param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in <paramref name="modifiedPointer"/>.</param>
             /// <param name="internFactory">An intern factory. </param>
        </member>
        <member name="M:Microsoft.Cci.ModifiedPointerType.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.ModifiedPointerType,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given pointer has a target type that involves a type parameter from the generic method from which the given method was instantiated,
            then return a new pointer using a target type that has been specialized with the type arguments of the given generic method instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ModifiedPointerType.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.ModifiedPointerType,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given modified pointer has a target type that involves a type parameter from the generic type from which the given type was instantiated,
            then return a new pointer using a target type that has been specialized with the type arguments of the given generic type instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ModifiedPointerType.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.ModifiedPointerType,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given modified pointer has a target type that involves a method type parameter of the unspecialized version of specializedMethodDefinition,
            then return a new pointer using a target type that is the corresponding method type parameter from specializedMethodDefinition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ModifiedTypeReference.DeepCopyTypeReference(Microsoft.Cci.IModifiedTypeReference,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a deep copy of a modified type reference. In the copy, every reference to a partially specialized type parameter defined by
            the partially specialized version of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition 
            and generic) will be replaced with the specialized type parameter, defined by targetContainer or its parents.
            </summary>
            <param name="modifiedTypeReference">An array type reference to be deep copied. </param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in <paramref name="modifiedTypeReference"/>.</param>
             /// <param name="internFactory">An intern factory. </param>
        </member>
        <member name="M:Microsoft.Cci.ModifiedTypeReference.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IModifiedTypeReference,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given pointer has a target type that involves a type parameter from the generic method from which the given method was instantiated,
            then return a new pointer using a target type that has been specialized with the type arguments of the given generic method instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ModifiedTypeReference.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IModifiedTypeReference,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given modified pointer has a target type that involves a type parameter from the generic type from which the given type was instantiated,
            then return a new pointer using a target type that has been specialized with the type arguments of the given generic type instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ModifiedTypeReference.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.IModifiedTypeReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given modified type reference has a target type that involves a method type parameter of the unspecialized version of specializedMethodDefinition,
            then return a new type reference using a target type that is the corresponding method type parameter from specializedMethodDefinition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SpecializedGenericTypeParameter">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericTypeParameter.#ctor(Microsoft.Cci.IGenericTypeParameter,Microsoft.Cci.ISpecializedNestedTypeReference,Microsoft.Cci.IInternFactory)">
            <summary>
            
            </summary>
            <param name="partiallySpecializedParameter"></param>
            <param name="definingTypeInstance"></param>
            <param name="internFactory"></param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedGenericTypeParameter.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(IGenericTypeParameter) method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericTypeParameter.ContainingGenericTypeInstance">
            <summary>
            Return the innermost containing generic type instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericTypeParameter.Constraints">
            <summary>
            A list of classes or interfaces. All type arguments matching this parameter must be derived from all of the classes and implement all of the interfaces.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedGenericTypeParameter.DefiningType">
            <summary>
            The generic type that defines this type parameter.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Cci.SpecializedNestedTypeDefinition">
            <summary>
            A type definition that is a specialized nested type. That is, the type definition is a member of a generic type instance, or of another specialized nested type.
            It is specialized, because if it had any references to the type parameters of the generic type, then those references have been replaced with the type arguments of the instance.
            In other words, it may be less generic than before, and hence it has been "specialized".
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedNestedTypeDefinition.#ctor(Microsoft.Cci.INestedTypeDefinition,Microsoft.Cci.INestedTypeDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.GenericTypeInstance,Microsoft.Cci.IInternFactory)">
            <summary>
            Allocates a type definition that is a specialized nested type. That is, the type definition is a member of a generic type instance, or of another specialized nested type.
            It is specialized, because if it had any references to the type parameters of the generic type, then those references have been replaced with the type arguments of the instance.
            In other words, it may be less generic than before, and hence it has been "specialized".
            </summary>
            <param name="unspecializedVersion">The most generic version of the nested type. In other words, the one that the programmer wrote. In persisted metadata, type references are 
            always to instantiations of the unspecialized version, with all inherited type arguments repeated inside the reference.</param>
            <param name="partiallySpecializedVersion">If containingGenericTypeInstance is an instance of a specialized nested generic type, then its members already have been specialized as
            part of the specialization of the generic (template) type. In that case, partiallySpecializedVersion is different from unspecialized version. At any rate, the thing to actually
            specialize if partiallySpecializedVersion. unspecializedVersion is used mainly for mapping to the CLR PE file format.</param>
            <param name="containingGenericTypeInstance">The generic type instance that supplies the type arguments that will be substituted for type parameters to create the specialized nested
            type created by this construtor.</param>
            <param name="containingTypeDefinition">The actual type that contains the specialized member constructed by this constructor. It can either be a generic type instance, or specialized
            nested type.</param>
            <param name="internFactory">The intern factory to use for computing the interned identity of this type and any types and members referenced by it.</param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedNestedTypeDefinition.DeepCopyTypeReference(Microsoft.Cci.INestedTypeReference,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a copy of the given type reference, but with every reference to a partially specialized version of type parameter 
            defined by the partially specialized version of the targetContainer, or of its parent (if the parent is a SpecializedNestedTypeDefinition 
            and generic) replaced with a reference to the specialized type parameter. 
            </summary>
            <remarks>
            We compute the copy of the nestedType by first copying its ContainingType and looking for the nestedType in the members of the copy.
            For example, to make a copy of Type1[T].Type2 with targetContainer being Outer[A].Mid (which has a specialized type parameter T, which we denote by
            T+), we first copy Type1[T] to Type1[T+] and then look for Type2 in the members of Type1[T+]. 
            </remarks>
            <param name="nestedType">A reference to a nested type to be copied.</param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in nestedType.</param>
            <param name="internFactory">An intern factory.</param>
        </member>
        <member name="M:Microsoft.Cci.SpecializedNestedTypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.INestedTypeReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Make a copy of the nested type, with every reference to a (partially specialized version of) generic parameter defined in the 
            partially specialized version of specializedMethodDefinition or its containing specialized nested type replaced with the specialized 
            version of the generic parameter defined in either specializedMethodDefinition or its containing specialized nested type. 
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedNestedTypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.INestedTypeReference,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            Return a copy of the given nestedType, but with every reference to a generic method parameter replaced with corresponding types in genericMethodInstance's
            GenericArguments. 
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedNestedTypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.INestedTypeReference,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given unspecialized type reference is a constructed nested type, then return a new instance (if necessary)
            in which all refererences to the type parameters of containingTypeInstance.GenericType have been replaced with the 
            corresponding values from containingTypeInstance.GenericArguments. 
            
            We compute the nested type by looking it up in the specailized version of its containing type. For example, to specialize Type1[T].Type2
            to Type1[int].Type2, w.r.t. to the current containing instance X[int], we first specialize Type1[T] to Type1[int] and then look for and
            return its member Type2.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SpecializedNestedTypeDefinition.CopyAndSpecialize(Microsoft.Cci.ITypeReference)">
            <summary>
            Makes a copy of the given type reference, making sure that any references to this.partiallySpecializedVersion.ContainingType or something defined, directly or indirectly,
            by this.partiallySpecializedVersion.Containing type are replaced with the equivalent reference to this.ContainingType or something defined, directly or indirectly
            by this.ContainingType. Also replaces all references to type parameters of this.ContainingGenericTypeInstance with the corresponding type arguments.
            </summary>
            <param name="partiallySpecializedTypeReference">A type reference obtained from some part of this.unspecializedVersion.</param>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.BaseClasses">
            <summary>
            Zero or more classes from which this type is derived.
            For CLR types this collection is empty for interfaces and System.Object and populated with exactly one base type for all other types.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.GenericParameters">
            <summary>
            Zero or more parameters that can be used as type annotations.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.ContainingGenericTypeInstance">
            <summary>
            The generic type instance that supplies the mapping from type parameters to type arguments that is used to create this specialized type definition.
            Any type references made by this nested type, such as to its base class, interfaces, or made by members of this nested type, are created by
            specializing the corresponding reference from the partially specialized version of this type, using the mapping defined by this instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.ExplicitImplementationOverrides">
            <summary>
            Zero or more implementation overrides provided by the class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.Interfaces">
            <summary>
            Zero or more interfaces implemented by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.InstanceType">
            <summary>
            An instance of this generic type that has been obtained by using the generic parameters as the arguments.
            Use this instance to look up members
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.Methods">
            <summary>
            Zero or more methods defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.PlatformType">
            <summary>
            A way to get to platform types such as System.Object.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.NestedTypes">
            <summary>
            Zero or more nested types defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.PrivateHelperMembers">
            <summary>
            Zero or more private type members generated by the compiler for implementation purposes. These members
            are only available after a complete visit of all of the other members of the type, including the bodies of methods.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.Properties">
            <summary>
            Zero or more properties defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.UnderlyingType">
            <summary>
            Returns a reference to the underlying (integral) type on which this (enum) type is based.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.UnspecializedVersion">
            <summary>
            The nested type that has been specialized to obtain this nested type. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.Visibility">
            <summary>
            Indicates if the member is public or confined to its containing type, derived types and/or declaring assembly.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.ContainingTypeDefinition">
            <summary>
            The type definition that contains this member.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.Alignment">
            <summary>
            The byte alignment that values of the given type ought to have. Must be a power of 2. If zero, the alignment is decided at runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.Events">
            <summary>
            Zero or more events defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.Fields">
            <summary>
            Zero or more fields defined by this type.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsAbstract">
            <summary>
            True if the type may not be instantiated.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsClass">
            <summary>
            True if the type is a class (it is not an interface or type parameter and does not extend a special base class).
            Corresponds to C# class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsDelegate">
            <summary>
            True if the type is a delegate (it extends System.MultiCastDelegate). Corresponds to C# delegate
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsEnum">
            <summary>
            True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsGeneric">
            <summary>
            True if this type is parameterized (this.GenericParameters is a non empty collection).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsInterface">
            <summary>
            True if the type is an interface.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsReferenceType">
            <summary>
            True if the type is a reference type. A reference type is non static class or interface or a suitably constrained type parameter.
            A type parameter for which MustBeReferenceType (the class constraint in C#) is true returns true for this property
            as does a type parameter with a constraint that is a class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsSealed">
            <summary>
            True if the type may not be subtyped.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsStatic">
            <summary>
            True if the type is an abstract sealed class that directly extends System.Object and declares no constructors.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsValueType">
            <summary>
            True if the type is a value type.
            Value types are sealed and extend System.ValueType or System.Enum.
            A type parameter for which MustBeValueType (the struct constraint in C#) is true also returns true for this property.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.IsStruct">
            <summary>
            True if the type is a struct (its not Primitive, is sealed and base is System.ValueType).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.SizeOf">
            <summary>
            Size of an object of this type. In bytes. If zero, the size is unspecified and will be determined at runtime.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.SecurityAttributes">
            <summary>
            Declarative security actions for this type. Will be empty if this.HasSecurity is false.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.TypeCode">
            <summary>
            Unless the value of TypeCode is PrimitiveTypeCode.NotPrimitive, the type corresponds to a "primitive" CLR type (such as System.Int32) and
            the type code identifies which of the primitive types it corresponds to.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.SpecializedNestedTypeDefinition.InternFactory">
            <summary>
            The intern factory to use for computing the interned identity of this type and any types and members referenced by it.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeDefinition.DeepCopyTypeReference(Microsoft.Cci.ITypeReference,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
             <summary>
             Returns a deep copy of partiallySpecializedTypeReference. In the copy, every reference to a partially specialized type parameter 
             of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition and generic) is 
             replaced with the specialized type parameter defined by targetContainer or its parents. 
             </summary>
             <remarks>
             The deep copy happens when we create a specialized member, such as a specialized method, property, field, parameters and so on.
             We must obtain a copy of any type reference in the member, which should not share nodes with the original type reference (called
             the partially specialized version) if the node contains generic parameters that may get specialized. Without such a copy, 
             the instantiation of a generic type or method will not work. In the new copy, the references to (partially specialized) generic 
             parameters must be replaced by the specialized version defined by the specialized parents of the specialized member. 
             
             For example, consider A[int].B[T1 =&gt; T1+], where A[int] is a generic type instance which contains a specialized nested type
             B, which has a generic type parameter T1 that is specialized to T1+. Now any type reference inside B[T1=&gt;T1+], such as types 
             of fields, methods, properties, and so on, must be copied and have any reference to T1 replaced by T1+. 
            
             Similar deep copy happens when specializing a method definition. <seealso cref="M:Microsoft.Cci.TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.ITypeReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)"/>.
             </remarks>
             <param name="partiallySpecializedTypeReference">A type reference to be deep copied. </param>
             <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will replace the occurrences
             of matching type parameters in partiallySpecializedTypeReference. </param>
             <param name="internFactory">An intern factory.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.ITypeReference,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given partially specialized type reference is a constructed type, such as an instance of IArrayTypeReference or IPointerTypeReference 
            or IGenericTypeInstanceReference or INestedTypeReference, then return a new instance (if necessary) in which all refererences to the type 
            parameters of containingMethodInstance.GenericMethod.GenericParameters have been replaced with the corresponding values from containingMethodInstance.GenericArguments. 
            If the type is not a constructed type the method just returns the type. For the purpose of this method, an instance of IGenericParameter is regarded as a constructed type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.ITypeReference,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given partially specialized type reference is a constructed type, such as an instance of IArrayType or IPointerType or 
            IGenericTypeInstance or INestedTypeReference, then return a new instance (if necessary) in which all refererences to the type 
            parameters of containingTypeInstance.GenericType have been replaced with the corresponding values from containingTypeInstance.GenericArguments. 
            If the type is not a constructed type the method just returns the type. For the purpose of this method, an instance of IGenericTypeParameterReference is regarded as a constructed type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.ITypeReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Make a copy of partiallySpecializedTypeReference so that the references to the partially specialized version of generic parameters defined in 
            specializedMethodDefinition and its containing specialized nested type definition (if any) are replaced with the specialized version. 
            </summary>
            <remarks>
            Consider specialized method A[T1 -> T1].B[T2=> T2+].bar[T3 => T3+], where A[T1->T1] is the generic instance obtained from A using its generic parameter
            as the generic argument, A[T1->T1].B[T2=>T2+] is a specialized nested type whose containing type is A[T1->T1] and whose generic type parameter
            T2 is specialized to T2+, and bar[T3=>T3] is further a specialized member of A[T1->T1].B[T2=>T2+] with its generic parameter T3 specialized to 
            T3+. 
            
            Suppose bar has a parameter whose type is X[T2, T3] for some generic type X. The corresponding parameter of of A[T1 -> T1].B[T2=> T2+].bar[T3 => T3+]
            is "specialized". The specialized parameter's type will participate future resolution and should not share nodes that may have been specialized with 
            the original type reference X[T2, T3] (called partially specialized version). We must obtain a copy of the partially specialized version in which we replace 
            the references of T2, T3 with their corresponding specialized versions, namely T2+ and T3+. 
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.Vector.DeepCopyTypeReference(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.SpecializedNestedTypeDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            Returns a deep copy the array type reference. In the copy, every reference to a partially specialized type parameter defined by
            the partially specialized version of targetContainer or of one of targetContainer's parents (if the parent is a SpecializedNestedTypeDefinition 
            and generic) will be replaced with the specialized type parameter, defined by targetContainer or its parents.
            </summary>
            <param name="array">An array type reference to be deep copied. </param>
            <param name="targetContainer">A specialized nested type definition whose or whose parents' (specialized) type parameters will
            replace the occurrences of matching type parameters in <paramref name="array"/>.</param>
             /// <param name="internFactory">An intern factory. </param>
        </member>
        <member name="M:Microsoft.Cci.Vector.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given vector has an element type that involves a type parameter from the generic method from which the given method was instantiated,
            then return a new vector using an element type that has been specialized with the type arguments of the given generic method instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Vector.SpecializeIfConstructedFromApplicableTypeParameter(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given vector has an element type that involves a type parameter from the generic type from which the given type was instantiated,
            then return a new vector using an element type that has been specialized with the type arguments of the given generic type instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Vector.DeepCopyTypeReferenceWRTSpecializedMethod(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.SpecializedMethodDefinition,Microsoft.Cci.IInternFactory)">
            <summary>
            If the given vector has an element type that involves a method type parameter from the unspecialized version of specializedMethodDefinition,
            then return a new vector using an element type that is the corresponding method type paramter from specializedMethodDefinition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.MetadataHostEnvironment">
            <summary>
            Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.#ctor(Microsoft.Cci.INameTable,System.Byte)">
            <summary>
            Allocates an object that provides an abstraction over the application hosting compilers based on this framework.
            </summary>
            <param name="nameTable">
            A collection of IName instances that represent names that are commonly used during compilation.
            This is a provided as a parameter to the host environment in order to allow more than one host
            environment to co-exist while agreeing on how to map strings to IName instances.
            </param>
            <param name="pointerSize">The size of a pointer on the runtime that is the target of the metadata units to be loaded
            into this metadta host. This parameter only matters if the host application wants to work out what the exact layout
            of a struct will be on the target runtime. The framework uses this value in methods such as TypeHelper.SizeOfType and
            TypeHelper.TypeAlignment. If the host application does not care about the pointer size it can provide 0 as the value
            of this parameter. In that case, the first reference to IMetadataHost.PointerSize will probe the list of loaded assemblies
            to find an assembly that either requires 32 bit pointers or 64 bit pointers. If no such assembly is found, the default is 32 bit pointers.
            </param>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.#ctor(Microsoft.Cci.INameTable,Microsoft.Cci.IInternFactory,System.Byte)">
            <summary>
            Allocates an object that provides an abstraction over the application hosting compilers based on this framework.
            </summary>
            <param name="nameTable">
            A collection of IName instances that represent names that are commonly used during compilation.
            This is a provided as a parameter to the host environment in order to allow more than one host
            environment to co-exist while agreeing on how to map strings to IName instances.
            </param>
            <param name="pointerSize">The size of a pointer on the runtime that is the target of the metadata units to be loaded
            into this metadta host. This parameter only matters if the host application wants to work out what the exact layout
            of a struct will be on the target runtime. The framework uses this value in methods such as TypeHelper.SizeOfType and
            TypeHelper.TypeAlignment. If the host application does not care about the pointer size it can provide 0 as the value
            of this parameter. In that case, the first reference to IMetadataHost.PointerSize will probe the list of loaded assemblies
            to find an assembly that either requires 32 bit pointers or 64 bit pointers. If no such assembly is found, the default is 32 bit pointers.
            </param>
            <param name="factory">The intern factory to use when generating keys. When comparing two or more assemblies using
            TypeHelper, MemberHelper, etc. it is necessary to make the hosts use the same intern factory.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.GetContractAssemblySymbolicIdentity">
            <summary>
            Returns the identity of the assembly containing the Microsoft.Contracts.Contract, by asking
            each of the loaded units for its opinion on the matter and returning the opinion with the highest version number.
            If none of the loaded units have an opinion, the result is the same as CoreAssemblySymbolicIdentity.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.GetCoreAssemblySymbolicIdentity">
            <summary>
            Returns the identity of the assembly containing the core system types such as System.Object, by asking
            each of the loaded units for its opinion on the matter and returning the opinion with the highest version number.
            If none of the loaded units have an opinion, the identity of the runtime executing the compiler itself is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.GetSystemCoreAssemblySymbolicIdentity">
            <summary>
            Returns an identity that is the same as CoreAssemblyIdentity, except that the name is "System.Core" and the version is at least 3.5.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.FindAssembly(Microsoft.Cci.AssemblyIdentity)">
            <summary>
            Finds the assembly that matches the given identifier among the already loaded set of assemblies,
            or a dummy assembly if no matching assembly can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.FindModule(Microsoft.Cci.ModuleIdentity)">
            <summary>
            Finds the module that matches the given identifier among the already loaded set of modules,
            or a dummy module if no matching module can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.FindUnit(Microsoft.Cci.UnitIdentity)">
            <summary>
            Finds the unit that matches the given identifier, or a dummy unit if no matching unit can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.GetLocalPath(System.Reflection.AssemblyName)">
            <summary>
            Returns the CodeBase of the named assembly (which is a URL), except if the URL has the file scheme.
            In that case the URL is converted to a local file path that can be used by System.IO.Path methods.
            </summary>
            <param name="assemblyName">The name of the assembly whose location is desired.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.LoadAssembly(Microsoft.Cci.AssemblyIdentity)">
            <summary>
            The assembly that matches the given reference, or a dummy assembly if no matching assembly can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.LoadModule(Microsoft.Cci.ModuleIdentity)">
            <summary>
            The module that matches the given reference, or a dummy module if no matching module can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.LoadUnit(Microsoft.Cci.UnitIdentity)">
            <summary>
            The unit that matches the given identity, or a dummy unit if no matching unit can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.LoadUnitFrom(System.String)">
            <summary>
            Returns the unit that is stored at the given location, or a dummy unit if no unit exists at that location or if the unit at that location is not accessible.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.GetPlatformType">
            <summary>
            Returns an object that provides a collection of references to types from the core platform, such as System.Object and System.String.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.GetTargetPlatformPointerSize">
            <summary>
            Returns an opinion about the size of a pointer on the target runtime for the set of modules
            currently in this.unitCache. If none of the modules requires either 32 bit pointers or 64 bit pointers
            the result is 4 (i.e. 32 bit pointers). This method is only called if a host application has not
            explicitly provided the pointer size of the target platform.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.RegisterAsLatest(Microsoft.Cci.IUnit)">
            <summary>
            Registers the given unit as the latest one associated with the unit's location.
            Such units can then be discovered by clients via GetUnit. 
            </summary>
            <param name="unit">The unit to register.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.ReportErrors(Microsoft.Cci.ErrorEventArgs)">
            <summary>
            Raises the CompilationErrors event with the given error event arguments.
            The event is raised on a separate thread.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.SynchronousReportErrors(System.Object)">
            <summary>
            Raises the CompilationErrors event with the given error event arguments.
            </summary>
            <param name="state">The error event arguments.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.ReportError(Microsoft.Cci.IErrorMessage)">
            <summary>
            Raises the CompilationErrors event with the given error wrapped up in an error event arguments object.
            The event is raised on a separate thread.
            </summary>
            <param name="error">The error to report.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.ProbeAssemblyReference(Microsoft.Cci.IUnit,Microsoft.Cci.AssemblyIdentity)">
            <summary>
            Given the identity of a referenced assembly (but not its location), apply host specific policies for finding the location
            of the referenced assembly.
            </summary>
            <param name="referringUnit">The unit that is referencing the assembly. It will have been loaded from somewhere and thus
            has a known location, which will typically be probed for the referenced assembly.</param>
            <param name="referencedAssembly">The assembly being referenced. This will not have a location since there is no point in probing
            for the location of an assembly when you already know its location.</param>
            <returns>
            An assembly identity that matches the given referenced assembly identity, but which includes a location.
            If the probe failed to find the location of the referenced assembly, the location will be "unknown://location".
            </returns>
            <remarks>
            Default implementation of ProbeAssemblyReference. Override this method to change its behavior.
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.ProbeModuleReference(Microsoft.Cci.IUnit,Microsoft.Cci.ModuleIdentity)">
            <summary>
            Given the identity of a referenced module (but not its location), apply host specific policies for finding the location
            of the referenced module.
            </summary>
            <param name="referringUnit">The unit that is referencing the module. It will have been loaded from somewhere and thus
            has a known location, which will typically be probed for the referenced module.</param>
            <param name="referencedModule">Module being referenced.</param>
            <returns>
            A module identity that matches the given referenced module identity, but which includes a location.
            If the probe failed to find the location of the referenced assembly, the location will be "unknown://location".
            </returns>
            <remarks>
            Default implementation of ProbeModuleReference. Override this method to change the behavior.
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.MetadataHostEnvironment.UnifyAssembly(Microsoft.Cci.AssemblyIdentity)">
            <summary>
            Default implementation of UnifyAssembly. Override this method to change the behaviour.
            </summary>
        </member>
        <member name="E:Microsoft.Cci.MetadataHostEnvironment.Errors">
            <summary>
            The errors reported by this event are discovered in background threads by an opend ended
            set of error reporters. Listeners to this event should thus be prepared to be called at abitrary times from arbitrary threads.
            Each occurrence of the event concerns a particular source location and a particular error reporter.
            The reported error collection (possibly empty) supercedes any errors previously reported by the same error reporter for the same source location.
            A source location can be an entire ISourceDocument, or just a part of it (the latter would apply to syntax errors discovered by an incremental
            parser after an edit to the source document).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataHostEnvironment.ContractAssemblySymbolicIdentity">
            <summary>
            The identity of the assembly containing Microsoft.Contracts.Contract.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataHostEnvironment.CoreAssemblySymbolicIdentity">
            <summary>
            The identity of the assembly containing the core system types such as System.Object.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataHostEnvironment.SystemCoreAssemblySymbolicIdentity">
            <summary>
            The identity of the System.Core assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataHostEnvironment.InternFactory">
            <summary>
            A collection of methods that associate unique integers with metadata model entities.
            The association is based on the identities of the entities and the factory does not retain
            references to the given metadata model objects.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataHostEnvironment.LoadedUnits">
            <summary>
            Returns enumeration of all the units loaded so far.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataHostEnvironment.NameTable">
            <summary>
            A table used to intern strings used as names.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataHostEnvironment.PlatformType">
            <summary>
            A collection of references to types from the core platform, such as System.Object and System.String.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataHostEnvironment.PointerSize">
            <summary>
            The size (in bytes) of a pointer on the platform on which the host is targetting.
            The value of this property is either 4 (32-bits) or 8 (64-bit).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.GlobalLock">
            <summary>
            Static class encasulating the global lock object.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.GlobalLock.LockingObject">
            <summary>
            All synchronization code should exclusively use this lock object,
            hence making it trivial to ensure that there are no deadlocks.
            It also means that the lock should never be held for long.
            In particular, no code holding this lock should ever wait on another thread.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataReaderHost">
            <summary>
            An interface provided by the application hosting the metadata reader. The interface allows the host application
            to control how assembly references are unified, where files are found and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataReaderHost.OpenBinaryDocument(Microsoft.Cci.IBinaryDocument)">
            <summary>
            Open the binary document as a memory block in host dependent fashion.
            </summary>
            <param name="sourceDocument">The binary document that is to be opened.</param>
            <returns>The unmanaged memory block corresponding to the source document.</returns>
        </member>
        <member name="M:Microsoft.Cci.IMetadataReaderHost.OpenBinaryDocument(Microsoft.Cci.IBinaryDocument,System.String)">
            <summary>
            Open the child binary document within the context of parent source document.as a memory block in host dependent fashion 
            For example: in multimodule assemblies the main module will be parentSourceDocument, where as other modules will be child
            docuements.
            </summary>
            <param name="parentSourceDocument">The source document indicating the child document location.</param>
            <param name="childDocumentName">The name of the child document.</param>
            <returns>The unmanaged memory block corresponding to the child document.</returns>
        </member>
        <member name="M:Microsoft.Cci.IMetadataReaderHost.ResolvingAssemblyReference(Microsoft.Cci.IUnit,Microsoft.Cci.AssemblyIdentity)">
            <summary>
            This method is called when the assembly reference is being resolved and its not already loaded by the host.
            </summary>
            <param name="referringUnit">The unit that is referencing the assembly.</param>
            <param name="referencedAssembly">Assembly identifier for the assembly being referenced.</param>
        </member>
        <member name="M:Microsoft.Cci.IMetadataReaderHost.ResolvingModuleReference(Microsoft.Cci.IUnit,Microsoft.Cci.ModuleIdentity)">
            <summary>
            This method is called when the module reference is being resolved and its not already loaded by the host.
            </summary>
            <param name="referringUnit">The unit that is referencing the module.</param>
            <param name="referencedModule">Module identifier for the assembly being referenced.</param>
        </member>
        <member name="M:Microsoft.Cci.IMetadataReaderHost.StartGuessingGame">
            <summary>
            Called by the metadata reader when it is about to start parsing a custom attribute blob.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataReaderHost.TryNextPermutation">
            <summary>
            Called by the metadata reader when it has unsucessfully tried to parse a custom attribute blob and it now needs to try a new permutation.
            Returns false if no more perumations are possible.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataReaderHost.WinGuessingGame">
            <summary>
            Called by the metadata reader when it has successfully parsed a custom attribute blob.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns a guess of the size of the underlying type of the given type reference to an enum type, which is assumed to be unresolvable
            because it is defined an assembly that is not loaded into this host. Successive calls to the method will cycle through these values
            with a periodicity determined by the number of types in the game and the successful guesses made in earlier games.
            </summary>
            <param name="reference">A type reference that cannot be resolved.</param>
            <returns>1, 2, 4 or 8.</returns>
        </member>
        <member name="T:Microsoft.Cci.MetadataReaderHost">
            <summary>
            A base class for an object provided by the application hosting the metadata reader. The object allows the host application
            to control how assembly references are unified, where files are found and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.#ctor">
            <summary>
            Allocates an object that provides an abstraction over the application hosting compilers based on this framework.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Allocates an object that provides an abstraction over the application hosting compilers based on this framework.
            </summary>
            <param name="searchPaths">
            A collection of strings that are interpreted as valid paths which are used to search for units.
            </param>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Allocates an object that provides an abstraction over the application hosting compilers based on this framework.
            </summary>
            <param name="searchPaths">
            A collection of strings that are interpreted as valid paths which are used to search for units.
            </param>
            <param name="searchInGAC">
            Whether the GAC (Global Assembly Cache) should be searched when resolving references.
            </param>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.#ctor(Microsoft.Cci.INameTable)">
            <summary>
            Allocates an object that provides an abstraction over the application hosting compilers based on this framework.
            </summary>
            <param name="nameTable">
            A collection of IName instances that represent names that are commonly used during compilation.
            This is a provided as a parameter to the host environment in order to allow more than one host
            environment to co-exist while agreeing on how to map strings to IName instances.
            </param>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.#ctor(Microsoft.Cci.INameTable,System.Byte)">
            <summary>
            Allocates an object that provides an abstraction over the application hosting compilers based on this framework.
            </summary>
            <param name="nameTable">
            A collection of IName instances that represent names that are commonly used during compilation.
            This is a provided as a parameter to the host environment in order to allow more than one host
            environment to co-exist while agreeing on how to map strings to IName instances.
            </param>
            <param name="pointerSize">The size of a pointer on the runtime that is the target of the metadata units to be loaded
            into this metadta host. This parameter only matters if the host application wants to work out what the exact layout
            of a struct will be on the target runtime. The framework uses this value in methods such as TypeHelper.SizeOfType and
            TypeHelper.TypeAlignment. If the host application does not care about the pointer size it can provide 0 as the value
            of this parameter. In that case, the first reference to IMetadataHost.PointerSize will probe the list of loaded assemblies
            to find an assembly that either requires 32 bit pointers or 64 bit pointers. If no such assembly is found, the default is 32 bit pointers.
            </param>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.#ctor(Microsoft.Cci.INameTable,Microsoft.Cci.IInternFactory,System.Byte)">
            <summary>
            Allocates an object that provides an abstraction over the application hosting compilers based on this framework.
            </summary>
            <param name="nameTable">
            A collection of IName instances that represent names that are commonly used during compilation.
            This is a provided as a parameter to the host environment in order to allow more than one host
            environment to co-exist while agreeing on how to map strings to IName instances.
            </param>
            <param name="factory">The intern factory to use when generating keys. When comparing two or more assemblies using
            TypeHelper, MemberHelper, etc. it is necessary to make the hosts use the same intern factory.</param>
            /// <param name="pointerSize">The size of a pointer on the runtime that is the target of the metadata units to be loaded
            into this metadta host. This parameter only matters if the host application wants to work out what the exact layout
            of a struct will be on the target runtime. The framework uses this value in methods such as TypeHelper.SizeOfType and
            TypeHelper.TypeAlignment. If the host application does not care about the pointer size it can provide 0 as the value
            of this parameter. In that case, the first reference to IMetadataHost.PointerSize will probe the list of loaded assemblies
            to find an assembly that either requires 32 bit pointers or 64 bit pointers. If no such assembly is found, the default is 32 bit pointers.
            </param>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.AddLibPath(System.String)">
            <summary>
            Adds a new directory (path) to the list of search paths for which
            to look in when searching for a unit to load.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.Probe(System.String,Microsoft.Cci.AssemblyIdentity)">
            <summary>
            Looks in the specified <paramref name="probeDir"/> to see if a file
            exists, first with the extension "dll" and then with the extension "exe".
            Returns null if not found, otherwise constructs a new AssemblyIdentity
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.ProbeAssemblyReference(Microsoft.Cci.IUnit,Microsoft.Cci.AssemblyIdentity)">
            <summary>
            Given the identity of a referenced assembly (but not its location), apply host specific policies for finding the location
            of the referenced assembly.
            Returns an assembly identity that matches the given referenced assembly identity, but which includes a location.
            If the probe failed to find the location of the referenced assembly, the location will be "unknown://location".
            </summary>
            <param name="referringUnit">The unit that is referencing the assembly. It will have been loaded from somewhere and thus
            has a known location, which will typically be probed for the referenced assembly.</param>
            <param name="referencedAssembly">The assembly being referenced. This will not have a location since there is no point in probing
            for the location of an assembly when you already know its location.</param>
            <returns>
            An assembly identity that matches the given referenced assembly identity, but which includes a location.
            If the probe failed to find the location of the referenced assembly, the location will be "unknown://location".
            </returns>
            <remarks>
            Looks for the referenced assembly first in the same directory as the referring unit, then
            in any search paths provided to the constructor, then finally the GAC.
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.OpenBinaryDocument(Microsoft.Cci.IBinaryDocument)">
            <summary>
            Open the binary document as a memory block in host dependent fashion.
            </summary>
            <param name="sourceDocument">The binary document that is to be opened.</param>
            <returns>The unmanaged memory block corresponding to the source document.</returns>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.OpenBinaryDocument(Microsoft.Cci.IBinaryDocument,System.String)">
            <summary>
            Open the child binary document within the context of parent source document.as a memory block in host dependent fashion 
            For example: in multimodule assemblies the main module will be parentSourceDocument, where as other modules will be child
            docuements.
            </summary>
            <param name="parentSourceDocument">The source document indicating the child document location.</param>
            <param name="childDocumentName">The name of the child document.</param>
            <returns>The unmanaged memory block corresponding to the child document.</returns>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.ResolvingAssemblyReference(Microsoft.Cci.IUnit,Microsoft.Cci.AssemblyIdentity)">
            <summary>
            This method is called when the assembly reference is being resolved and its not already loaded by the Read/Write host.
            </summary>
            <param name="referringUnit">The unit that is referencing the assembly.</param>
            <param name="referencedAssembly">Assembly identity for the assembly being referenced.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.ResolvingModuleReference(Microsoft.Cci.IUnit,Microsoft.Cci.ModuleIdentity)">
            <summary>
            This method is called when the module reference is being resolved and its not already loaded by the Read/Write host.
            </summary>
            <param name="referringUnit">The unit that is referencing the module.</param>
            <param name="referencedModule">Module identity for the assembly being referenced.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.StartGuessingGame">
            <summary>
            Called by the metadata reader when it is about to start parsing a custom attribute blob.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.TryNextPermutation">
            <summary>
            Called by the metadata reader when it has unsucessfully tried to parse a custom attribute blob and it now needs to try a new permutation.
            Returns false if no more perumations are possible.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.WinGuessingGame">
            <summary>
            Called by the metadata reader when it has successfully parsed a custom attribute blob.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns a guess of the size of the underlying type of the given type reference to an enum type, which is assumed to be unresolvable
            because it is defined an assembly that is not loaded into this host. Successive calls to the method will cycle through these values
            with a periodicity determined by the number of types in the game and the successful guesses made in earlier games.
            </summary>
            <param name="reference">A type reference that cannot be resolved.</param>
            <returns>1, 2, 4 or 8.</returns>
        </member>
        <member name="P:Microsoft.Cci.MetadataReaderHost.SearchInGAC">
            <summary>
            Sets or gets the boolean that determines if lookups of assemblies searches the GAC by default.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataReaderHost.LibPaths">
            <summary>
            A potentially empty list of directory paths that will be searched when probing for an assembly reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.InternFactory.GetGenericMethodParameterReferenceInternId(Microsoft.Cci.IMethodReference,System.UInt32)">
            <summary>
            Returns the interned key for the generic method parameter constructed with the given index
            </summary>
            <param name="definingMethodReference">A reference to the method defining the referenced generic parameter.</param>
            <param name="index">The index of the referenced generic parameter. This is an index rather than a name because metadata in CLR
            PE files contain only the index, not the name.</param>
        </member>
        <member name="T:Microsoft.Cci.NameTable">
            <summary>
            A collection of IName instances that represent names that are commonly used during compilation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NameTable.#ctor">
            <summary>
            Allocates a collection of IName instances that represent names that are commonly used during compilation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NameTable.GetNameFor(System.String)">
            <summary>
            Gets a cached IName instance corresponding to the given string. If no cached instance exists, a new instance is created.
            The method is only available to fully trusted code since it allows the caller to cause new objects to be added to the cache.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.NameTable.EmptyName">
            <summary>
            The Empty name.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1">
            <summary>
            Hashtable that can host multiple values for the same uint key.
            </summary>
            <typeparam name="InternalT"></typeparam>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.#ctor">
            <summary>
            Constructor for MultiHashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.#ctor(System.UInt32)">
            <summary>
            Constructor for MultiHashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.Add(System.UInt32,`0)">
            <summary>
            Add element to MultiHashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.Contains(System.UInt32,`0)">
            <summary>
            Checks if key and value is present in the MultiHashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.GetValuesFor(System.UInt32)">
            <summary>
            Enumeration to return all the values associated with the given key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.Count">
            <summary>
            Count of elements in MultiHashtable
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.Values">
            <summary>
            Enumeration of all the values
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.KeyedValuesEnumerator">
            <summary>
            Enumerator to enumerate values with given key.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.KeyedValuesEnumerator.MoveNext">
            <summary>
            Move to next element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.KeyedValuesEnumerator.Reset">
            <summary>
            Reset the enumeration.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.KeyedValuesEnumerator.Current">
            <summary>
            Get the current element.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.KeyedValuesEnumerable">
            <summary>
            Enumerable to enumerate values with given key.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.KeyedValuesEnumerable.GetEnumerator">
            <summary>
            Return the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.ValuesEnumerator">
            <summary>
            Enumerator to enumerate all values.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.ValuesEnumerator.MoveNext">
            <summary>
            Move to next element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.ValuesEnumerator.Reset">
            <summary>
            Reset the enumeration.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.ValuesEnumerator.Current">
            <summary>
            Get the current element.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.ValuesEnumerable">
            <summary>
            Enumerable to enumerate all values.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.MultiHashtable`1.ValuesEnumerable.GetEnumerator">
            <summary>
            Return the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.Hashtable`1">
            <summary>
            Hashtable that can hold only single value per uint key.
            </summary>
            <typeparam name="InternalT"></typeparam>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable`1.#ctor">
            <summary>
            Constructor for Hashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable`1.#ctor(System.UInt32)">
            <summary>
            Constructor for Hashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable`1.Add(System.UInt32,`0)">
            <summary>
            Add element to the Hashtable
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable`1.Find(System.UInt32)">
            <summary>
            Find element in the Hashtable
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.Hashtable`1.Count">
            <summary>
            Number of elements
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.Hashtable`1.Values">
            <summary>
            Enumerable of all the values
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.Hashtable`1.ValuesEnumerator">
            <summary>
            Enumerator for elements
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable`1.ValuesEnumerator.MoveNext">
            <summary>
            Move to next element
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable`1.ValuesEnumerator.Reset">
            <summary>
            Reset the enumerator
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.Hashtable`1.ValuesEnumerator.Current">
            <summary>
            Current element
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.Hashtable`1.ValuesEnumerable">
            <summary>
            Enumerable for elements
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable`1.ValuesEnumerable.GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.Hashtable">
            <summary>
            Hashtable that can hold only single uint value per uint key.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable.#ctor">
            <summary>
            Constructor for Hashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable.#ctor(System.UInt32)">
            <summary>
            Constructor for Hashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable.Add(System.UInt32,System.UInt32)">
            <summary>
            Add element to the Hashtable
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable.Find(System.UInt32)">
            <summary>
            Find element in the Hashtable
            </summary>
            <param name="key"></param>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.Hashtable.Count">
            <summary>
            Number of elements
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.Hashtable.Values">
            <summary>
            Enumerable of all the values
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.Hashtable.ValuesEnumerator">
            <summary>
            Enumerator for elements
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable.ValuesEnumerator.MoveNext">
            <summary>
            Move to next element
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable.ValuesEnumerator.Reset">
            <summary>
            Reset the enumerator
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.Hashtable.ValuesEnumerator.Current">
            <summary>
            Current element
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.Hashtable.ValuesEnumerable">
            <summary>
            Enumerable for elements
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.Hashtable.ValuesEnumerable.GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.DoubleHashtable">
            <summary>
            Hashtable that has two uints as its key. Its value is also uint
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.DoubleHashtable.#ctor">
            <summary>
            Constructor for DoubleHashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.DoubleHashtable.#ctor(System.UInt32)">
            <summary>
            Constructor for DoubleHashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.DoubleHashtable.Add(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Add element to the Hashtable
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.DoubleHashtable.Find(System.UInt32,System.UInt32)">
            <summary>
            Fine element in the Hashtable
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.DoubleHashtable.Count">
            <summary>
            Count of elements
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UtilityDataStructures.DoubleHashtable`1">
            <summary>
            Hashtable that has two uints as its key.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.DoubleHashtable`1.#ctor">
            <summary>
            Constructor for DoubleHashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.DoubleHashtable`1.#ctor(System.UInt32)">
            <summary>
            Constructor for DoubleHashtable
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.DoubleHashtable`1.Add(System.UInt32,System.UInt32,`0)">
            <summary>
            Add element to the DoubleHashtable
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.UtilityDataStructures.DoubleHashtable`1.Find(System.UInt32,System.UInt32)">
            <summary>
            Find element in DoubleHashtable
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.UtilityDataStructures.DoubleHashtable`1.Count">
            <summary>
            Count of elements
            </summary>
        </member>
        <member name="T:Microsoft.Cci.MemberHelper">
            <summary>
            Helper class for computing information from the structure of ITypeDefinitionMember instances.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.ComputeFieldOffset(Microsoft.Cci.ITypeDefinitionMember,Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns the number of bytes that separate the start of an instance of the items's declaring type from the start of the field itself.
            </summary>
            <param name="item">The item (field or nested type) of interests, which must not be static. </param>
            <param name="containingTypeDefinition">The type containing the item.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GetExplicitlyOverriddenMethods(Microsoft.Cci.IMethodDefinition)">
            <summary>
            Returns zero or more base class and interface methods that are explicitly overridden by the given method.
            </summary>
            <remarks>
            IMethodReferences are returned (as opposed to IMethodDefinitions) because the references are directly available:
            no resolving is needed to find them.
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GetFieldBitOffset(Microsoft.Cci.IFieldDefinition)">
            <summary>
            Returns the number of least significant bits in the representation of field.Type that should be ignored when reading or writing the field value at MemberHelper.GetFieldOffset(field).
            </summary>
            <param name="field">The bit field whose bit offset is to returned.</param>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GetFieldOffset(Microsoft.Cci.IFieldDefinition)">
            <summary>
            Get the field offset of a particular field, whose containing type may have its own policy
            of assigning offset. For example, a struct and a union in C may be different. 
            </summary>
            <param name="field">The field whose offset is to returned. The field must not be static.</param>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.MethodsAreEquivalent(Microsoft.Cci.IMethodDefinition,Microsoft.Cci.IMethodDefinition)">
            <summary>
            Returns true iff the two methods are identical (if they are both non-generic) or
            if they are equivalent modulo method generic type parameters (if they are both generic).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GetImplicitlyImplementedInterfaceMethods(Microsoft.Cci.IMethodDefinition)">
            <summary>
            Returns zero or more interface methods that are implemented by the given method. Only methods from interfaces that
            are directly implemented by the containing type of the given method are returned. Interfaces declared on base classes
            are always fully implemented by the base class, albeit sometimes by an abstract method that is itself implemented by a derived class method.
            </summary>
            <remarks>
            IMethodDefinitions are returned (as opposed to IMethodReferences) because it isn't possible to find the interface methods
            without resolving the interface references to their definitions.
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GetImplicitlyOverriddenBaseClassMethod(Microsoft.Cci.IMethodDefinition)">
            <summary>
            Returns the method from the closest base class that is overridden by the given method.
            If no such method exists, Dummy.Method is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GetImplicitlyOverridingDerivedClassMethod(Microsoft.Cci.IMethodDefinition,Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns the method from the derived class that overrides the given method.
            If no such method exists, Dummy.Method is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GetMemberSignature(Microsoft.Cci.ITypeMemberReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type member definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GetMethodSignature(Microsoft.Cci.IMethodReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given method definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.IsVisibleOutsideAssembly(Microsoft.Cci.ITypeDefinitionMember)">
            <summary>
            Decides if the given type definition member is visible outside of the assembly it
            is defined in.
            It does not take into account friend assemblies: the meaning of this method
            is that it returns true for those members that are visible outside of their
            defining assembly to *all* assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.IsVolatile(Microsoft.Cci.IFieldDefinition)">
            <summary>
            Returns true if the field signature has the System.Runtime.CompilerServices.IsVolatile modifier.
            Such fields should only be accessed with volatile reads and writes.
            </summary>
            <param name="field">The field to inspect for the System.Runtime.CompilerServices.IsVolatile modifier.</param>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.SignaturesAreEqual(Microsoft.Cci.ISignature,Microsoft.Cci.ISignature)">
            <summary>
            Returns true if the two signatures match according to the criteria of the CLR loader.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemberHelper.GenericMethodSignaturesAreEqual(Microsoft.Cci.IMethodDefinition,Microsoft.Cci.IMethodDefinition)">
            <summary>
            Returns true if the two generic method signatures match according to the criteria of the CLR loader.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.MemberHelper.GenericMethodParameterEqualityComparer">
            <summary>
            A static instance of type GenericMethodParameterInformationComparer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.MemberHelper.ParameterInformationComparer">
            <summary>
            A static instance of type ParameterInformationComparer.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.MethodReference">
            <summary>
            A reference to a method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MethodReference.#ctor(Microsoft.Cci.IMetadataHost,Microsoft.Cci.ITypeReference,Microsoft.Cci.CallingConvention,Microsoft.Cci.ITypeReference,Microsoft.Cci.IName,System.UInt16,Microsoft.Cci.ITypeReference[])">
            <summary>
            Allocates a reference to a method.
            </summary>
            <param name="host">Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.</param>
            <param name="containingType">A reference to the containing type of the referenced method.</param>
            <param name="callingConvention">The calling convention of the referenced method.</param>
            <param name="returnType">The return type of the referenced method.</param>
            <param name="name">The name of the referenced method.</param>
            <param name="genericParameterCount">The number of generic parameters of the referenced method. Zero if the referenced method is not generic.</param>
            <param name="parameterTypes">Zero or more references the types of the parameters of the referenced method.</param>
        </member>
        <member name="M:Microsoft.Cci.MethodReference.#ctor(Microsoft.Cci.IMetadataHost,Microsoft.Cci.ITypeReference,Microsoft.Cci.CallingConvention,Microsoft.Cci.ITypeReference,Microsoft.Cci.IName,System.UInt16,System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterTypeInformation},Microsoft.Cci.ITypeReference[])">
            <summary>
            Allocates a reference to a method.
            </summary>
            <param name="host">Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.</param>
            <param name="containingType">A reference to the containing type of the referenced method.</param>
            <param name="callingConvention">The calling convention of the referenced method.</param>
            <param name="returnType">The return type of the referenced method.</param>
            <param name="name">The name of the referenced method.</param>
            <param name="genericParameterCount">The number of generic parameters of the referenced method. Zero if the referenced method is not generic.</param>
            <param name="parameters">Information about the parameters forming part of the signature of the referenced method.</param>
            <param name="extraParameterTypes">Reference to the types of the the extra arguments supplied by the method call that uses this reference.</param>
        </member>
        <member name="M:Microsoft.Cci.MethodReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IMethodReference).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.MethodReference.host">
            <summary>
            Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MethodReference.Resolve(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Searches the given type, as well as its base classes or base interfaces (if it is an interface), for a method
            that matches this method reference and returns the method. Returns Dummy.Method is no matching method can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MethodReference.ToString">
            <summary>
             Returns a C#-like string that corresponds to the signature of the referenced method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.AcceptsExtraArguments">
            <summary>
            True if the call sites that references the method with this object supply extra arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.CallingConvention">
            <summary>
            The calling convention of the referenced method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.ContainingType">
            <summary>
            A reference to the containing type of the referenced method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.ExtraParameters">
            <summary>
            Information about this types of the extra arguments supplied at the call sites that
            reference the method with this object.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.GenericParameterCount">
            <summary>
            The number of generic parameters of the referenced method. Zero if the referenced method is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.InternedKey">
            <summary>
            Returns the unique interned key associated with the referenced method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.IsGeneric">
            <summary>
            True if the referenced method has generic parameters;
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.Name">
            <summary>
            The name of the referenced method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.ParameterCount">
            <summary>
            The number of required parameters of the referenced method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.ResolvedMethod">
            <summary>
            The method being referred to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodReference.Type">
            <summary>
            The return type of the referenced method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SimpleParameterTypeInformation">
            <summary>
            Information that describes a method or property parameter, but does not include all the information in a IParameterDefinition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SimpleParameterTypeInformation.#ctor(Microsoft.Cci.ISignature,System.UInt16,Microsoft.Cci.ITypeReference)">
            <summary>
            Allocates an object with information that describes a method or property parameter, but does not include all the information in a IParameterDefinition.
            </summary>
            <param name="containingSignature">The method or property that defines the described parameter.</param>
            <param name="index">The position in the parameter list where the described parameter can be found.</param>
            <param name="type">The type of argument value that corresponds to the described parameter.</param>
        </member>
        <member name="P:Microsoft.Cci.SimpleParameterTypeInformation.ContainingSignature">
            <summary>
            The method or property that defines the described parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SimpleParameterTypeInformation.Index">
            <summary>
            The position in the parameter list where the described parameter can be found.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.SimpleParameterTypeInformation.Type">
            <summary>
            The type of argument value that corresponds to the described parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.GenericMethodParameterInformationComparer">
            <summary>
            An object that compares to instances of IParameterTypeInformation for equality using the assumption
            that two generic method type parameters are equivalent if their parameter list indices are the same.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodParameterInformationComparer.Equals(Microsoft.Cci.IParameterDefinition,Microsoft.Cci.IParameterDefinition)">
            <summary>
            Returns true if the given two instances if IParameterTypeInformation are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.GenericMethodParameterInformationComparer.GetHashCode(Microsoft.Cci.IParameterDefinition)">
            <summary>
            Returns a hash code that is the same for any two equivalent instances of IParameterTypeInformation.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ParameterInformationComparer">
            <summary>
            An object that compares to instances of IParameterTypeInformation for equality.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ParameterInformationComparer.Equals(Microsoft.Cci.IParameterTypeInformation,Microsoft.Cci.IParameterTypeInformation)">
            <summary>
            Returns true if the given two instances if IParameterTypeInformation are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ParameterInformationComparer.GetHashCode(Microsoft.Cci.IParameterTypeInformation)">
            <summary>
            Returns a hash code that is the same for any two equivalent instances of IParameterTypeInformation.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SignatureFormatter">
            <summary>
            A collection of methods that format type member signatures as strings. The methods are virtual and reference each other. 
            By default, types are formatting according to C# conventions. However, by overriding one or more of the
            methods, the formatting can be customized for other languages.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.#ctor">
            <summary>
            Allocates an object with a collection of methods that format type member signatures as strings. The methods are virtual and reference each other. 
            By default, types are formatting according to C# conventions. However, by overriding one or more of the
            methods, the formatting can be customized for other languages.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.#ctor(Microsoft.Cci.TypeNameFormatter)">
            <summary>
            Allocates an object with a collection of methods that format type member signatures as strings. The methods are virtual and reference each other. 
            By default, types are formatting according to C# conventions. However, by overriding one or more of the
            methods, the formatting can be customized for other languages.
            </summary>
            <param name="typeNameFormatter">The type name formatter object to use for formatting the type references that occur in the signatures.</param>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.GetEventSignature(Microsoft.Cci.IEventDefinition,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the signature of the given event definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.GetFieldSignature(Microsoft.Cci.IFieldReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the signature of the given field and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.GetMemberSignature(Microsoft.Cci.ITypeMemberReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type member definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.GetMethodSignature(Microsoft.Cci.IMethodReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the signature of the given method and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.GetPropertySignature(Microsoft.Cci.IPropertyDefinition,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the signature of the given property definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.AppendGenericArguments(Microsoft.Cci.IGenericMethodInstanceReference,Microsoft.Cci.NameFormattingOptions,System.Text.StringBuilder)">
            <summary>
            Appends a formatted string of type arguments. Enclosed in angle brackets and comma-delimited.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.AppendGenericParameters(Microsoft.Cci.IMethodReference,Microsoft.Cci.NameFormattingOptions,System.Text.StringBuilder)">
            <summary>
            Appends a formatted string of type parameters. Enclosed in angle brackets and comma-delimited.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.AppendMethodParameters(System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterTypeInformation},Microsoft.Cci.NameFormattingOptions,System.Text.StringBuilder)">
            <summary>
            Appends a formatted string of parameters. Enclosed in parentheses and comma-delimited.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.AppendMethodName(Microsoft.Cci.IMethodReference,Microsoft.Cci.NameFormattingOptions,System.Text.StringBuilder)">
            <summary>
            Appends the method name, optionally including the containing type name and using special names for methods with IsSpecialName set to true.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.AppendParameter(Microsoft.Cci.IParameterTypeInformation,Microsoft.Cci.NameFormattingOptions,System.Text.StringBuilder)">
            <summary>
            Appends a formatted parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.AppendPropertyName(Microsoft.Cci.IPropertyDefinition,Microsoft.Cci.NameFormattingOptions,System.Text.StringBuilder)">
            <summary>
            Appends the method name, optionally including the containing type name.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.AppendPropertyParameters(System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterDefinition},Microsoft.Cci.NameFormattingOptions,System.Text.StringBuilder)">
            <summary>
            Appends a formatted string of parameters. Enclosed in square brackets and comma-delimited.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.AppendReturnTypeSignature(Microsoft.Cci.ISignature,Microsoft.Cci.NameFormattingOptions,System.Text.StringBuilder)">
            <summary>
            Formats the return type of a signature
            </summary>
        </member>
        <member name="M:Microsoft.Cci.SignatureFormatter.MapToDocumentationIdName(System.String)">
            <summary>
            Replaces characters that are not allowed in a documentation id with legal characters.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UnitHelper">
            <summary>
            Class containing helper routines for Units
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.GetAssemblyIdentity(System.Reflection.AssemblyName,Microsoft.Cci.IMetadataHost)">
            <summary>
            Returns the Assembly identity for the assembly name.
            </summary>
            <param name="assemblyName"></param>
            <param name="metadataHost"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.GetAssemblyIdentity(Microsoft.Cci.IAssembly)">
            <summary>
            Allocates an object that identifies a .NET assembly, using the IAssembly object
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.GetModuleIdentity(Microsoft.Cci.IModule)">
            <summary>
            Constructs module identity for the given module
            </summary>
            <param name="module">Module for which the identity is desired.</param>
            <returns>The module identity corresponding to the passed module.</returns>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.ComputePublicKeyToken(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Computes the public key token for the given public key
            </summary>
            <param name="publicKey"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.StrongName(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Computes the string representing the strong name of the given assembly reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.FindType(Microsoft.Cci.INameTable,Microsoft.Cci.IUnit,System.String)">
            <summary>
            Finds a type in the given module using the given type name, expressed in C# notation with dots separating both namespaces and types.
            If no such type can be found Dummy.NamespaceTypeDefinition is returned.
            </summary>
            <param name="nameTable">A collection of IName instances that represent names that are commonly used during compilation.
            This is a provided as a parameter to the host environment in order to allow more than one host
            environment to co-exist while agreeing on how to map strings to IName instances.</param>
            <param name="unit">The unit of metadata to search for the type.</param>
            <param name="typeName">A string containing the fully qualified type name, using C# formatting conventions.</param>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.FindType(Microsoft.Cci.INameTable,Microsoft.Cci.IUnit,System.String,System.Int32)">
            <summary>
            Finds a type in the given module using the given type name, expressed in C# notation with dots separating both namespaces and types.
            If no such type can be found Dummy.NamespaceTypeDefinition is returned.
            </summary>
            <param name="nameTable">A collection of IName instances that represent names that are commonly used during compilation.
            This is a provided as a parameter to the host environment in order to allow more than one host
            environment to co-exist while agreeing on how to map strings to IName instances.</param>
            <param name="unit">The unit of metadata to search for the type.</param>
            <param name="typeName">A string containing the fully qualified type name, using C# formatting conventions.</param>
            <param name="genericParameterCount">The number of generic parameters the returned type should have.</param>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.FindResourceNamed(Microsoft.Cci.IAssembly,Microsoft.Cci.IName)">
            <summary>
            Searches for the resource with given name in the given assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.AssembliesAreEquivalent(Microsoft.Cci.IAssemblyReference,Microsoft.Cci.IAssemblyReference)">
            <summary>
            Returns true if the given two assembly references are to be considered equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.ModulesAreEquivalent(Microsoft.Cci.IModuleReference,Microsoft.Cci.IModuleReference)">
            <summary>
            Returns true if the given two module references are to be considered equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.UnitsAreEquivalent(Microsoft.Cci.IUnitReference,Microsoft.Cci.IUnitReference)">
            <summary>
            Returns true if the given two unit references are to be considered equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.UnitsAreContainmentEquivalent(Microsoft.Cci.IUnitReference,Microsoft.Cci.IUnitReference)">
            <summary>
            Returns true if the given two unit references are to be considered equivalent as containers.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.UnitNamespacesAreEquivalent(Microsoft.Cci.IUnitNamespaceReference,Microsoft.Cci.IUnitNamespaceReference)">
            <summary>
            Returns true if the given two unit namespaces are to be considered equivalent as containers.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UnitSet">
            <summary>
            A set of units that all contribute to a unified root namespace. For example the set of assemblies referenced by a C# project.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitSet.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Cci.IUnit})">
            <summary>
            Constructs a unit set made up of the given (non empty) list of units.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitSet.Contains(Microsoft.Cci.IUnit)">
            <summary>
            Determines if the given unit belongs to this set of units.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UnitSet.Units">
            <summary>
            Enumerates the units making up this set of units.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UnitSet.UnitSetNamespaceRoot">
            <summary>
            A unified root namespace for this set of units. It contains nested namespaces as well as top level types and anything else that implements INamespaceMember.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.AggregatedNamespace`2">
            <summary>
            A namespace definition whose members are aggregations of the members of a collection of containers of the given container type.
            </summary>
            <typeparam name="ContainerType">The type of container that provides the members (or parts of members) for this namespace. For example NamespaceDeclaration.</typeparam>
            <typeparam name="ContainerMemberType">The base type for members supplied by the container. For example IAggregatableNamespaceDeclarationMember.</typeparam>
        </member>
        <member name="T:Microsoft.Cci.AggregatedScope`3">
            <summary>
            A scope whose members are aggregations of the members of a collection of "containers". For example, a symbol table type definition whose members
            are the aggregations of the members of a collection of source type declarations.
            </summary>
            <typeparam name="ScopeMemberType">The base type for members of the aggregated scope. For example ITypeDefinitionMember.</typeparam>
            <typeparam name="ContainerType">The type of container that provides the members (or parts of members) for this scope. For example ITypeDeclaration.</typeparam>
            <typeparam name="ContainerMemberType">The base type for members supplied by the container. For example ITypeDeclarationMember.</typeparam>
        </member>
        <member name="M:Microsoft.Cci.AggregatedScope`3.AddContainerMemberToCache(`2)">
            <summary>
            Takes a container member, gets a corresponding aggregated member for it and adds the latter to the member collection of this scope (if necessary).
            Usually, the container member is added to the declarations collection of the aggregated member. This behavior is overridable. See GetAggregatedMember.
            </summary>
            <param name="member">The container member to aggregate. The aggregation gets cached and shows up in the Members collection of this scope.</param>
        </member>
        <member name="M:Microsoft.Cci.AggregatedScope`3.AddContainer(`1)">
            <summary>
            Adds all of the members of the given container to this scope, after aggregating the members with members from other containers.
            </summary>
            <param name="container">A collection of members to aggregate with members from other containers and add to the members collection of this scope.</param>
        </member>
        <member name="M:Microsoft.Cci.AggregatedScope`3.GetAggregatedMember(`2)">
            <summary>
            Finds or creates an aggregated member instance corresponding to the given member. Usually this should result in the given member being added to the declarations
            collection of the aggregated member.
            </summary>
            <param name="member">The member to aggregate.</param>
        </member>
        <member name="M:Microsoft.Cci.AggregatedNamespace`2.#ctor(Microsoft.Cci.IName)">
            <summary>
            Allocates a namespace definition whose members are aggregations of the members of a collection of containers of the given container type.
            </summary>
            <param name="name">The name of this namespace definition.</param>
        </member>
        <member name="M:Microsoft.Cci.AggregatedNamespace`2.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDoubleDispatcher. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AggregatedNamespace`2.Name">
            <summary>
            The name of this namespace definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AggregatedNamespace`2.RootOwner">
            <summary>
            The object associated with the namespace. For example an IUnit or IUnitSet instance. This namespace is either the root namespace of that object
            or it is a nested namespace that is directly of indirectly nested in the root namespace.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AggregatedNamespace`2.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AggregatedNamespace`2.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.RootUnitSetNamespace">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UnitSetNamespace">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitSetNamespace.#ctor(Microsoft.Cci.IName,Microsoft.Cci.UnitSet)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="unitSet"></param>
        </member>
        <member name="M:Microsoft.Cci.UnitSetNamespace.#ctor(Microsoft.Cci.IName,Microsoft.Cci.IUnitSet,System.Collections.Generic.List{Microsoft.Cci.IUnitNamespace})">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="unitSet"></param>
            <param name="nestedUnitNamespaces"></param>
        </member>
        <member name="M:Microsoft.Cci.UnitSetNamespace.GetAggregatedMember(Microsoft.Cci.INamespaceMember)">
            <summary>
            
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.UnitSetNamespace.Locations">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UnitSetNamespace.RootOwner">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UnitSetNamespace.UnitNamespaces">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UnitSetNamespace.UnitSet">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.RootUnitSetNamespace.#ctor(Microsoft.Cci.IName,Microsoft.Cci.UnitSet)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="unitSet"></param>
        </member>
        <member name="M:Microsoft.Cci.RootUnitSetNamespace.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(IRootUnitSetNamespace) method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.RootUnitSetNamespace.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.NestedUnitSetNamespace">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NestedUnitSetNamespace.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(INestedUnitSetNamespace) method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NestedUnitSetNamespace.InitializeIfNecessary">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NestedUnitSetNamespace.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Cci.NestedUnitSetNamespace.ContainingNamespace">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NestedUnitSetNamespace.ContainingScope">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NestedUnitSetNamespace.Container">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NestedUnitSetNamespace.ContainingUnitSetNamespace">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ClrOperandStackType">
            <summary>
            Represents CLR Operand stack types
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrOperandStackType.Int32">
            <summary>
            Operand stack is 32 bit value. It will be treated independent of sign on the stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrOperandStackType.Int64">
            <summary>
            Operand stack is 64 bit value. It will be treated independent of sign on the stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrOperandStackType.NativeInt">
            <summary>
            Operand stack is platform dependent int value. It will be treated independent of sign on the stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrOperandStackType.Float">
            <summary>
            Operand stack represents a real number. It can be converted to either float or double.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrOperandStackType.Reference">
            <summary>
            Operand stack is a reference to some type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrOperandStackType.Object">
            <summary>
            Operand stack is a reference or value type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrOperandStackType.Pointer">
            <summary>
            Operand stack is a pointer type
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrOperandStackType.Invalid">
            <summary>
            Operand stack is of invalid type
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ClrHelper">
            <summary>
            Helper class to get CLR Type manipulation information.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ClrHelper.ClrOperandStackTypeFor(Microsoft.Cci.ITypeReference)">
            <summary>
            Gives the Clr operand stack type corresponding to the typeDefinition
            </summary>
            <param name="typeReference"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.ClrHelper.ClrOperandStackTypeFor(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Gives the Clr operand stack type corresponding to the PrimitiveTypeCode
            </summary>
            <param name="typeCode"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.ClrHelper.PrimitiveTypeCodeFor(Microsoft.Cci.ClrOperandStackType)">
            <summary>
            Gives the primitive type code corresponding to the ClrOperandStackType
            </summary>
            <param name="numericType"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.ClrHelper.ConversionPossible(Microsoft.Cci.ClrOperandStackType,Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Conversion is possible from value stored on stack of type ClrOpernadStackType to given PrimitiveTypeCode.
            </summary>
            <param name="fromType"></param>
            <param name="toType"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.AddResult">
            <summary>
            Table representing the result of add operation with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.DivMulRemResult">
            <summary>
            Table representing the result of division, multiplication and reminder operation with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.SubResult">
            <summary>
            Table representing the result of substraction operation with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.UnaryResult">
            <summary>
            Table representing the result of negation and not operation with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.CompResult">
            <summary>
            Table representing the result of comparision operation with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.EqCompResult">
            <summary>
            Table representing the result of equality comparision operation with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.IntOperationResult">
            <summary>
            Table representing the result of integer operation (bitwise and, or, xor) with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.ShiftOperationResult">
            <summary>
            Table representing the result of bit shift operation with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ClrHelper.ImplicitConversionPossibleArr">
            <summary>
            Table representing the implicit conversion for the purpose of method calls with respect to ClrOperand stack.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.NameFormattingOptions">
            <summary>
            Options that specify how type and namespace member names should be formatted.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.None">
            <summary>
            Format the name with default options.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.ContractNullable">
            <summary>
            If the type is an instance of System.Nullable&lt;T&gt; format it using a short form, such as T?.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.DocumentationId">
            <summary>
            Format for a unique id string like the ones generated in XML reference files. 
            <remarks>To generate a truly unique and compliant id, this option should not be used in conjunction with other NameFormattingOptions.</remarks>
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.DocumentationIdMemberKind">
            <summary>
            Prefix the kind of member or type to the name. For example "T:System.AppDomain" or "M:System.Object.Equals".
            <para>Full list of prefixes: "T:" = Type, "M:" = Method, "F:" = Field, "E:" = Event, "P:" = Property.</para>
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.EmptyTypeParameterList">
            <summary>
            Include empty type parameter lists with the names of generic types.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.EscapeKeyword">
            <summary>
            If the name of the member is the same as keyword, format the name using the keyword escape syntax. For example: "@if" rather than just "if".
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.FormattingForDocumentationId">
            <summary>
            Perform multiple miscellaneous formatting changes needed for a documentation id.
            <remarks>This option does not perform all formatting necessary for a documentation id; instead use the <see cref="F:Microsoft.Cci.NameFormattingOptions.DocumentationId"/> option for a complete id string like the ones generated in XML reference files.</remarks>
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.MemberKind">
            <summary>
            Prefix the kind of member or type to the name. For example "class System.AppDomain".
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.MethodConstraints">
            <summary>
            Include the type constraints of generic methods in their names.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.Modifiers">
            <summary>
            Include modifiers, such as "static" with the name of the member.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.OmitContainingNamespace">
            <summary>
            Do not include the name of the containing namespace in the name of a namespace member.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.OmitContainingType">
            <summary>
            Do not include the name of the containing type in the name of a type member.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.OmitCustomModifiers">
            <summary>
            Do not include optional and required custom modifiers.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.OmitImplementedInterface">
            <summary>
            If the type member explicitly implements an interface, do not include the name of the interface in the name of the member.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.OmitTypeArguments">
            <summary>
            Do not include type argument names with the names of generic type instances.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.OmitWhiteSpaceAfterListDelimiter">
            <summary>
            Don't insert a space after the delimiter in a list. For example (one,two) rather than (one, two).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.ParameterName">
            <summary>
            Include the names of parameters in the signatures of methods and indexers.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.ParameterModifiers">
            <summary>
            Include modifiers such as "ref" and "out" in the signatures of methods and indexers.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.PreserveSpecialNames">
            <summary>
            Do not transform special names such as .ctor and get_PropertyName into language specific notation.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.ReturnType">
            <summary>
            Include the name of the return types in the signatures of methods and indexers.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.Signature">
            <summary>
            Include the parameter types and optionally additional information such as parameter names.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.SmartTypeName">
            <summary>
            Inlcude the name of the containing type only if it is needed becuase of ambiguity or hiding. Include only as much as is needed to resolve this.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.SmartNamespaceName">
            <summary>
            Inlcude the name of the containing namespace only if it is needed becuase of ambiguity or hiding. Include only as much as is needed to resolve this.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.SupressAttributeSuffix">
            <summary>
            Do not include the "Attribute" suffix in the name of a custom attribute type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.TypeConstraints">
            <summary>
            Include the type parameter constraints of generic types in their names.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.TypeParameters">
            <summary>
            Include type parameters names with the names of generic types.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.UseGenericTypeNameSuffix">
            <summary>
            Append `n where n is the number of type parameters to the type name.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.UseReflectionStyleForNestedTypeNames">
            <summary>
            Use '+' instead of '.' to delimit the boundary between a containing type name and a nested type name.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.Visibility">
            <summary>
            Include the visibility of the member in its name.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.NameFormattingOptions.UseTypeKeywords">
            <summary>
            If the type corresponds to a keyword use the keyword rather than the type name.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeHelper">
            <summary>
            Helper class for computing information from the structure of ITypeDefinition instances.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.BaseClass(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns the Base class. If there is no base type it returns null.
            </summary>
            <param name="typeDef">The type whose base class is to be returned.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.EffectiveBaseClass(Microsoft.Cci.IGenericParameter)">
            <summary>
            Returns the most derived common base class that all types that satisfy the constraints of the given
            generic parameter must derive from.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.IsCompileTimeConstantType(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true a value of this type can be treated as a compile time constant.
            Such values need not be stored in memory in order to be representable. For example, they can appear as part of a CLR instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.IsPrimitiveInteger(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if the CLR allows integer operators to be applied to values of the given type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.IsSignedPrimitiveInteger(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if the CLR allows signed integer operators to be applied to values of the given type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.IsUnsignedPrimitiveInteger(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if the CLR allows unsigned integer operators to be applied to values of the given type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.IsVisibleOutsideAssembly(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Decides if the given type definition is visible to assemblies other than the assembly it is defined in (and other than its friends).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.MergedType(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns the merged type of two types as per the verification algorithm in CLR.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GenericInstanceVisibilityAsTypeMemberVisibility(Microsoft.Cci.TypeMemberVisibility,System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeReference})">
            <summary>
            Returns the most accessible visibility that is not greater than the given visibility and the visibilities of each of the given typeArguments.
            For the purpose of computing the intersection, namespace types are treated as being TypeMemberVisibility.Public or TypeMemberVisibility.Assembly.
            Generic type instances are treated as having a visibility that is the intersection of the generic type's visibility and all of the type arguments' visibilities.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.TypeVisibilityAsTypeMemberVisibility(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns a TypeMemberVisibility value that corresponds to the visibility of the given type definition.
            Namespace types are treated as being TypeMemberVisibility.Public or TypeMemberVisibility.Assembly.
            Generic type instances are treated as having a visibility that is the intersection of the generic type's visibility and all of the type arguments' visibilities.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.VisibilityIntersection(Microsoft.Cci.TypeMemberVisibility,Microsoft.Cci.TypeMemberVisibility)">
            <summary>
            Returns a TypeMemberVisibility value that is as accessible as possible while being no more accessible than either of the two given visibilities.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetDefiningUnit(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns the unit that defines the given type. If the type is a structural type, such as a pointer the result is 
            the defining unit of the element type, or in the case of a generic type instance, the definining type of the generic template type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetDefiningUnitReference(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns a reference to the unit that defines the given referenced type. If the referenced type is a structural type, such as a pointer or a generic type instance,
            then the result is null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetField(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IName)">
            <summary>
            Returns a field of the given declaring type that has the given name.
            If no such field can be found, Dummy.Field is returned.
            </summary>
            <param name="declaringType">The type thats declares the field.</param>
            <param name="fieldName">The name of the field.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetField(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IFieldReference)">
            <summary>
            Returns a field of the given declaring type that has the same name and signature as the given field reference.
            If no such field can be found, Dummy.Field is returned.
            </summary>
            <param name="declaringType">The type thats declares the field.</param>
            <param name="fieldReference">A reference to the field.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetMethod(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IName,Microsoft.Cci.ITypeReference[])">
            <summary>
            Returns a method of the given declaring type that has the given name and that matches the given parameter types.
            If no such method can be found, Dummy.Method is returned.
            </summary>
            <param name="declaringType">The type that declares the method to be returned.</param>
            <param name="methodName">The name of the method.</param>
            <param name="parameterTypes">A list of types that should correspond to the parameter types of the returned method.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetMethod(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeDefinitionMember},Microsoft.Cci.IName,Microsoft.Cci.ITypeReference[])">
            <summary>
            Returns the first method, if any, of the given list of type members that has the given name and that matches the given parameter types.
            If no such method can be found, Dummy.Method is returned.
            </summary>
            <param name="members">A list of type members.</param>
            <param name="methodName">The name of the method.</param>
            <param name="parameterTypes">A list of types that should correspond to the parameter types of the returned method.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetMethod(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IMethodReference)">
            <summary>
            Returns a method of the given declaring type that matches the given method reference.
            If no such method can be found, Dummy.Method is returned.
            </summary>
            <param name="declaringType">The type that declares the method to be returned.</param>
            <param name="methodReference">A method reference whose name and signature matches that of the desired result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetInvokeMethod(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IMetadataHost)">
            <summary>
            Gets the Invoke method from the delegate. Returns Dummy.Method if the delegate type is malformed.
            </summary>
            <param name="delegateType">A delegate type.</param>
            <param name="host">The host application that provided the nametable used by delegateType.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetMethod(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeDefinitionMember},Microsoft.Cci.IMethodReference)">
            <summary>
            Returns the first method, if any, of the given list of type members that matches the signature of the given method.
            If no such method can be found, Dummy.Method is returned.
            </summary>
            <param name="members">A list of type members.</param>
            <param name="methodSignature">A method whose signature matches that of the desired result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetNamespaceName(Microsoft.Cci.IUnitSetNamespace,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given namespace definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetNamespaceName(Microsoft.Cci.IUnitNamespaceReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given namespace definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetNestedType(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IName,System.Int32)">
            <summary>
            Returns the nested type, if any, of the given declaring type with the given name and given generic parameter count.
            If no such type is found, Dummy.NestedType is returned.
            </summary>
            <param name="declaringType">The type to search for a nested type with the given name and number of generic parameters.</param>
            <param name="typeName">The name of the nested type to return.</param>
            <param name="genericParameterCount">The number of generic parameters. Zero if the type is not generic, larger than zero otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.TryGetFullyInstantiatedSpecializedTypeReference(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeReference@)">
            <summary>
            Try to compute the self instance of a type, that is, a fully instantiated and specialized type reference. 
            For example, use T and T1 to instantiate A&lt;T&gt;.B.C&lt;T1&gt;. If successful, result is set to a 
            IGenericTypeInstance if type definition is generic, or a specialized nested type reference if one of
            the parent of typeDefinition is generic, or typeDefinition if none of the above. Failure happens when 
            one of its parent's members is not properly initialized. 
            </summary>
            <param name="typeDefinition">A type definition whose self instance is to be computed.</param>
            <param name="result">The self instantiated reference to typeDefinition. Valid only when returning true. </param>
            <returns>True if the instantiation succeeded. False if typeDefinition is a nested type and we cannot find such a nested type definition 
            in its parent's self instance.</returns>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetTypeName(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns a C#-like string that corresponds to a source expression that would bind to the given type definition when appearing in an appropriate context.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetTypeName(Microsoft.Cci.ITypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.MostDerivedCommonBaseClass(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns the most derived base class that both given types have in common. Returns null if no such class exists.
            For example: if either or both are interface types, then the result is null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.ParametersAreEquivalent(Microsoft.Cci.IParameterTypeInformation,Microsoft.Cci.IParameterTypeInformation)">
            <summary>
            Returns true if two parameters are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.ParameterListsAreEquivalent(System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterTypeInformation},System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterTypeInformation})">
            <summary>
            Returns true if two parameter lists are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.ParameterListsAreEquivalent(System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterDefinition},System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterDefinition})">
            <summary>
            Returns true if two parameter lists of type IParameterDefinition are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.SizeOfType(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns the computed size (number of bytes) of a type. May call the SizeOf property of the type.
            Use SizeOfType(ITypeReference, bool) to suppress the use of the SizeOf property.
            </summary>
            <param name="type">The type whose size is wanted. If not a reference to a primitive type, this type must be resolvable.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.SizeOfType(Microsoft.Cci.ITypeReference,System.Boolean)">
            <summary>
            Returns the computed size (number of bytes) of a type. 
            </summary>
            <param name="type">The type whose size is wanted. If not a reference to a primitive type, this type must be resolvable.</param>
            <param name="mayUseSizeOfProperty">If true the SizeOf property of the given type may be evaluated and used
            as the result of this routine if not 0. Remember to specify false for this parameter when using this routine in the implementation
            of the ITypeDefinition.SizeOf property.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.TypeAlignment(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns the byte alignment that values of the given type ought to have. The result is a power of two and greater than zero.
            May call the Alignment property of the type.
            Use TypeAlignment(ITypeDefinition, bool) to suppress the use of the Alignment property.    
            </summary>
            <param name="type">The type whose size is wanted. If not a reference to a primitive type, this type must be resolvable.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.TypeAlignment(Microsoft.Cci.ITypeReference,System.Boolean)">
            <summary>
            Returns the byte alignment that values of the given type ought to have. The result is a power of two and greater than zero.
            </summary>
            <param name="type">The type whose size is wanted. If not a reference to a primitive type, this type must be resolvable.</param>
            <param name="mayUseAlignmentProperty">If true the Alignment property of the given type may be inspected and used
            as the result of this routine if not 0. Rembmer to specify false for this parameter when using this routine in the implementation
            of the ITypeDefinition.Alignment property.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.ArrayTypesAreEquivalent(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Returns true if the given two array types are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GenericTypeInstancesAreEquivalent(Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.IGenericTypeInstanceReference)">
            <summary>
            Returns true if the given two generic instance types are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.IsAttributeType(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns true if the given type extends System.Attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.PointerTypesAreEquivalent(Microsoft.Cci.IPointerTypeReference,Microsoft.Cci.IPointerTypeReference)">
            <summary>
            Returns true if the given two pointer types are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GenericTypeParametersAreEquivalent(Microsoft.Cci.IGenericTypeParameterReference,Microsoft.Cci.IGenericTypeParameterReference)">
            <summary>
            Returns true if the given two generic type parameters are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GenericMethodParametersAreEquivalent(Microsoft.Cci.IGenericMethodParameterReference,Microsoft.Cci.IGenericMethodParameterReference)">
            <summary>
            Returns true if the given two generic method parameter are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.FunctionPointerTypesAreEquivalent(Microsoft.Cci.IFunctionPointerTypeReference,Microsoft.Cci.IFunctionPointerTypeReference)">
            <summary>
            Returns true if the given two function pointer types are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.NamespaceTypesAreEquivalent(Microsoft.Cci.INamespaceTypeReference,Microsoft.Cci.INamespaceTypeReference)">
            <summary>
            Returns true if the given two function pointer types are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.NestedTypesAreEquivalent(Microsoft.Cci.INestedTypeReference,Microsoft.Cci.INestedTypeReference)">
            <summary>
            Returns true if the given two function pointer types are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.TypesAreEquivalent(Microsoft.Cci.ITypeReference,Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if the given two types are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(Microsoft.Cci.ITypeReference,Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if the given two types are to be considered equivalent for the purpose of generic method signature matching. This differs from
            TypeHelper.TypesAreEquivalent in that two generic method type parameters are considered equivalent if their parameter list indices are the same.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.Type1DerivesFromOrIsTheSameAsType2(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if type1 is the same as type2 or if it is derives from type2.
            Type1 derives from type2 if the latter is a direct or indirect base class.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.Type1DerivesFromType2(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeReference)">
            <summary>
            Type1 derives from type2 if the latter is a direct or indirect base class.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.Type1ImplementsType2(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if the given type definition, or one of its base types, implements the given interface or an interface
            that derives from the given interface.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.Type1IsCovariantWithType2(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if Type1 is CovariantWith Type2 as per CLR.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.TypesAreAssignmentCompatible(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns true if a CLR supplied implicit reference conversion is available to convert a value of the given source type to a corresponding value of the given target type.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeHelper.RelaxedTypeEquivalenceComparer">
            <summary>
            Considers two types to be equivalent even if TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch returns
            true, as opposed to the stricter rules applied by TypeHelper.TypesAreEquivalent.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeHelper.RelaxedTypeEquivalenceComparer.instance">
            <summary>
            A singleton instance of RelaxedTypeEquivalenceComparer that is safe to use in all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.RelaxedTypeEquivalenceComparer.Equals(Microsoft.Cci.ITypeReference,Microsoft.Cci.ITypeReference)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object of type <paramref name="T"/> to compare.</param>
            <param name="y">The second object of type <paramref name="T"/> to compare.</param>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.RelaxedTypeEquivalenceComparer.GetHashCode(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <param name="r">The r.</param>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Microsoft.Cci.TypeNameFormatter">
            <summary>
            A collection of methods that format types as strings. The methods are virtual and reference each other. 
            By default, types are formatting according to C# conventions. However, by overriding one or more of the
            methods, the formatting can be customized for other languages.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.AddGenericParametersIfNeeded(Microsoft.Cci.ITypeReference,System.UInt16,Microsoft.Cci.NameFormattingOptions,System.String)">
            <summary>
            Returns the given type name unless genericParameterCount is greater than zero and NameFormattingOptions.TypeParameters has been specified and the
            type can be resolved. In the latter case, return the type name augmented with the type parameters 
            (or, if NameFormatting.UseGenericTypeNameSuffix has been specified, the type name is agumented with `n where n is the number of parameters).
            </summary>
            <param name="type">A reference to a named type.</param>
            <param name="genericParameterCount">The number of generic parameters the type has.</param>
            <param name="formattingOptions">A set of flags that specify how the type name is to be formatted.</param>
            <param name="typeName">The unmangled, unaugmented name of the type.</param>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetArrayTypeName(Microsoft.Cci.IArrayTypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type reference and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.AppendArrayDimensions(Microsoft.Cci.IArrayTypeReference,System.Text.StringBuilder,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Appends a C#-like specific string of the dimensions of the given array type reference to the given StringBuilder.
            <example>For example, this appends the "[][,]" part of an array like "int[][,]".</example>
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetGenericMethodParameterName(Microsoft.Cci.IGenericMethodParameterReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetGenericTypeParameterName(Microsoft.Cci.IGenericTypeParameterReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetManagedPointerTypeName(Microsoft.Cci.IManagedPointerTypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to a source expression that would bind to the given managed pointer when appearing in an appropriate context.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetModifiedTypeName(Microsoft.Cci.IModifiedTypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to a source expression that would bind to the given modified type when appearing in an appropriate context.
            C# does not actually have such an expression, but the components of this made up expression corresponds to C# syntax.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetNamespaceTypeName(Microsoft.Cci.INamespaceTypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetNamespaceName(Microsoft.Cci.IUnitSetNamespace,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given unit set namespace definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetNamespaceName(Microsoft.Cci.IUnitNamespaceReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given referenced namespace definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetNestedTypeName(Microsoft.Cci.INestedTypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetPointerTypeName(Microsoft.Cci.IPointerTypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetTypeName(Microsoft.Cci.ITypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to the given type definition and that conforms to the specified formatting options.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetTypeKind(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns a C#-like string that identifies the kind of the given type definition. For example, "class" or "delegate".
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetFunctionPointerTypeName(Microsoft.Cci.IFunctionPointerTypeReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to a source expression that would bind to the given funcion pointer type instance when appearing in an appropriate context,
            if course, C# actually had a function pointer type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameFormatter.GetGenericTypeInstanceName(Microsoft.Cci.IGenericTypeInstanceReference,Microsoft.Cci.NameFormattingOptions)">
            <summary>
            Returns a C#-like string that corresponds to a source expression that would bind to the given generic type instance when appearing in an appropriate context.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.AssemblyReference">
            <summary>
            A reference to a .NET assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.AssemblyReference.#ctor(Microsoft.Cci.IMetadataHost,Microsoft.Cci.AssemblyIdentity)">
            <summary>
            Allocates a reference to a .NET assembly.
            </summary>
            <param name="host">Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.</param>
            <param name="assemblyIdentity">The identity of the referenced assembly.</param>
        </member>
        <member name="M:Microsoft.Cci.AssemblyReference.#ctor(Microsoft.Cci.IMetadataHost,Microsoft.Cci.AssemblyIdentity,System.Boolean)">
            <summary>
            Allocates a reference to a .NET assembly.
            </summary>
            <param name="host">Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.</param>
            <param name="assemblyIdentity">The identity of the referenced assembly.</param>
            <param name="isRetargetable">True if the implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.</param>
        </member>
        <member name="M:Microsoft.Cci.AssemblyReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IAssemblyReference).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.AssemblyReference.host">
            <summary>
            Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.Aliases">
            <summary>
            A list of aliases for the root namespace of the referenced assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.AssemblyIdentity">
            <summary>
            The identity of the referenced assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.ContainingAssembly">
            <summary>
            The Assembly that contains this module. May be null if the module is not part of an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.Culture">
            <summary>
            Identifies the culture associated with the assembly reference. Typically specified for sattelite assemblies with localized resources.
            Empty if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.IsRetargetable">
            <summary>
            True if the implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this AssemblyReference instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.ModuleIdentity">
            <summary>
            The identity of the referenced module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.Name">
            <summary>
            The name of the referenced assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.PublicKeyToken">
            <summary>
            The hashed 8 bytes of the public key of the referenced assembly. This is empty if the referenced assembly does not have a public key.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.ResolvedAssembly">
            <summary>
            The referenced assembly, or Dummy.Assembly if the reference cannot be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.ResolvedModule">
            <summary>
            The referenced module, or Dummy.Module if the reference cannot be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.ResolvedUnit">
            <summary>
            The referenced unit, or Dummy.Unit if the reference cannot be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.UnifiedAssemblyIdentity">
            <summary>
            Returns the identity of the assembly reference to which this assembly reference has been unified.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.UnitIdentity">
            <summary>
            The identity of the unit reference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.AssemblyReference.Version">
            <summary>
            The version of the referenced assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.BaseTypeReference">
            <summary>
            A reference to a type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BaseTypeReference.#ctor(Microsoft.Cci.IMetadataHost,System.Boolean,System.Boolean)">
            <summary>
            Allocates a reference to a type.
            </summary>
            <param name="host">Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.</param>
            <param name="isEnum">True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.</param>
            <param name="isValueType">True if the referenced type is a value type.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseTypeReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDefinition. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.BaseTypeReference.host">
            <summary>
            Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BaseTypeReference.Resolve">
            <summary>
            The type definition being referred to.
            In case this type was alias, this is also the type of the aliased type
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.AliasForType">
            <summary>
            Gives the alias for the type
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.InternedKey">
            <summary>
            Returns the unique interned key associated with the type. This takes unification/aliases/custom modifiers into account .
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.IsAlias">
            <summary>
            Indicates if this type reference resolved to an alias rather than a type
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.IsEnum">
            <summary>
            True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.IsValueType">
            <summary>
            True if the type is a value type. 
            Value types are sealed and extend System.ValueType or System.Enum.
            A type parameter for which MustBeValueType (the struct constraint in C#) is true also returns true for this property.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this IReference instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.PlatformType">
            <summary>
            A collection of references to types from the core platform, such as System.Object and System.String.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.BaseTypeReference.TypeCode">
            <summary>
            Unless the value of TypeCode is PrimitiveTypeCode.NotPrimitive, the type corresponds to a "primitive: CLR type (such as System.Int32) and
            the type code identifies which of the primitive types it corresponds to.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ModuleReference">
            <summary>
            A reference to a .NET module.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ModuleReference.#ctor(Microsoft.Cci.IMetadataHost,Microsoft.Cci.ModuleIdentity)">
            <summary>
            Allocates a reference to a .NET module.
            </summary>
            <param name="host">Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.</param>
            <param name="moduleIdentity"></param>
        </member>
        <member name="M:Microsoft.Cci.ModuleReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IModuleReference).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleReference.host">
            <summary>
            Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModuleReference.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModuleReference.ContainingAssembly">
            <summary>
            The Assembly that contains this module. May be null if the module is not part of an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModuleReference.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this ModuleReference instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModuleReference.ModuleIdentity">
            <summary>
            The identity of the referenced module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModuleReference.Name">
            <summary>
            The name of the referenced assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModuleReference.ResolvedModule">
            <summary>
            The referenced module, or Dummy.Module if the reference cannot be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModuleReference.ResolvedUnit">
            <summary>
            The referenced unit, or Dummy.Unit if the reference cannot be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModuleReference.UnitIdentity">
            <summary>
            The identity of the unit reference.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.NamespaceTypeReference">
            <summary>
            A reference to a type definition that is a member of a namespace definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NamespaceTypeReference.#ctor(Microsoft.Cci.IMetadataHost,Microsoft.Cci.IUnitNamespaceReference,Microsoft.Cci.IName,System.UInt16,System.Boolean,System.Boolean,Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Allocates a type definition that is a member of a namespace definition.
            </summary>
            <param name="host">Provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.</param>
            <param name="containingUnitNamespace">The namespace that contains the referenced type.</param>
            <param name="name">The name of the referenced type.</param>
            <param name="genericParameterCount">The number of generic parameters. Zero if the type is not generic.</param>
            <param name="isEnum">True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.</param>
            <param name="isValueType">True if the referenced type is a value type.</param>
            <param name="typeCode">A value indicating if the type is a primitive type or not.</param>
        </member>
        <member name="M:Microsoft.Cci.NamespaceTypeReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(INamespaceTypeReference)
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NamespaceTypeReference.GetResolvedType">
            <summary>
            The namespace type this reference resolves to.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NamespaceTypeReference.Resolve">
            <summary>
            The type definition being referred to.
            In case this type was alias, this is also the type of the aliased type
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NamespaceTypeReference.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NamespaceTypeReference.ContainingUnitNamespace">
            <summary>
            The namespace that contains the referenced type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NamespaceTypeReference.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NamespaceTypeReference.InternedKey">
            <summary>
            Returns the unique interned key associated with the type. This takes unification/aliases/custom modifiers into account .
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NamespaceTypeReference.Name">
            <summary>
            The name of the referenced type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NamespaceTypeReference.ResolvedType">
            <summary>
            The namespace type this reference resolves to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NamespaceTypeReference.TypeCode">
            <summary>
            Unless the value of TypeCode is PrimitiveTypeCode.NotPrimitive, the type corresponds to a "primitive: CLR type (such as System.Int32) and
            the type code identifies which of the primitive types it corresponds to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NamespaceTypeReference.MangleName">
            <summary>
            If true, the type name is mangled by appending "`n" where n is the number of type parameters, if the number of type parameters is greater than 0.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.NestedUnitNamespaceReference">
            <summary>
            A reference to a nested unit namespace.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.NestedUnitNamespaceReference.#ctor(Microsoft.Cci.IUnitNamespaceReference,Microsoft.Cci.IName)">
            <summary>
            Allocates a reference to a nested unit namespace.
            </summary>
            <param name="containingUnitNamespace">A reference to the unit namespace that contains the referenced nested unit namespace.</param>
            <param name="name">The name of the referenced nested unit namespace.</param>
        </member>
        <member name="M:Microsoft.Cci.NestedUnitNamespaceReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(INestedUnitNamespaceReference) method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NestedUnitNamespaceReference.ContainingUnitNamespace">
            <summary>
            A reference to the unit namespace that contains the referenced nested unit namespace.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NestedUnitNamespaceReference.Name">
            <summary>
            The name of the referenced nested unit namespace.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NestedUnitNamespaceReference.ResolvedNestedUnitNamespace">
            <summary>
            The namespace definition being referred to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.NestedUnitNamespaceReference.Unit">
            <summary>
            A reference to the unit that defines the referenced namespace.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PlatformType">
            <summary>
            A collection of references to types from the core platform, such as System.Object and System.String.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PlatformType.#ctor(Microsoft.Cci.IMetadataHost)">
            <summary>
            Allocates a collection of references to types from the core platform, such as System.Object and System.String.
            </summary>
            <param name="host">
            An object that provides a standard abstraction over the applications that host components that provide or consume objects from the metadata model.
            </param>
        </member>
        <member name="M:Microsoft.Cci.PlatformType.CreateReference(Microsoft.Cci.IAssemblyReference,System.String[])">
            <summary>
            Creates a type reference to a namespace type from the given assembly, where the last element of the names
            array is the name of the type and the other elements are the names of the namespaces.
            </summary>
            <param name="assemblyReference">A reference to the assembly that contains the type for which a reference is desired.</param>
            <param name="names">The last entry of this array is the name of the type, the others are the names of the containing namespaces.</param>
        </member>
        <member name="M:Microsoft.Cci.PlatformType.CreateReference(Microsoft.Cci.IAssemblyReference,System.Boolean,System.String[])">
            <summary>
            Creates a type reference to a namespace type from the given assembly, where the last element of the names
            array is the name of the type and the other elements are the names of the namespaces.
            </summary>
            <param name="assemblyReference">A reference to the assembly that contains the type for which a reference is desired.</param>
            <param name="isValueType">True if the referenced type is known to be a value type.</param>
            <param name="names">The last entry of this array is the name of the type, the others are the names of the containing namespaces.</param>
        </member>
        <member name="M:Microsoft.Cci.PlatformType.CreateReference(Microsoft.Cci.IAssemblyReference,Microsoft.Cci.PrimitiveTypeCode,System.String[])">
            <summary>
            Creates a type reference to a namespace type from the given assembly, where the last element of the names
            array is the name of the type and the other elements are the names of the namespaces.
            </summary>
            <param name="assemblyReference">A reference to the assembly that contains the type for which a reference is desired.</param>
            <param name="typeCode">A code that identifies what kind of type is being referenced.</param>
            <param name="names">The last entry of this array is the name of the type, the others are the names of the containing namespaces.</param>
        </member>
        <member name="M:Microsoft.Cci.PlatformType.CreateReference(Microsoft.Cci.IAssemblyReference,System.UInt16,System.String[])">
            <summary>
            Creates a type reference to a namespace type from the given assembly, where the last element of the names
            array is the name of the type and the other elements are the names of the namespaces.
            </summary>
            <param name="assemblyReference">A reference to the assembly that contains the type for which a reference is desired.</param>
            <param name="genericParameterCount">The number of generic parameters, if any, that the type has must. Must be zero or more.</param>
            <param name="names">The last entry of this array is the name of the type, the others are the names of the containing namespaces.</param>
        </member>
        <member name="M:Microsoft.Cci.PlatformType.CreateReference(Microsoft.Cci.IAssemblyReference,System.Boolean,System.UInt16,Microsoft.Cci.PrimitiveTypeCode,System.String[])">
            <summary>
            Creates a type reference to a namespace type from the given assembly, where the last element of the names
            array is the name of the type and the other elements are the names of the namespaces.
            </summary>
            <param name="assemblyReference">A reference to the assembly that contains the type for which a reference is desired.</param>
            <param name="isValueType">True if the referenced type is known to be a value type.</param>
            <param name="genericParameterCount">The number of generic parameters, if any, that the type has must. Must be zero or more.</param>
            <param name="typeCode">A code that identifies what kind of type is being referenced.</param>
            <param name="names">The last entry of this array is the name of the type, the others are the names of the containing namespaces.</param>
        </member>
        <member name="M:Microsoft.Cci.PlatformType.GetTypeFor(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Maps a PrimitiveTypeCode value (other than Pointer, Reference and NotPrimitive) to a corresponding ITypeDefinition instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.ContractAssemblyRef">
            <summary>
            A reference to the assembly that contains the types and methods used to encode information about code contracts.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.CoreAssemblyRef">
            <summary>
            A reference to the assembly that contains the system types that have special encodings in metadata. Usually mscorlib, but
            can be a different assembly on other non CLR based systems.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCoreAssemblyRef">
            <summary>
            A reference to the System.Core assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemDiagnosticsContractsContract">
            <summary>
            A reference to the class that contains the standard contract methods, such as System.Diagnostics.Contracts.Contract.Requires.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.PointerSize">
            <summary>
            The size (in bytes) of a pointer on the platform on which these types are implemented.
            The value of this property is either 4 (32-bits) or 8 (64-bit).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemArgIterator">
            <summary>
            System.ArgIterator
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemArray">
            <summary>
            System.Array
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemAsyncCallback">
            <summary>
            System.AsyncCallBack
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemAttribute">
            <summary>
            System.Attribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemAttributeUsageAttribute">
            <summary>
            System.AttributeUsageAttribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemBoolean">
            <summary>
            System.Boolean
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemChar">
            <summary>
            System.Char
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsGenericDictionary">
            <summary>
            System.Collections.Generic.Dictionary
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsGenericICollection">
            <summary>
            System.Collections.Generic.ICollection
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsGenericIEnumerable">
            <summary>
            System.Collections.Generic.IEnumerable
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsGenericIEnumerator">
            <summary>
            System.Collections.Generic.IEnumerator
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsGenericIList">
            <summary>
            System.Collections.Generic.IList
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsICollection">
            <summary>
            System.Collections.ICollection
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsIEnumerable">
            <summary>
            System.Collections.IEnumerable
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsIEnumerator">
            <summary>
            System.Collections.IEnumerator
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemCollectionsIList">
            <summary>
            System.Collections.IList
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemDateTime">
            <summary>
            System.DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemDecimal">
            <summary>
            System.Decimal
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemDelegate">
            <summary>
            System.Delegate
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemDBNull">
            <summary>
            System.DBNull
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemEnum">
            <summary>
            System.Enum
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemFloat32">
            <summary>
            System.Float32
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemFloat64">
            <summary>
            System.Float64
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemIAsyncResult">
            <summary>
            System.IAsyncResult
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemICloneable">
            <summary>
            System.ICloneable
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemInt16">
            <summary>
            System.Int16
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemInt32">
            <summary>
            System.Int32
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemInt64">
            <summary>
            System.Int64
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemInt8">
            <summary>
            System.Int8
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemIntPtr">
            <summary>
            System.IntPtr
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemMulticastDelegate">
            <summary>
            System.MulticastDelegate
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemNullable">
            <summary>
            System.Nullable&lt;T&gt;
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemObject">
            <summary>
            System.Object
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeArgumentHandle">
            <summary>
            System.RuntimeArgumentHandle
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeFieldHandle">
            <summary>
            System.RuntimeFieldHandle
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeMethodHandle">
            <summary>
            System.RuntimeMethodHandle
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeTypeHandle">
            <summary>
            System.RuntimeTypeHandle
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeCompilerServicesCallConvCdecl">
            <summary>
            System.Runtime.CompilerServices.CallConvCdecl
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeCompilerServicesCompilerGeneratedAttribute">
            <summary>
            System.Runtime.CompilerServices.CompilerGeneratedAttribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeCompilerServicesExtensionAttribute">
            <summary>
            System.Runtime.CompilerServices.ExtensionAttribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeCompilerServicesFriendAccessAllowedAttribute">
            <summary>
            System.Runtime.CompilerServices.FriendAccessAllowedAttribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeCompilerServicesIsConst">
            <summary>
            System.Runtime.CompilerServices.IsConst
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeCompilerServicesIsVolatile">
            <summary>
            System.Runtime.CompilerServices.IsVolatile
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeCompilerServicesReferenceAssemblyAttribute">
            <summary>
            System.Runtime.CompilerServices.ReferenceAssemblyAttribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemRuntimeInteropServicesDllImportAttribute">
            <summary>
            System.Runtime.InteropServices.DllImportAttribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemSecurityPermissionsSecurityAction">
            <summary>
            System.Security.Permissions.SecurityAction
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemSecuritySecurityCriticalAttribute">
            <summary>
            System.Security.SecurityCriticalAttribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemSecuritySecuritySafeCriticalAttribute">
            <summary>
            System.Security.SecuritySafeCriticalAttribute
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemString">
            <summary>
            System.String
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemType">
            <summary>
            System.Type
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemTypedReference">
            <summary>
            System.TypedReference
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemUInt16">
            <summary>
            System.UInt16
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemUInt32">
            <summary>
            System.UInt32
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemUInt64">
            <summary>
            System.UInt64
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemUInt8">
            <summary>
            System.UInt8
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemUIntPtr">
            <summary>
            System.UIntPtr
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemValueType">
            <summary>
            System.ValueType
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemVoid">
            <summary>
            System.Void
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PlatformType.SystemVoidPtr">
            <summary>
            System.Void*
            </summary>
        </member>
        <member name="T:Microsoft.Cci.RootUnitNamespaceReference">
            <summary>
            A reference to a root unit namespace.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.RootUnitNamespaceReference.#ctor(Microsoft.Cci.IUnitReference)">
            <summary>
            Allocates a reference to a root unit namespace.
            </summary>
            <param name="unit">A reference to the unit that defines the referenced namespace.</param>
        </member>
        <member name="M:Microsoft.Cci.RootUnitNamespaceReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IRootUnitNamespaceReference).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.RootUnitNamespaceReference.ResolvedUnitNamespace">
            <summary>
            The namespace definition being referred to, if it can be resolved. Otherwise Dummy.UnitNamespace;
            </summary>
        </member>
        <member name="P:Microsoft.Cci.RootUnitNamespaceReference.Unit">
            <summary>
            A reference to the unit that defines the referenced namespace.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.MemoryMappedFile">
            <summary>
            Class representing the unmanaged memory mapped file. This can be used to open the file as memory mapped file and get the pointer to the buffer of file content.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemoryMappedFile.Finalize">
            <summary>
            Finalizer for the Memory mapped file. Calls the CloseMap.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MemoryMappedFile.CreateMemoryMappedFile(System.String,Microsoft.Cci.IBinaryDocument)">
            <summary>
            Factory method for opening the memory mapped file. The content of the map is assumed to come from localFileName.
            This can throw FileLoadException in case of error.
            </summary>
            <param name="localFileName">Name of the file from where the binary document needs to be opened.
            This is useful in case we want to copy the file to temporary location and then open or when we want to open document on the network.</param>
            <param name="binaryDocument">The binary document for which the memory mapping is requested.</param>
        </member>
        <member name="T:Microsoft.Cci.UnmanagedBinaryMemoryBlock">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnmanagedBinaryMemoryBlock.Finalize">
            <summary>
            Destructor for UnmanagedBinaryMemoryBlock
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnmanagedBinaryMemoryBlock.CreateUnmanagedBinaryMemoryBlock(System.String,Microsoft.Cci.IBinaryDocument)">
            <summary>
            Factory method for opening the memory mapped file. The content of the map is assumed to come from localFileName.
            This can throw FileLoadException in case of error.
            </summary>
            <param name="localFileName"></param>
            <param name="binaryDocument"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.BinaryDocument">
            <summary>
            Class representing a binary document
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BinaryDocument.#ctor(System.String,Microsoft.Cci.IName,System.UInt32)">
            <summary>
            Constructor for the Binay Document.
            </summary>
            <param name="location"></param>
            <param name="name"></param>
            <param name="length"></param>
        </member>
        <member name="M:Microsoft.Cci.BinaryDocument.GetBinaryDocumentForFile(System.String,Microsoft.Cci.IMetadataHost)">
            <summary>
            Static factory method for getting the Binary document given full file path. Note this reads the file on the disk hence can throw some of the IO exceptions.
            </summary>
            <param name="fullFilePath"></param>
            <param name="compilationHost"></param>
        </member>
        <member name="T:Microsoft.Cci.BinaryLocation">
            <summary>
            Class representing the Binary location.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BinaryLocation.#ctor(Microsoft.Cci.IBinaryDocument,System.UInt32)">
            <summary>
            Constructor for the Binary location
            </summary>
            <param name="binaryDocument"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Microsoft.Cci.BinaryLocation.Equals(System.Object)">
            <summary>
            Compares the equality of two locations.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.BinaryLocation.GetHashCode">
            <summary>
            Gives the hash code of the location
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.BinaryLocation.ToString">
            <summary>
            Gives the string representing the location
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.ILLocation">
            <summary>
            Class representing the location in IL stream.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ILLocation.#ctor(Microsoft.Cci.IBinaryDocument,Microsoft.Cci.IMethodDefinition,System.UInt32)">
            <summary>
            Constructor for IL location
            </summary>
            <param name="binaryDocument"></param>
            <param name="methodDefinition"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Microsoft.Cci.ILLocation.Equals(System.Object)">
            <summary>
            Compares the equality of two locations.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.ILLocation.GetHashCode">
            <summary>
            Gives the hash code of the location
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.ILLocation.ToString">
            <summary>
            Gives the string representing the location
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.AttributeHelper">
            <summary>
            Class conraining helper routines for Attributes
            </summary>
        </member>
        <member name="M:Microsoft.Cci.AttributeHelper.IsAttributeType(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns true if the type definition is an attribute. Typedefinition is said to be attribute when it inherits from [mscorlib]System.Attribute
            </summary>
        </member>
        <member name="M:Microsoft.Cci.AttributeHelper.Contains(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICustomAttribute},Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if the given collection of attributes contains an attribute of the given type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.AttributeHelper.AllowMultiple(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.INameTable)">
            <summary>
            Specifies whether more than one instance of this type of attribute is allowed on same element.
            This information is obtained from an attribute on the attribute type definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.AttributeHelper.Inherited(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.INameTable)">
            <summary>
            Specifies whether this attribute applies to derived types and/or overridden methods.
            This information is obtained from an attribute on the attribute type definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.AttributeHelper.ValidOn(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Specifies the symbol table elements on which it is valid to apply this attribute.
            This information is obtained from an attribute on the attribute type definition.
            </summary>
        </member>
        <member name="T:OptionParsing">
            <summary>
            Subclass this class and define private fields for options
            </summary>
        </member>
        <member name="F:OptionParsing.errors">
            <summary>
            The number of errors discovered during command-line option parsing.
            </summary>
        </member>
        <member name="M:OptionParsing.AddError">
            <summary>
            Allows a client to signal that there is an error in the command-line options.
            </summary>
        </member>
        <member name="F:OptionParsing.generalArguments">
            <summary>
            This field will hold non-option arguments
            </summary>
        </member>
        <member name="M:OptionParsing.ParseUnknown(System.String,System.String[],System.Int32@,System.String)">
            <summary>
            Called when reflection based resolution does not find option
            </summary>
            <param name="option">option name (no - or /)</param>
            <param name="args">all args being parsed</param>
            <param name="index">current index of arg</param>
            <param name="optionEqualsArgument">null, or the optionArgument when option was option=optionArgument</param>
            <returns>true if option is recognized, false otherwise</returns>
        </member>
        <member name="M:OptionParsing.Parse(System.String[])">
            <summary>
            Main method called by a client to process the command-line options.
            </summary>
        </member>
        <member name="M:OptionParsing.DerivedOptionFor(System.String,System.Int32)">
            <summary>
            For the given field, returns the derived option that is indexed by
            option in the list of derived options.
            </summary>
        </member>
        <member name="M:OptionParsing.TryGetOptions(System.String,System.String[]@)">
            <summary>
            Returns the options associated with the field, specified as a string.
            If there are none, options is set to null and false is returned.
            </summary>
        </member>
        <member name="M:OptionParsing.GetCheckCode">
            <summary>
            Use this 
            </summary>
        </member>
        <member name="M:OptionParsing.PrintOptions(System.String)">
            <summary>
            Writes all of the options out to the console.
            </summary>
        </member>
        <member name="M:OptionParsing.PrintDerivedOptions(System.String)">
            <summary>
            Prints all of the derived options to the console.
            </summary>
        </member>
        <member name="P:OptionParsing.HelpRequested">
            <summary>
            True if and only if a question mark was given as a command-line option.
            </summary>
        </member>
        <member name="P:OptionParsing.HasErrors">
            <summary>
            True if and only if some command-line option caused a parsing error, or specifies an option
            that does not exist.
            </summary>
        </member>
        <member name="P:OptionParsing.UseDashOptionPrefix">
            <summary>
            Override and return false if options do not start with '-' or '/'
            </summary>
        </member>
        <member name="P:OptionParsing.GeneralArguments">
            <summary>
            The non-option arguments provided on the command line.
            </summary>
        </member>
        <member name="T:OptionParsing.OptionDescription">
            <summary>
            Put this on fields if you want a more verbose help description
            </summary>
        </member>
        <member name="F:OptionParsing.OptionDescription.Description">
            <summary>
            The text that is shown when the usage is displayed.
            </summary>
        </member>
        <member name="M:OptionParsing.OptionDescription.#ctor(System.String)">
            <summary>
            Constructor for creating the information about an option.
            </summary>
        </member>
        <member name="P:OptionParsing.OptionDescription.Required">
            <summary>
            Indicates whether the associated option is required or not.
            </summary>
        </member>
        <member name="P:OptionParsing.OptionDescription.ShortForm">
            <summary>
            Indicates a short form for the option. Very useful for options
            whose names are reserved keywords.
            </summary>
        </member>
        <member name="T:OptionParsing.OptionWitness">
            <summary>
            Put this on fields if you want the field to be relevant when hashing an Option object
            </summary>
        </member>
        <member name="T:OptionParsing.OptionValueOverridesFamily">
            <summary>
            If a field has this attribute, then its value is inherited by all the family of analyses
            </summary>
        </member>
        <member name="T:OptionParsing.OptionFor">
            <summary>
            A way to have a single option be a macro for several options.
            </summary>
        </member>
        <member name="F:OptionParsing.OptionFor.options">
            <summary>
            The field that this option is a macro for.
            </summary>
        </member>
        <member name="M:OptionParsing.OptionFor.#ctor(System.String)">
            <summary>
            Constructor for specifying which field this is a macro option for.
            </summary>
        </member>
    </members>
</doc>
