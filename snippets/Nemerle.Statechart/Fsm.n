using System;
using System.Collections.Generic;
using System.Diagnostics;
using Nemerle.Statechart;
//using Nemerle.Statechart.Utils.MacroUtils;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;
//using Sanford.StateMachineToolkit;
//using CommonLib.Nemerle;
//using Nemerle.DesignPatterns;

namespace Nemerle.Statechart
{

      /*TODO:
  точка входа и выхода  
  +shallow history
  +deep history
  +default history transitions  
  +guards
  +guards in fsm class, properties, functions
  +reset history by final (check spec)
  + приоритет переходов вложенных классов
  - если исторический переход в final то переход в default в этом же состоянии в котором final
  - warning при неиспользовании элементов (истории и тп)
  - несколько типов историй в одном состоянии
  - final is not pseudostate
  - terminal pseudostate
  - do activity
  - choice
  - junction
  - fork and join pseudostates
  - orthogonal regions
  - local and external transitions
  - auto initial attribute for state
  - deffered events  
  - events with parameters
  - sync and async events (eg queue)
  - time events
  - events hierarchy
  - change events (like properties)  
  + maybe several initial and several completions with guards
  - no transition to final from outer states
  - else guard
  - оптимизация повторяющихся действий
  - there is no more reaction to events within the region if the final state is active
  - completion запускается сразу если нет активности по стандарту (надо задавать флагами если мы не хотим этого)  
  - приоритет действий вложенных классов
  - сложные выражения в guards
  */
    
  module FsmHelper
  {          
    Parse(ty : TypeBuilder,body : string,loc : Location) : StateMachine
    {
      def parser=FsmParser();              
      def (pos,ast)=parser.TryParse(body);            
      if (pos > 0)
      {
        ast
      }
      else
      {          
        def (pos, ids) = parser.GetMaxRollbackPosAndNames();
        def line=parser.ParsingSource.GetSourceLine(pos);             
        def (line,col)=line.StartLineColumn;        
        def line=loc.Line+line;
        def col=col+ty.Ast.ParsedAttributsAndModifiers.GetMacroAttributes().Head.Location.Column;        
        Message.Error($"Error in input at $line:$col. Expected: ..$(ids;\r\n    )");
        null                
      }
      
    }      
    
    public ParseAndGenerate(ty : TypeBuilder,body : PExpr) : void
    {              
    
      def parse(val)
      {
        //assert2(false);    
        def fsm=Parse(ty,val,body.Location);      
        if (fsm!=null)
        {
          when (fsm.flags.Debug) assert2(false);
          def analyser=FsmAnalyser(fsm);      
          analyser.Analyse();
          if (!analyser.Error) 
          {
            def gen=StaticGenerator(analyser,ty);
            gen.Generate();
          } else
          {
            analyser.Errors.Iter(Message.Error);
          }          
        } else
        {          
          Message.Warning("No Statechart parsed");          
        }
      }
      match (body)
      {
        | Literal(String(val)) => parse(val)
        |_ => Message.Error(ty.Location,"Body expression must be a string");
      }
    }
      
  }
  
      
}
