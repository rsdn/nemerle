using System;
using System.Collections.Generic;
using System.Diagnostics;
using Nemerle.Statechart;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{

/*TODO:  
  + shallow history
  + deep history
  + default history transitions  
  + guards
  + guards in fsm class,  properties,  functions
  + reset history by final (check spec)
  + приоритет переходов вложенных классов
  + maybe several initial and several completions with guards
  + несколько типов историй в одном состоянии
  + final is not pseudostate
  + если исторический переход в final то переход в default в этом же состоянии в котором final (!!! если несколько состояний ???)
  + terminate pseudostate
  + do activity
  - conditional thread
  - точка входа и выхода
  - warning при неиспользовании элементов (истории и тп)
  - choice
  - junction
  - fork and join pseudostates
  - orthogonal regions
  - synch state
  - local and external transitions
  - auto initial attribute for state
  - deffered events
  - events with parameters
  - sync and async events (eg queue)
  - time events
  - events hierarchy
  - change events (like properties)
  - no transition to final from outer states
  - else guard
  - генерация в с++ код микроконтроллера
  - генерация таблицы переходов
  - импорт из нарисованной модели
  - экспорт в State Chart Xml
  - импорт в State Chart Xml
  - оптимизация повторяющихся действий
  - there is no more reaction to events within the region if the final state is active
  - completion запускается сразу если нет активности по стандарту (надо задавать флагами если мы не хотим этого)  
  - приоритет действий вложенных классов
  - сложные выражения в guards
  */
    
  module FsmHelper
  {          
    Parse(ty : TypeBuilder, body : string, loc : Location) : StateNode.StateMachine
    {
      def parser = FsmParser();              
      if (!body.Trim().IsEmpty()) 
      {
        def (pos, ast) = parser.TryParse(body);            
        if (pos > 0)
        {
          ast
        }
        else
        {          
          def (pos,  ids)  =  parser.GetMaxRollbackPosAndNames();
          def line = parser.ParsingSource.GetSourceLine(pos);             
          def (line, col) = line.StartLineColumn;        
          def line = loc.Line + line;
          def col = col + ty.Ast.ParsedAttributsAndModifiers.GetMacroAttributes().Head.Location.Column;        
          Message.Error($"Error in input at $line:$col. Expected: ..$(ids;\r\n    )");
          null                
        }
      } else null
    }      
    
    public ParseAndGenerate(ty : TypeBuilder, body : PExpr) : void
    {              
    
      def parse(val)
      {        
        def fsm = Parse(ty, val, body.Location);
        if (fsm != null)
        {
          when (fsm.flags.Debug) assert2(false);
          def analyser = FsmAnalyser(fsm);      
          analyser.Analyse();
          analyser.Warnings.Iter(Message.Warning);
          if (!analyser.Error) 
          {
            def gen = StaticGenerator(analyser, ty);
            gen.Generate();
          } else
          {
            analyser.Errors.Iter(Message.Error);
          }          
        } else
        {          
          Message.Warning("No Statechart parsed");          
        }
      }

      match (body)
      {
        | Literal(String(val))  => parse(val);
        | _  => Message.Error(ty.Location, "Body expression must be a string");
      }
    }
      
  }
  
      
}
