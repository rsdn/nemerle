using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Peg;
using Nemerle;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  
  partial class FsmParser
  {      
    name(tok : NToken) : NameIdentifier.Name
    {
      NameIdentifier.Name(tok.StartPos,GetText(tok))
    }
    
    fully_qualified(id1 : NToken,id2 : NToken) : NameIdentifier.QualifiedName
    {
      NameIdentifier.QualifiedName(id1.StartPos,GetText(id1),GetText(id2))      
    }
    
    guard(tok : NToken) : TransitionNode.Guard
    {
      TransitionNode.Guard(tok.StartPos,GetText(tok))
    }
            
    transition_mark(guard : option[TransitionNode.Guard],act : option[TransitionNode.Actions],state : NameIdentifier) : StateNode.Transition
    {            
      def target=NameToState(state);
      StateNode.Transition(guard,act,target);
    }
      
    default_transition(act : option[TransitionNode.Actions],state : NameIdentifier) : StateNode.Default
    {      
      StateNode.Default(act,state.GetNode());        
    }
    
    events(id : NToken,evt : List[NToken]) : List[TransitionNode.Event]
    {        
      def lst=id :: evt.NToList();      
      def lst=lst &> create_event;
      lst.ToList()
    }    
    
    simple_transition(evt : List[TransitionNode.Event],tran : StateNode.Transition) : StateNode
    {        
      //Debugger.Break();          
      StateNode.Transition(evt,tran)    
    }
    
    attribute(attr : NToken) : StateAttribute
    {
      def str=GetText(attr);
      def pos=attr.StartPos;
      match (str)
      {
        | "Initial" => StateAttribute.Initial(pos)
        | _ => StateAttribute.Unknown(pos,str)
      }
    }

    trans_act_list(lst : List[NToken]) : TransitionNode.Actions
    {
      create_action(lst)
    }    
    
    block_action_list(lst : List[NToken]) : TransitionNode.Actions
    {
      create_action(lst)
    }
    
    delim_action_list(lst : List[NToken]) : TransitionNode.Actions
    {      
      create_action(lst)
    }
          
    entry(key : NToken,acts : option[TransitionNode.Actions]) : StateNode.Entry
    {      
      acts.MapDefault(StateNode.Entry(key.StartPos,_),StateNode.Entry(key.StartPos));
    }

    exit(key : NToken, acts : option[TransitionNode.Actions]) : StateNode.Exit
    {
      acts.MapDefault(StateNode.Exit(key.StartPos,_),StateNode.Exit(key.StartPos));
      //ifvalue (acts) StateNode.Exit(key.StartPos,_) else StateNode.Exit(key.StartPos);      
    }
            
    //simple_transition(evt : NToken,mark : StateNode.Transition) : StateNode.Transition
    //{
    //  StateNode.Transition(TransitionNode.Event(evt.StartPos,GetText(evt)),mark);
    //}
    
    internal_trans(evt : NToken,acts : TransitionNode.Actions) : StateNode.InternalTransition
    {
      StateNode.InternalTransition(evt.StartPos,[create_event(evt)],option.None(),acts)
    }
              
    initial_trans(name : NToken,tran : StateNode.Transition) : StateNode.Initial
    {            
      StateNode.Initial(name.StartPos,tran)
    }
              
    state(attr : option[List[StateAttribute]],name : NToken,nodes : List[StateNode]) : StateNode.State
    {        
      def name_text=GetText(name);      
      def attr=attr.MapDefault(_.NToList(),[]);
      CreateState(name.StartPos,name_text,attr,nodes.NToList());
    }
      
    flags(tok : List[NToken]) : MachineFlags
    {
      def proc_tok(tok,flag)
      {
        def nflag=match (GetText(tok))
                   {            
                     |"debug" => MachineFlag.Debug
                     |"auto_initial" => MachineFlag.AutoInitial
                     |"local_default" => MachineFlag.LocalDefault
                     |"transition_completed_events" => MachineFlag.TransitionCompleted
                     |_ => MachineFlag.None
                   }
        nflag | flag
      }     
      
      MachineFlags(tok.Fold(MachineFlag.None,proc_tok));      
    }
    
    history_deep(tok : NToken,tran : option[StateNode.Default]) : StateNode.History
    {
      def_history(StateHistory.Deep,tok,tran)
    }    

    history_shallow(tok : NToken,tran : option[StateNode.Default]) : StateNode.History
    {
      def_history(StateHistory.Shallow,tok,tran)      
    }    
    
    history_long(type : NToken,tran : option[StateNode.Default]) : StateNode.History
    {
      match (GetText(type))
      {
        |"Deep"
        |"deep" => def_history(StateHistory.Deep,type,tran)      
        |"Shallow"
        |"shallow" => def_history(StateHistory.Shallow,type,tran)     
        |_ => def_history(StateHistory.None,type,tran)      
      }
    }
    
    stateMachine(sp : NToken,flags : option[MachineFlags], st : List[StateNode]) : StateNode.StateMachine
    {                    
      def st=CreateState(sp.StartPos,null,[],st.NToList());
      def flags=flags.WithDefault(MachineFlags(MachineFlag.None));
      //def flags=ifvalue (flags) _ else MachineFlags(MachineFlag.None);
      StateNode.StateMachine(flags,st);
    }
  }
          

    
}
