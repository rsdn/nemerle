using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  [Record]
  variant StateNode
  {
    
    | StateMachine 
        {
          flags : MachineFlags;
          state : State;
          
          this(fl : MachineFlags, st : State)
          {
            flags = fl;
            state = st;
            base(st.pos);
          }
        }
    | Region  
        {
            nodes : list[State];
            
            this(pos : int) 
            {
                base(pos)
            }            
        } 
    | Regions 
        {
            regions : list[Region];
        }
    | Initial 
        {
          guard : option[TransitionNode.Guard];
          action : option[Actions];         
          target : StateNode.State;
          
          this(pos : int, tran : Transition)
          {
            guard = tran.guard;
            action = tran.action;
            match (tran.to)
            {
              | TargetType.State(st)  => target = st;
              | _  => ()
            }
            base(pos);
          }
                    
        }
    | Default
        {
          action : option[Actions];
          target : StateNode.State;
          mutable history : History;
                    
          this(act : option[Actions], to : State)
          {
              action = act;
              target = to;
              base(0)
          }
                    
        }
    | Final
        {               
            mutable state  : State;
            
            this(s : State) 
            {
                state = s;
                base(0);
            }
        }
    | State 
        {           
          this (n : string) {name = n;reference = true;base(0);}
          
          name : string;
          initial : list[Initial];
          attributes : list[StateAttribute];
          entry : option[Entry];
          exit : option[Exit];
          internal_tran : list[InternalTransition];
          transitions : list[Transition];
          do_activity : option[DoActivity];
          [RecordIgnore]
          SuperState  : State {get;set;}
          history : ThreeOption[History];
          sub_states : list[State];
          regions : option[Regions];
          [RecordIgnore]
          reference : bool;
          pseudo_states : list[PseudoState];
          
        }        
    | Entry 
        {                
          this(pos : int) {action = Actions([]);base(pos);}
          this(lst : list[string]) {action = Actions(lst);base(0);}                       
          action : Actions;
        }
    | Exit 
        {
          this(pos : int) {action = Actions([]);base(pos);}
          this(lst : list[string]) {action = Actions(lst);base(0);}          
          action : Actions;
        }           
    | DoActivity {action : Actions;}    
    | InternalTransition    
        {
          evt : list[TransitionNode.Event];
          guard : option[TransitionNode.Guard];
          action : Actions;
          
          Actions : list[string]
          {
            get
            {
              action.ActionList
            }
          }          
          
        }        
    | Transition 
        {
          evt : list[TransitionNode.Event];
          guard : option[TransitionNode.Guard];
          action : option[Actions];
          to : TargetType;

          ToState : StateNode.State
          {
              get
              {
                  match (to)
                  {
                      | TargetType.State(st)  => st
                      | _  => null
                  }
              }
          }
          
          this(guard : option[TransitionNode.Guard], action : option[Actions], to : TargetType)
          {
            this.guard = guard;
            this.action = action;
            this.to = to;
            base(to.pos);
          }
                    
          this( evt : List[TransitionNode.Event],  tran : Transition)
          {
            this.evt = evt.NToList();
            guard = tran.guard;
            action = tran.action;
            to = tran.to;
            base(evt.First().pos);              
          }
          
        }
            
    | History
        { 
          type : StateHistory;
          default : option[Default];
          mutable state : State;
          reference : bool;
          
          this(pos : int, state : State)
          {
            this.state = state;
            reference = true;
            default = option.None();
            base(pos);
          }
          
          this(pos : int, type : StateHistory, default : option[Default])
          {            
            this.type = type;
            this.default = default;
            base(pos);
          }

          
        }        
     | PseudoState
       {
         node : PseudoStateAstNode;
       }
        
    public pos : int {get;set;}
       
  }

}
