using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  [Record]
  variant StateNode
  {
    
    |StateMachine 
        {
          flags : MachineFlags;
          state : State;
          
          this(fl : MachineFlags,st : State)
          {
            flags=fl;
            state=st;
            base(st.pos);
          }
        }
    |Region  
        {
            nodes : list[State];
            
            this(pos : int) 
            {
                base(pos)
            }            
        } 
    |Regions 
        {
            regions : list[Region];
        }
    |Initial 
        {
          guard : option[TransitionNode.Guard];
          action : option[TransitionNode.Actions];         
          target : StateNode.State;
          
          this(pos : int,tran : Transition)
          {
            guard=tran.guard;
            action=tran.action;
            match (tran.to)
            {
              |TargetType.State(st) => target=st;
              |_ => ()
            }
            base(pos);
          }
          
          //this(pos : int,to : State) {this(to);this.pos=pos;}
          //this(to : State)
          //{
          //  target=TargetType.State(to);
          //  guard=option.None();
          //  action=option.None();
          //  base(to.pos);
          //}
        }
    |Default
        {
          action : option[TransitionNode.Actions];
          target : StateNode.State;
          mutable history : History;
          
          //this(pos : int,target : StateNode.State)
          //{                        
          //  this.target=target;
          //  base(pos);
          //}
          this(act : option[TransitionNode.Actions],to : State)
          {
              action=act;
              target=to;
              base(0)
          }
          
          //this(pos : int,history : History, tran : Transition)
          //{
          //    this.history=history;
          //    target=tran.ToState;
          //    action=tran.action;
          //    base(pos);
          //}
        }
    |Final
        {               
            mutable state  : State;
            
            this(s : State) 
            {
                state=s;
                base(0);
            }
        }
    |State 
        {           
          this (n : string) {name=n;reference=true;base(0);}
          
          name : string;
          initial : list[Initial];
          attributes : list[StateAttribute];
          entry : option[Entry];
          exit : option[Exit];
          internal_tran : list[InternalTransition];
          transitions : list[Transition];
          do_activity : option[DoActivity];
          [RecordIgnore]
          Parent  : State {get;set;}
          history : ThreeOption[History];
          sub_states : list[State];
          regions : option[Regions];
          [RecordIgnore]
          reference : bool;
          
        }        
    |Entry 
        {                
          this(pos : int) {action=TransitionNode.Actions(pos,[]);base(pos);}
          this(lst : list[TransitionNode.Action]) {action=TransitionNode.Actions(lst);base(action.pos);}             
          //this(act : TransitionNode.Actions) {action=act;base(act.pos);}
          action : TransitionNode.Actions;
        }
    |Exit 
        {
          this(pos : int) {action=TransitionNode.Actions(pos,[]);base(pos);}
          this(lst : list[TransitionNode.Action]) {action=TransitionNode.Actions(lst);base(action.pos);}
          //this(act : TransitionNode.Actions) {action=act;base(act.pos);}
          action : TransitionNode.Actions;
        }           
    |DoActivity {action : TransitionNode.Actions;}    
    |InternalTransition    
        {
          evt : list[TransitionNode.Event];
          guard : option[TransitionNode.Guard];
          action : TransitionNode.Actions;   
          
          Actions : list[string]
          {
            get
            {
              action.ActionList
            }
          }          
          
        }        
    |Transition 
        {
          evt : list[TransitionNode.Event];
          guard : option[TransitionNode.Guard];
          action : option[TransitionNode.Actions];
          to : TargetType;

          ToState : StateNode.State
          {
              get
              {
                  match (to)
                  {
                      |TargetType.State(st) => st
                      |_ => null
                  }
              }
          }
          
          this(guard : option[TransitionNode.Guard],action : option[TransitionNode.Actions],to : TargetType)
          {
            this.guard=guard;
            this.action=action;
            this.to=to;
            base(to.pos);
          }
          
          //this(evt : TransitionNode.Event,tran : Transition)
          //{
          //  this.evt=[evt];
          //  guard=tran.guard;
          //  action=tran.action;
          //  to=tran.to;
          //  base(evt.pos);
          //}
          
          //this(evt : TransitionNode.Event,guard : option[TransitionNode.Guard],action : option[TransitionNode.Actions],to : TargetType)
          //{
          //  this(guard,action,to);
          //  this.evt=[evt];
          //}
          
          //this(evt : TransitionNode.Event,to : State)
          //{
          //  this.evt=[evt];
          //  this.to=TargetType.State(to);
          //  guard=option.None();
          //  action=option.None();
          //  base(evt.pos);
          //}
          
          //this( evt : List[TransitionNode.Event],
          //      guard : option[TransitionNode.Guard],
          //      action : option[TransitionNode.Actions],
          //      to : TargetType)
          //{
          //  this.evt=evt.NToList();
          //  this(guard,action,to);            
          //}
          
          this( evt : List[TransitionNode.Event], tran : Transition)
          {
            this.evt=evt.NToList();
            guard=tran.guard;
            action=tran.action;
            to=tran.to;
            base(evt.First().pos);              
          }
          
        }
            
    |History
        { 
          type : StateHistory;
          default : option[Default];
          mutable state : State;
          reference : bool;
          
          this(pos : int,state : State)
          {
            this.state=state;
            reference=true;
            default=option.None();
            base(pos);
          }
          
          this(pos : int,type : StateHistory,default : option[Default])
          {
            //this.state=state;
            this.type=type;
            this.default=default;
            base(pos);
          }

          
        }        
                
    public pos : int {get;set;}
       
  }

}
