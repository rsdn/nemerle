using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using PseudoStateAstNode;  
  using FsmState;
  
  [Record]
  variant TransitionTarget
  {
    | History 
        {
          mutable history : StateChartHistory;
         
          override UpdateReference(map : StateMap) : void
          {
            when (history.Reference) history = map[history.State.Name].GetHistory(history);            
          }

          override ToString() : string
          {        
            $"$(history.State)History"   
          }
          
          this(st : FsmState,  type : TargetType.History)
          {
            history = StateChartHistory(st, type.history, true)            
          }
        }
    | Final
        {
          mutable state : FsmState.Final;

          override ToString() : string
          {
            $"$(state)"
          }
          
          this()
          {            
          }
          
          public override UpdateReference(map : StateMap) : void
          {
            when (state != null && state.Reference) state = map[state.Name] :> FsmState.Final;
          }            
        }
    | PseudoState
        {
          mutable node : PseudoStateNode;

          this(node : TargetType.PseudoState)
          {              
            this.node = PseudoStateNode.Create(node.node);            
          }

          override UpdateReference(map : StateMap) : void
          {
            node.UpdateReference(map);            
          }
          
          override ToString() : string
          {
            node.ToString()
          }
        }
    | State 
        {
          mutable state : FsmState;
          
          override UpdateReference(map : StateMap) : void
          {
            when (state.Reference) state = map[state.Name];            
          }

          Name : string
          {
            get
            {
              state.Name
            }
          }
          
          override ToString() : string
          {        
            state.ToString();
          }
          
          this(type : TargetType.State)
          {
            state = FsmState.State(type.state, true);            
          }
          
        }
             
    public static Create(state : FsmState, target : TargetType) : TransitionTarget
    {
      match (target)
      {
        | PseudoState as t  => TransitionTarget.PseudoState(t)  
        | History as t  => TransitionTarget.History(state, t)
        | Final  => TransitionTarget.Final()
        | State as t  => TransitionTarget.State(t);
      }
    }
    
    public CompareTo(target : TransitionTarget) : int
    {
      match (this, target)
      {
        | (History(h1), History(h2)) => FsmAnalyser.StringComparator(h1.Name, h2.Name)
        | (Final(st1), Final(st2)) => FsmAnalyser.StringComparator(st1.Name, st2.Name)
        | (PseudoState(n1), PseudoState(n2)) => FsmAnalyser.StringComparator(n1.ToString(), n2.ToString())
        | (State(st1), State(st2)) => FsmAnalyser.StringComparator(st1.Name, st2.Name)
        | _ => -1
      }
    }
    
    public virtual UpdateReference(_ : StateMap) : void
    {
         
    }
     
    
  }
  
  [Record]
  variant PseudoStateNode
  {      
    | Junction
    | Choice
    | Fork 
        {
          mutable states : list[FsmState];
       
          override UpdateReference(map : StateMap) : void
          {      
            states=states.Map(map.CheckRef(_));
            base.UpdateReference(map);
          }
        }
    | Join
    | EntryPoint
    | ExitPoint       
    | Terminate
        {                    
          override ToString() : string
          {            
            $"$(state)Terminate"
          }
        }
        
    public static Create(st : PseudoStateAstNode) : PseudoStateNode
    {
      | Junction(state = null) => Junction(null)
      | Junction(state = st) => Junction(State(st, true))
      | Choice(state = null) => Choice(null)
      | Choice(state = st) => Choice(State(st, true))
      | Fork(states = lst, state = null) => Fork(null, lst |> State(_, true))
      | Fork(states = lst, state = st) => Fork(State(st, true), lst |> State(_, true))
      | Join(state = null) => Join(null)
      | Join(state = st) => Join(State(st, true))
      | EntryPoint(state = null) => EntryPoint(null)
      | EntryPoint(state = st) => EntryPoint(State(st, true))
      | ExitPoint(state = null) => ExitPoint(null)
      | ExitPoint(state = st) => ExitPoint(State(st, true))
      | Terminate(state = null) => Terminate(null)
      | Terminate(state = st) => Terminate(State(st, true))
    }
        
    public mutable state : FsmState;

    public virtual UpdateReference(map : StateMap) : void
    {            
      when (state != null && state.Reference) state = map[state.Name]
    }
      
  }

}
