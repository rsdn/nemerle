using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  [Record]
  variant TransitionTarget
  {
    |History 
        {
          mutable history : StateChartNode.History;
         
          override UpdateReference(map : StateMap) : void
          {
              when (history.reference) history=map.Map[history.state.Name].GetHistory(history);
            //history.UpdateReference(map);
          }

          override ToString() : string
          {        
            $"$(history.state)History"   
          }
          
          this(st : FsmState, type : TargetType.History)
          {
            history=StateChartNode.History(st,type.history,true)
            //if (type.history.state!=null)  else st.history.Value;              
          }
        }
    |Final
        {
          mutable state : FsmState.FinalState;

          override ToString() : string
          {
            $"$(state)"
          }
          
          this()
          {            
          }
          
          public override UpdateReference(map : StateMap) : void
          {
            when (state!=null && state.Reference) state=map[state.Name] :> FsmState.FinalState;
          }            
        }
    |PseudoState
        {
          node : PseudoStateNode;

          this(state : FsmState,node : TargetType.PseudoState)
          {              
            this.node=match (node.node)
                       {
                         |Choice => PseudoStateNode.Choice(state)
                         |EntryPoint => PseudoStateNode.EntryPoint(state)
                         |ExitPoint => PseudoStateNode.ExitPoint(state)                         
                         |Junction => PseudoStateNode.Junction(state)
                         | _ => null
                       }
          }
          
          override UpdateReference(map : StateMap) : void
          {
            node.UpdateReference(map);            
          }
          
          override ToString() : string
          {
            node.ToString()
          }
        }
    |State 
        {
          mutable state : FsmState;
          
          override UpdateReference(map : StateMap) : void
          {
            when (state.Reference) state=map[state.Name];            
          }

          Name : string
          {
            get
            {
              state.Name
            }
          }
          
          override ToString() : string
          {        
            state.ToString();
          }
          
          this(type : TargetType.State)
          {
            state=FsmState(type.state,true);            
          }
          
        }

    public static Create(state : FsmState,target : TargetType) : TransitionTarget
    {
      match (target)
      {
        |PseudoState as t => TransitionTarget.PseudoState(state,t)  
        |History as t => TransitionTarget.History(state,t)
        |Final => TransitionTarget.Final()
        |State as t => TransitionTarget.State(t);
      }
    }
    
    public virtual UpdateReference(_ : StateMap) : void
    {
         
    }
     
    
  }
  
    [Record]
  variant PseudoStateNode
  {      
    |Junction
    |Choice
    |EntryPoint
    |ExitPoint       
        
    public mutable state : FsmState;

    public UpdateReference(map : StateMap) : void
    {
      when (state.Reference && state.Name!=null) state=map[state.Name];
    }
      
  }

}
