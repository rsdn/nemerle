using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  [Record]    
  [DebuggerDisplay("Actions = {ActList}")]   
  variant StateAction
  {
    |Entry
    |Exit
        
    ActList : list[string]
    {
      get
      {
        action.ActionList
      }
    }
    
    [Accessor]
    state : FsmState;
    [Accessor]
    action : TransitionNode.Actions;
  }
    
  variant StateTransition
  {
    |Default
        {
          default : StateNode.Default;                  
          history : StateChartNode.History;
          
          this(st : FsmState,hist : StateChartNode.History,default : StateNode.Default)
          {
            this.default=default;
            history=hist;
            action=default.action;
            From=st;
            To=TransitionTarget.State(FsmState(default.target,true))
          }
         
          Name : string
          {
            get
            {
              //def hist=From.history.Value;
              $"DefaultTransition$(history)To$ActualTo"
            }
          }
          
          override ToString() : string
          {
            Name
          }
          
        }
    |Initial 
        {          
          initial : StateNode.Initial;
          
          this(st : FsmState,init : StateNode.Initial)
          {
            From=st;
            guard=init.guard;
            action=init.action;
            To= TransitionTarget.Create(st,TargetType.State(0,init.target));
            //ActualTo=null;            
            //tran=Transition(st,init);
          }
          
          this(from : FsmState,to : FsmState)
          {
            From=from;
            To=TransitionTarget.State(to);
            //ActualTo=To;
            guard=option.None();
            action=option.None();
            //tran=Transition(from,to);                            
          }
                              
          Name : string
          {
            get
            {
              $"InitialTransitionFrom$(From)To$ToState"
            }
          }
                    
          override ToString() : string
          {
            Name
          }
          
        }
    [DebuggerDisplay("Transition = {Name}")]       
    |Transition 
        {
          trigger : StateChartNode.Event;
          node : StateNode.Transition;
          
          [RecordIgnore]
          Name : string 
          {
            get
            {              
              def prefix= $"Transition$(From)To$(To)In$Source";
              $"$(prefix)By$(FriendlyTriggerName)";
            }
          }
                    
          IsCrossed : bool {get;set;}
          
          IsCompletion : bool
          {
            get
            {
              TriggerName==null
            }
          }
          
          /// <summary>
          /// Переходы из родительских состояний пересекающие с текущим
          /// </summary>
          ParentCrossed : list[Transition]
          {
            get
            {
              Source.GetParentCrossTransitions(this)
            }
          }
          
          TriggerName : string
          {
            get
            {
              trigger.Name
            }
          }                    
          
          FriendlyTriggerName : string
          {
            get
            {
              if (TriggerName==null) "Completion" else TriggerName
            }
          }
          
          override ToString() : string
          {
            Name
          }
          //this(from : FsmState,to : FsmState)
          //{
          //  From=from;
          //  To=to;
          //  ActualTo=to;
          //  transition=StateNode.Transition(null,to.state);
          //}                   
          
          static Create(st : FsmState,tr : list[StateNode.Transition]) : list[Transition]
          { 
            $[Transition(st,StateChartNode.Event(y),x),x in tr,y in x.evt]
          }
                              
          this(st : FsmState,evt : StateChartNode.Event,tr : StateNode.Transition)
          {
            From=st;
            this.trigger=evt;
            node=tr;
            guard=tr.guard;
            action=tr.action;
            To=TransitionTarget.Create(st,tr.to);
          }
          
          //this(st : FsmState,tr : StateNode.Initial)
          //{
          //  From=st;
          //  evt=null;
          //  transition=StateNode.Transition(null,tr.guard,tr.action,tr.target);
          //  To=FsmState(tr.target,true);
          //  ActualTo=To;
          //}
          this(tr : Transition)
          {
            From=tr.From;
            trigger=tr.trigger;            
            guard=tr.guard;
            action=tr.action;
            node=tr.node;
            To=tr.To;              
          }
          
          this(st : FsmState,tr : Transition)
          {
            this(tr);
            Source=st;            
          }          
        }          
        
    /// <summary>
    /// Состояние реагирующее на событие перехода (начало линии перехода)
    /// </summary>    
    public From : FsmState {get;set;}
    public guard : option[TransitionNode.Guard] {get;set;}
    public action : option[TransitionNode.Actions] {get;set;}
    public To : TransitionTarget {get;set;}
    public ActualTo : FsmState {get;set;}
    public Path : TransitionPath {get;set;}
    
    public static Comparer : (StateTransition * StateTransition -> int) = (g1,g2) => g2.guard.Compare(g1.guard,(x,y) => x.condition.CompareTo(y.condition));
    
    /// <summary>
	/// Предустановочное состояние         
	/// </summary>
    public PreSetState : option[FsmState]
    {
      get
      {
        Path.PreSetState
      }
    }
    
    public HistoryTarget : StateChartNode.History
    {
      get
      {
        match (To)
        {
          |TransitionTarget.History(hist) => hist
          |_ => null
        }
      }
    }
    
    public mutable to_choice : list[StateTransition]=[];
    
    public ToChoice : list[StateTransition] 
    {
      get
      {
        to_choice
      }
      set
      {
        to_choice=value
      }
    }
    
    public ToState : FsmState
    {
      get
      {
        match (To)
        {
          |TransitionTarget.State(st) => st
          |_ => null
        }
      }
    }
    
    /// <summary>
    /// Начальное состояние из которого реально осуществляется переход     
    /// </summary>   
    /// <remarks>
    /// (от From отличается что Source всегда является текущим вложенным состоянием в котором должна пребывать машина
    /// From определяет начальное состояние из которого на диаграмме выходит переход
    /// Source как правило является вложенным состоянием или тем же что From, если From не имеет подсостояний
    /// </remarks>
    public Source : FsmState {get;set;}      
        
    public CreatePath() : void
    {      
      Path=TransitionPath(this,From.Analyser);              
    }
    
    public PathNodes : list[PathNode]
    {
      get
      {
        Path.Path
      }
    }
     
    //Action : option[TransitionNode.Actions]
    //{
    //  get
    //  {
    //    transition.action
    //  }
    //}
    
    public UpdateReference(map : StateMap) : void
    {
      when (From!=null && From.Reference) From=map[From.Name];
      To.UpdateReference(map);
      //ActualTo.UpdateReference(map);
    }

    //public static ChangeSource(tran : StateTransition.Transition,source : FsmState) : StateTransition
    //{             
    //  def tr=StateTransition.Transition(tran);
    //  tr.Source=source;
    //  tr
    //}
    
    public Actions : list[string]
    {
      get
      {
        Path.Actions
      }
    }
    
    public mutable Used : bool;
  }
  
    

}
