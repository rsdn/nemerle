using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
    
  [Record]
  [DebuggerDisplay("State = {Name}")]
  class FsmState
  {    
    
    public state : StateNode.State;
    public mutable initial : list[StateTransition.Initial]=[];
    public mutable entry : option[StateAction.Entry]=None();
    public mutable exit  : option[StateAction.Exit]=None();
    public mutable internal_tran : list[StateChartNode.InternalTransition]=[];
    public mutable transitions : list[StateTransition.Transition]=[];
    public parent  : FsmState {get;set;}
    public mutable sub_states : list[FsmState]=[];
    public paths : TransitionPaths {get;set;}
    /// <summary>
    /// Позиция в иерархии
    /// </summary>
    public hierarchy_pos : int {get;set;}
    public history : ThreeOption[StateChartNode.History]=ThreeOption.None();
    /// <summary>
    /// показывает что машина пребывает в этом состоянии и оно не является лишь композитом
    /// </summary>
    public Lived : bool {get;set;}

    public history_paths : Hashtable[string,HistoryPath] {get;set;} // пути из внешних исторических состояний
    
    public this(st : StateNode.State,reference : bool=false)
    {
      state=st;
      parent_cross_transitions=[];
      Reference=reference || state.reference;
      when (!Reference)
      {
        Name=st.name;
        internal_tran=StateChartNode.InternalTransition.Create(this,st.internal_tran);
        entry=st.entry |> StateAction.Entry(this,_.action);
        exit=st.exit |> StateAction.Exit(this,_.action);
        history=st.history |> StateChartNode.History(this,_);
        transitions=StateTransition.Transition.Create(this,st.transitions);
        initial=st.initial |> StateTransition.Initial(this,_);
        parent=if (st.Parent!=null) FsmState(st.Parent,true); else null;
        sub_states=st.sub_states &> FsmState;
      }
    }
    
    public this()
    {        
    }
    
    public class FinalState : FsmState
    {        
             
      public this(parent : FsmState,reference : bool= false)
      {            
        this.parent=parent;
        name= $"$(parent)Final";
        IsFinal=true;            
        this.Reference=reference;
      }
        
      public override UpdateReference(map : StateMap) : void
      {
        when (parent.Reference) parent=map[parent.name];
      }
    }
    
    public mutable IsFinal : bool;
    /// <summary>
    /// переходы из родительских состояний которые могут пересекаться с событиями из тек.состояния    
    /// </summary>
    public mutable parent_cross_transitions : list[StateTransition.Transition]=[];
    
    public completion_transitions : list[StateTransition.Transition]
    {
      get
      {
        transitions.Filter(x => x.IsCompletion)
      } 
    }
    
    public all_transitions : list[StateTransition.Transition]
    {
      get
      {
        transitions + parent_cross_transitions        
      }
    }

    create_group(tr : list[StateTransition.Transition]) : Hashtable[string,list[StateTransition.Transition]]
    {        
      def group=tr.Group((x,y) => FsmAnalyser.StringComparator(x.FriendlyTriggerName,y.FriendlyTriggerName));
      def lst=group |> (_.Head.FriendlyTriggerName,_);
      Hashtable(lst)
    }
    
    public HaveFinalNode : bool
    {
      get
      {
        sub_states.Exists(x => x.this_transitions.Exists(x => x.To is TransitionTarget.Final))
      }
    }
    
    public grouped_transitions : Hashtable[string,list[StateTransition.Transition]]
    {
      get
      {
        create_group(all_transitions)
      }
    }
    
    public this_cross_transitions : Hashtable[string,list[StateTransition.Transition]]
    {
      get
      {        
        create_group(this_transitions).Filter((_,x) => x.Length > 1)
      }
    }
        
    public work_transition_group : Hashtable[string,list[StateTransition.Transition]]
    {
      get
      {
        create_group(work_transitions)
      }
    }
    
    public cross_transitions : Hashtable[string,list[StateTransition.Transition]]
    {
      get
      {
        //def all=all_transitions.Filter(x => !x.IsCompletion);
        //def group=create_group(all);
        grouped_transitions.Filter((_,x) => x.Length > 1)
      }
    }
    
    /// <summary>
	/// Переходы определенные напрямую из этого состояния
	/// </summary>
    public this_transitions : list[StateTransition.Transition]
    {
      get
      {
        transitions.Filter(x => x.From==this)
      }
    }
    
    public GetHistory(type : StateChartNode.History) : StateChartNode.History
    {
      match (history)
      {
        |One(h) => h
        |Two(f,s) => if (f.type==type.type) f else s
        |_ => null
      }
    }
    
    public IsTopState : bool
    {
      get
      {
        Name==TopStateName
      }
    }

    public static TopStateName = "[Top]";

    public static @==(a : FsmState,b : FsmState) : bool
    {
      |(null,null) => true
      |(a,null) => a : object == null
      |(null,b) => b : object == null
      |(a,b) => a.Name==b.Name
    }

    public static @!=(a : FsmState,b : FsmState) : bool
    {
        !(@==(a,b))
    }
    
    public HaveHistoryPaths : bool
    {
      get
      {
        history_paths!=null && history_paths.Count()!=0
      }
    }

    public DefineHistoryPath(st : string,nodes : HistoryPath) : void
    {
      when (history_paths==null) history_paths=Hashtable();
      history_paths[st]=nodes;
    }

    public DefineHistoryPathRecurse(st : string,nodes : HistoryPath) : void
    {
      when (Lived) DefineHistoryPath(st,nodes);
      sub_states.Iter(x => x.DefineHistoryPathRecurse(st,nodes));
    }

    /// <summary>
	/// События на которые реагирует состояние
	/// </summary>
    public events : list[StateChartNode.Event]
    {
      get
      {
        transitions |> trigger
      }
    }
    
    public DeleteTransitions(tr : list[StateTransition.Transition]) : void
    {
      transitions=transitions.Exclude(tr,(x,y) => x.Name==y.Name);
    }
    
    /// <summary>
	/// Рабочие переходы
	/// </summary>
    public work_transitions : list[StateTransition.Transition]
    {
      get
      {
        if (Lived) transitions.Filter(x => !x.IsCompletion) else [];
      }
    }

    /// <summary>
	/// Все подсостояния
	/// </summary>
    public AllSubStates : list[FsmState]
    {
      get
      {
        sub_states+(sub_states |>< AllSubStates)
      }
    }

    /// <summary>
	/// Все живущие подсостояния
	/// </summary>
    public AllLivedSubStates : list[FsmState]
    {
      get
      {
        LivedSubStates+(sub_states |>< LivedSubStates)
      }
    }

    /// <summary>
	/// Живущие прямые подсостояния
	/// </summary>
    public LivedSubStates : list[FsmState]
    {
      get
      {
        sub_states.Filter(_.Lived)
      }
    }

 //   /// <summary>
	///// Исторические состояния этого региона
	///// </summary>
 //   public RegionHistory : list[StateChartNode.History]
 //   {
 //     get
 //     {
 //       Analyser.HistoryStates.Filter(x => x.state.ThroughHistorySubStates.Contains(this))
 //     }
 //   }
    
    /// <summary>
	/// Подсостояния включенные в историю этого состояния
	/// </summary>
    public ThroughHistorySubStates : list[FsmState]
    {
      get
      {
        def check_history(h)
        {
          |StateChartNode.History(type=StateHistory.Deep) => AllLivedSubStates
          |StateChartNode.History(type=StateHistory.Shallow) => sub_states
          |_ => []
        }
                        
        history.MapToList(check_history).Flatten()
      }
    }

    public GetParentCrossTransitions(tr : StateTransition.Transition) : list[StateTransition.Transition]
    {
      parent_cross_transitions.Filter(x => x.trigger==tr.trigger)
    }
    
    public DefineInitial(st : FsmState) : void
    {
      when (initial==null) initial=[];
      initial::=StateTransition.Initial(this,st);
    }

    public DefineTransition(tr : StateTransition.Transition) : void
    {
      transitions::=StateTransition.Transition(this,tr);
    }

    public DefineParentCrossTransition(tr : StateTransition.Transition) : void
    {      
      parent_cross_transitions::=tr;
    }

    public DefineParentCrossTransitions(tr : list[StateTransition.Transition]) : void
    {
      tr.Iter(DefineParentCrossTransition);
      parent_cross_transitions=parent_cross_transitions.Sort((x,y) => y.From.hierarchy_pos-x.From.hierarchy_pos);
    }
    
    public DefineTransitions(tr : list[StateTransition.Transition]) : void
    {
      tr.Iter(DefineTransition);
    }

    public Parents : list[FsmState]
    {
      get
      {
        def loop(p,res)
        {
          match (p)
          {
            |null => res.Rev()                
            |p => loop(p.parent,p :: res)    
          }
        }
            
        loop(parent,[])
      }
    }
    
    public Reference : bool {get;set;}
    private mutable name : string;

    public Analyser : FsmAnalyser {get;set;}

    public Id : ulong {get;set;}

    public Name : string
    {
      get
      {
        if (name!=null) name else AstName
      }
      set
      {
        name=value;
      }
    }

    public AstName : string
    {
      get
      {
        state.name
      }
    }

    public override ToString() : string {Name}

    public virtual UpdateReference(map : StateMap) : void
    {
      sub_states.Iter(x => x.Analyser=Analyser);
      when (parent!=null)
        when (parent.Reference)
        {
          when (parent.AstName==null) parent.Name=TopStateName;
          parent=map[parent.Name];
        }      
      initial.Iter(_.UpdateReference(map));
      transitions.Iter(_.UpdateReference(map));
      history.Iter(_.UpdateReference(map));
      sub_states.Iter(_.UpdateReference(map));
    }

  }
}
