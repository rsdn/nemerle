using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

    
  [Record]  
  variant StateChartNode
  {
    |Event 
        {
          evt : TransitionNode.Event;          
          InternalOnly : bool {get;set;}
          
          Name : string
          {
            get
            {
              evt.name
            }
          }
          
          this(e : TransitionNode.Event)
          {
            evt=e;
          }
          
          public static @==(a : Event,b : Event) : bool
          {
              FsmAnalyser.StringComparator(a.Name,b.Name)==0              
          }

          public static @!=(a : Event,b : Event) : bool
          {
               !(@==(a,b))
          }
          
        }
        
    |InternalTransition    
        {
          trigger : Event;
          transition : StateNode.InternalTransition; 
          state : FsmState;
          
          [RecordIgnore]
          Name : string 
          {
            get
            {
              $"Internal$(state)By$(TriggerName)"           
            }
          }

          TriggerName : string
          {
            get
            {
              trigger.Name
            }
          }
          
          Actions : list[string]
          {
            get
            {
              transition.Actions
            }
          }
          
          ActionNode : PathNode
          {
            get
            {
              PathNode.Action(transition.action)
            }
          }
                    
          static Create(st : FsmState,tr : list[StateNode.InternalTransition]) : list[InternalTransition]
          {
              $[InternalTransition(Event(y),x,st),x in tr,y in x.evt]                            
          }
        }        
        
    |History
        {
          history : StateNode.History;
          default : option[StateTransition.Default] {get;set;}
          state : FsmState {get;set;}
          type : StateHistory {get;set;}        
          
          reference : bool;
          mutable Used : bool;
          
          Name : string
          {
              get
              {
                  def type=match (type)
                  {
                      |Deep => "Deep"
                      |Shallow => "Shallow"
                      |None => ""
                  }
                  
                  if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
              }
          }
          
          SimpleName : string
          {
              get
              {
                  $"$(state)History"
              }
          }
          
          override ToString() : string
          {
              Name
          }
          
          GetHist(hist : ThreeOption[StateChartNode.History]) : StateChartNode.History
          {
              |None => null
              |One(s) => s
              |Two(f,_) => f
          }
          
          this(st : FsmState, hist : StateNode.History,reference : bool=false)
          {
            history=hist;
            state=if (hist.state!=null) FsmState(hist.state,true); else st;
            type=hist.type;            
            this.reference=reference;
            default=history.default |> StateTransition.Default(state,this,_);
          }
          
          public UpdateReference(map : StateMap) : void
          {
            when (state.Reference) state=map[state.Name];
            when (history.reference)
            {
              def hist=GetHist(state.history);
              type=hist.type;
              default=hist.default;
            }
            default.Iter(_.UpdateReference(map));
          }

        }
        
  }
}
