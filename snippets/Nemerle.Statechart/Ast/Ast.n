using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  enum StateHistory
  {    
    |None
    |Shallow
    |Deep
  }   
     
  [Record]
  variant NameIdentifier
  {
    |Name 
    |QualifiedName {sub_name : string;}
        
    public pos : int;
    public name : string;
    
    public TargetName : string
    {
      get
      {
        match (this)
        {
          |NameIdentifier.Name(name=n)
          |QualifiedName(sub_name=n) => n
        }
      }
    }
    
    public ParentName : string
    {
      get
      {
        match (this)
        {
          |NameIdentifier.Name => null
          |QualifiedName(name=n) => n
        }
            
      }
        
    }
    
    public GetState() : StateNode.State
    {
      def n=ParentName;
      if (n==null) null else StateNode.State(n)
    }
        
    public GetNode() : StateNode.State
    {
      StateNode.State(TargetName)          
    }
  }
  
  [Record]
  variant TransitionNode
  {      
    |Event 
        {
          name : string; 
          
          override ToString() : string {name}
        }      
    |Guard 
        {
          condition : string;
          override ToString() : string {Name}
        
          Name : string
          {
            get
            {
              $"Guard$condition"
            }
          }
                            
        }
    |Action 
        {
          name : string;
          override ToString() : string {name}
        }   
    |Actions 
        {                    
          this(acts : list[this.Action]) 
          {              
            actions=acts;
            def pos=if (acts.IsEmpty()) 0 else acts.Head.pos;                            
            base(pos);
          }
          //[RecordIgnore]
          actions : list[this.Action];
          
          ActionList : list[string]
          {
            get
            {
              actions |> name
            }
          }
          
          Empty : bool
          {
            get
            {
              actions.IsEmpty()
            }
          }
                    
        }
        
       //this() {pos=0;} 
       //[RecordIgnore]
    public pos : int {get;set;}
  }
    
  type StateMachine=StateNode.StateMachine;
  
  [Record]
  variant StateAttribute
  {
    |Initial 
    |Unknown {name : string}
    
    pos : int {get;set;}
  }
  
  [Flags]
  enum MachineFlag
  {
    |None    
    |Debug               = 0b0001  // включение точки останова для отладки
    |AutoInitial         = 0b0010  // автоматическое определения инициализирующего перехода из первого определения
    |LocalDefault        = 0b0100  // локальные переходы по умолчанию вместо external (это знач. при входе в родит.сост. не вызывается entry)    
    |TransitionCompleted = 0b1000  // события завершения переходов
  }
  
  [Record]
  class MachineFlags
  {      
    [FlagAccessor (AutoInitial, LocalDefault, Debug,TransitionCompleted, flags = WantSetter)]      
    mutable flags : MachineFlag;
      
      
  }
  
  [Record]
  variant PseudoStateAstNode
  {      
    |Fork
    |Join
    |Junction
    |Choice
    |EntryPoint
    |ExitPoint
            
    public state : StateNode.State;
      
  }
  
  [Record]
  variant TargetType
  {
    |History 
        {
          history : StateNode.History;
                
          this(pos : int,state : StateNode.State)
          {
            history=StateNode.History(pos,state);
            base(pos);
          }
        //this(pos : int)
        //{
        //  base(pos);
        //}
        }
    |PseudoState
        {
          node : PseudoStateAstNode;
          
          //this(pos : int,state : PseudoStateAstNode)
          //{
          //  node=PseudoStateAstNode();
          //  base(pos);
          //}
          
        }
    |Final {node : StateNode.Final;}
    |State 
        {            
            mutable state : StateNode.State;
          
        //this(st : StateNode.State)
        //{
        //  state=st;
        //  base(st.pos);
        //}
        } 
    
    public pos : int;
  }
  
}
