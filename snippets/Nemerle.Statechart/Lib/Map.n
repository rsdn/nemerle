using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using StringTemplate;
using Nemerle.Macros;

namespace Nemerle.Statechart
{
  macro @|>(first,second)
  syntax (first,"|>",second)
  {
    //assert2(false);
    def ctx=Macros.ImplicitCTX();
    def (n,expr)=  MapHelper.MapCreate(first,second,ctx);        
    def pars= MapHelper.GetParams(n);
      <[ $first.Map($pars => $expr) ]>      
  }

  macro @&>(first,second)
  syntax (first,"&>",second)
  {
    //assert2(false);
    def ctx=Macros.ImplicitCTX();
    def (n,expr)=  MapHelper.MapCreateFunc(first,second,ctx);        
    def pars= MapHelper.GetParams(n);
      <[ $first.Map($pars => $expr) ]>      
  }
  
  macro @&><(first,second)
  syntax (first,"&><",second)
  {
    //assert2(false);
    def ctx=Macros.ImplicitCTX();
    def (n,expr)=  MapHelper.MapCreateFunc(first,second,ctx);        
    def pars= MapHelper.GetParams(n);
      <[ $first.Map($pars => $expr).Flatten() ]>      
  }
  
  macro @|><(first,second)
  syntax (first,"|><",second)
  {
    //assert2(false);
    def ctx=Macros.ImplicitCTX();
    def (n,expr)=  MapHelper.MapCreate(first,second,ctx);
    def pars= MapHelper.GetParams(n);
      <[ $first.Map($pars => $expr).Flatten() ]>
  }
  
  macro @%|>(first,second)
  syntax (first,"%|>",second)
  {
    //assert2(false);
    def ctx=Macros.ImplicitCTX();
    def (_,expr) =  MapHelper.MapCreate(first,second,ctx);        
    <[ $first.Map((x,_) => $expr) ]>
  }  

  macro @%|><(first,second)
  syntax (first,"%|><",second)
  {
    //assert2(false);
    def ctx=Macros.ImplicitCTX();
    def (_,expr) =  MapHelper.MapCreate(first,second,ctx);        
    <[ $first.Map((x,_) => $expr).Flatten() ]>
  }  
  
  macro @^|>(first,second)
  syntax (first,"^|>",second)
  {
    //assert2(false);
    def ctx=Macros.ImplicitCTX();
    def (_,expr)=  MapHelper.MapCreate(first,second,ctx);        
    <[ $first.Map((_,x) => $expr) ]>
  }  
  
  macro @^|><(first,second)
  syntax (first,"^|><",second)
  {
    //assert2(false);
    def ctx=Macros.ImplicitCTX();
    def (_,expr)=  MapHelper.MapCreate(first,second,ctx);        
    <[ $first.Map((_,x) => $expr).Flatten() ]>
  }  
  
  module MapHelper
  {          
      
    public GetParam(num : int) : PExpr
    {
      match (num)
      {
        |1 => <[ x ]>
        |2 => <[ y ]>
        |3 => <[ z ]>
        |4 => <[ a ]>
        |5 => <[ b ]>
        |_ => <[ x ]>
      }
    }
    
    
    public GetParams(num : int) : PExpr
    {
      match (num)
      {
        |1 => <[ x ]>
        |2 => <[ (x,y) ]>
        |3 => <[ (x,y,z) ]>
        |4 => <[ (x,y,z,a) ]>
        |5 => <[ (x,y,z,a,b) ]>
        |_ => <[ x ]>
      }
        
    }
    
    public MapCreateFunc(first : PExpr,second : PExpr,ctx : Typer) : int * PExpr
    {
        MapCreate(first,second,ctx,expr => <[ $expr(x) ]>);
    }
    
    public MapCreate(first : PExpr,second : PExpr,ctx : Typer) : int * PExpr
    {
        MapCreate(first,second,ctx,expr => <[ x.$((expr.ToString()) : usesite)]>);
    }
    
    public MapCreate(_ : PExpr,second : PExpr,ctx : Typer,first_expr : PExpr -> PExpr) : int * PExpr
    { 
      mutable is_first = true;
      mutable n_params : int =1;            
      
      
      def loop(expr)
      {

      
        def check_splicable(sp)
        {
          |Splicable.Expression(exp) => Splicable.Expression(loop(exp));
          |_ => sp
        }

        def check_parameter(par)
        {
          |PParameter where (name=n,modifiers=m,Type=t) => PParameter(check_splicable(n),m,loop(t))          
        }
        
        def check_classmember(cl) : ClassMember
        {
          |ClassMember.Function(name=n,header=h,modifiers=m,implemented=i,body=b) => 
              def n= check_splicable(n);
              def h=match (h)
                     {
                       | PFunHeader where 
                          (TypeParameters=Typarms where (tyvars=ty,constraints=c),
                           SplicableName=n,ReturnType=ret,Parameters=pars) => 
                           PFunHeader(Typarms(ty.Map(check_splicable),c),check_splicable(n),loop(ret),
                                        pars.Map(check_parameter))                       
                     }
              def b=match (b)
                     {
                       |FunBody.Parsed(expr) => FunBody.Parsed(loop(expr))
                       |_ => b
                     }              
              ClassMember.Function(n,m,h,i.Map(loop),b)     
          |EnumOption(name=n,modifiers=m,value=v) => ClassMember.EnumOption(check_splicable(n),m,v.Map(loop))
          |Field(name=n,modifiers=m,ty=t) => ClassMember.Field(check_splicable(n),m,loop(t))
          |Event(name=n,modifiers=m,ty=t,field=f,add=a,remove=r) => 
              ClassMember.Event(check_splicable(n),m,loop(t),
                                  check_classmember(f) :> ClassMember.Field,
                                  check_classmember(a) :> ClassMember.Function,
                                  check_classmember(r) :> ClassMember.Function)     
          | _ => cl     
          
        }
        
        match (expr)
        {
          | PExpr.Ref(name) when (name.ToString()=="_") => <[ x ]>
          | PExpr.Ref => if (is_first) {is_first=false;first_expr(expr);} else <[ $((expr.ToString()) : usesite)]>          
          | <[ $obj.$mem ]> => def exp= <[ $(loop(obj)).$(check_splicable(mem)) ]>;is_first=false;exp                    
          | <[ _ ]> => is_first=false;<[ x ]>    
          | <[ $exp : $typ ]> => is_first=false;<[ $(loop(exp)) : $typ ]>
          | Tuple(args) when args.All(_ is PExpr.Ref) => is_first=false;PExpr.Tuple(args.Map(first_expr))
          | <[ (..$args) ]> => <[ (..$(args.Map(loop))) ]>
          | <[ {..$lst} ]> => is_first=false;<[ {..$(lst.Map(loop))} ]>          
          | Call(<[ Nemerle.IO.sprint]>,[PExpr.Literal(Literal.String) as lit]) => 
              def expr=Helper.SprintImpl(lit, true, x => x, ctx.Env);
              loop(expr)                                                            
          | <[ $f(..$p) ]> => is_first=false;<[ $(loop(f))(..$(p.Map(loop))) ]>
          | Spliced(body) => PExpr.Spliced(loop(body))
          | Indexer(<[ _ ]>,[PExpr.Literal(Literal.Integer(val,_,_))]) with num=val :> int => n_params=Math.Max(n_params,num);<[ $(GetParam(num)) ]>
          | <[ $obj[..$args] ]> => <[ $(loop(obj))[..$(args.Map(loop))] ]>          
          | Quoted(SyntaxElement.Expression(exp)) => is_first=false;
              PExpr.Quoted(SyntaxElement.Expression(loop(exp)))
          | Quoted(SyntaxElement.ClassMember(mem)) => is_first=false; PExpr.Quoted(SyntaxElement.ClassMember(check_classmember(mem)))
          | Quoted(SyntaxElement.MatchCase(MatchCase where (patterns=p,body=b))) => is_first=false;
              PExpr.Quoted(SyntaxElement.MatchCase(MatchCase(p.Map(loop),loop(b))))                    
          | <[ $expr1 = $expr2]> => <[ $(loop(expr1)) = $(loop(expr2)) ]>
          | _ =>  is_first=false;expr
        }
      }      
      def expr=loop(second);
      (n_params,expr)
    }

  }
}
