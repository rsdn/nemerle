using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of TransitionPathImpl.
  /// </summary>
  partial class TransitionPath
  {
    [Accessor]
    transition : StateTransition;
    analyser : FsmAnalyser;    

    [Accessor]
    mutable path : list[PathNode];
        
    FindPath(src_st : FsmState,
             dest_st : FsmState,
             exit : list[FsmState],
             entry : list[FsmState]
             ) : option[FsmState] * list[FsmState] * list[FsmState]
    {
      def find_path(st,dest,ex,en)
      {        
        match (st,dest)
        {
          // если не найден
          | (null,null) => (option.None(),[],[]) 
          | (null,d) => find_path(src_st,d.parent,exit,d :: en) // если дошли до вершины но есть еще состояния не просмотренные
          // если найден родитель
          | (s,d) when (d==s) => (option.Some(st),ex.Rev(),en)
          // иначе ищем дальше через родитель 
          | (s,d) => find_path(s.parent,d,s :: ex,en)
        }             

      }
      find_path(src_st,dest_st,exit,entry)
    }

     //* 1. The source and target are the same (self-transition).
                 //* -2. The target is a substate of the source. (local or external?)
                 //* -3. The source is a substate of the target. (local or external?)
                 //* 4. The source and target share the same superstate.
                 //* 5. All other cases.
                 //*     a. The source and target reside at the save level in the 
                 //*        hiearchy (but do not share the same superstate).
                 //*     b. The source is lower in the hiearchy than the target.
                 //*     c. The target is lower in the hierarchy than the source.
                 //* 
                 //* Case 1: Immediately performs the transition.
                 //* 
                 //* Case 2: Traverses the hierarchy from the source to the target, 
                 //*         entering each state along the way. No states are exited.
                 //* 
                 //* Case 3: Traverses the hierarchy from the source to the target, 
                 //*         exiting each state along the way. The target is then 
                 //*         entered.
                 //* 
                 //* Case 4: The source is exited and the target entered.
                 //* 
                 //* Case 5: Traverses the hiearchy until a common superstate is met.
    FindLCA(st : FsmState,
            dest_st : FsmState) : option[FsmState] * list[FsmState] * list[FsmState]
    {                  
      FindPath(st.parent,dest_st.parent,st :: [],dest_st :: []);
    }                
    
    AddAction(nodes : list[PathNode],act : option[TransitionNode.Actions]) : list[PathNode]
    {
        |(n,Some(act)) => n+[PathNode.Action(act)]
        |(n,_) => n
    }

    CreateNode(nodes : list[FsmState],
               get_node : FsmState -> option[StateAction],
               creator : TransitionNode.Actions * FsmState -> PathNode) : list[PathNode]
    {
      def nod=(nodes &> get_node).FilterValues();                           
      def nod=nod |> (Action,State);
      nod.Map(creator)
    }            
            
    EntryNodeCreate(nodes : list[FsmState]) : list[PathNode]
    {
      CreateNode(nodes,x => x.entry |> _ : StateAction,PathNode.Entry);
    }
      
    ExitNodeCreate(nodes : list[FsmState]) : list[PathNode]
    {        
      CreateNode(nodes,x => x.exit |> _ : StateAction,PathNode.Exit);
    }

    NodesCreate(ex : list[FsmState],tran : StateTransition, en : list[FsmState]) : list[PathNode]
    {
      def nodes=ExitNodeCreate(ex); // создаем узел пути выходных действий     
      def nodes=AddAction(nodes,tran.action); // добавляем действия
      def entry_nodes=EntryNodeCreate(en); // создаем узел пути входных действий
      nodes+entry_nodes; // собираем вместе узлы
    }
    
    //NameEqual(x : FsmState,y : FsmState) : bool
    //{
    //  FsmAnalyser.StrEq(x.Name,y.Name);
    //}
    
    static completion : StateChartNode.Event=StateChartNode.Event(TransitionNode.Event(0,null));

  }
}
