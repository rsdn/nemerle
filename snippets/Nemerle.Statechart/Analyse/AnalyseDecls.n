using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nemerle.Statechart;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  [Record]
  variant FsmError
  {        
    |DuplicateState {name : string;}
    |UnknownState {state : string;name : string;tran : string;}
    |StateNotFound {state : string;}
    |StateHasNoParent {state : string;}
    //|FinalStateNeedsCompletion {state : string;parent : string;}
    |DuplicateTransition {tran : list[StateTransition];}
    |DuplicateHistory {state : string;history : string;}
    //|NoInitial 
  }

  //[Record]
  //class StateNotFoundException : KeyNotFoundException
  //{
  //    [Accessor]
  //    state : string;
  //}
  
  class StateMap
  {
    [Accessor]
    map : Hashtable[string,FsmState]=Hashtable();
      
    [Accessor]
    errors : List[string]=List();                    
      
    public HaveErrors : bool
    {
      get
      {
              !errors.IsEmpty()
      }
    }
      
    public Contains(state : string) : bool
    {                    
      map.Contains(state)
    }
      
    public Get(state : string) : FsmState 
    {
      if (Contains(state)) map[state] else 
      {
        errors.Add(state);
        null
      }
    }
            
    public Item[index : string] : FsmState 
    {
      get
      {
        Get(index)
      }
      set
      {
        map[index]=value;
      }
    }
      
    public Names : list[string]
    {
      get
      {
        map.Keys()
      }
    }
      
    public States : list[FsmState]
    {
      get
      {
        map.Values()
      }
    }
  }
  
  partial class FsmAnalyser
  {
        
    [Accessor]
    statemap : StateMap=StateMap();
    
    [Accessor]
    mutable lived_states : list[FsmState];
    [Accessor]
    mutable states : list[string];
    [Accessor]
    mutable events : list[string];
    [Accessor]
    mutable transitions : Map[string,StateTransition.Transition];
    [Accessor]
    mutable internal_transitions : Map[string,StateChartNode.InternalTransition];    
    mutable events_map : Map[string,StateChartNode.Event]; // event * for internal transition        
    mutable trans_paths : Map[string,TransitionPaths];
    [Accessor]
    mutable transition_nodes : Map[string,list[PathNode]];
    [Accessor]
    mutable int_trans_nodes : Map[string,PathNode];
    [Accessor]
    mutable actions : list[string];
    [Accessor]
    mutable action_nodes : list[PathNode];
    [Accessor]
    mutable hierarchy : list[FsmState];
    [Accessor]
    mutable history_states : list[StateChartNode.History];
    [Accessor]
    mutable history_paths : list[HistoryPath];
    [Accessor]
    mutable work_transitions : Map[string,StateTransition.Transition];
    
    [Accessor]
    mutable work_transition_nodes : Map[string,list[PathNode]];
    [Accessor]
    mutable initial_transition_nodes : Map[string,list[PathNode]];
    [Accessor]
    mutable initial_transitions : Map[string,StateTransition.Initial];    
    
    [Accessor]
    fsm : StateMachine;
    mutable chart : FsmState;
    
    Init() : void
    {      
      Errors=[];
      Warnings=[];
    }
      
    InitStatechart() : void
    {
      chart=FsmState(fsm.state);
    }       
    
    public AddError(err : FsmError) : void
    {
      def str=match (err)
               {
                 | DuplicateState(name) => $<#Duplicated state "$(name)"#>
                 | StateNotFound(s) => $<#State "$s" Not Found#>
                 | StateHasNoParent(s) => $<#State "$s" has no parent#>
                 | UnknownState(s,tran,to) => $<#Transition "$tran" in "$s" has unknown target state "$to"#>
                 //| FinalStateNeedsCompletion(st,parent) => $<#Final state in "$st" needs completion transition in parent "$parent"#>
                 | DuplicateTransition(tran) => $<#Duplicate transitions $tran#>;
                 | DuplicateHistory(st,hist) => $<#Duplicate history of type "$hist" in "$st"#>
                 | _ => "Unknown Error"
               }
      Errors::=str;      
    }
    
    public this(fsm : StateMachine)
    {        
      this.fsm=fsm;
      Init();             
    }
                
    public Errors : list[string] {get;set;}
    public Warnings : list[string] {get;set;}
    
    public Analyse() : void
    {      
      when (Errors.IsEmpty())
      {
        InitStateMap();
        InitEvents();
        CreateTransitions();
        CheckTransitions();    
        CheckInitialTransitions();
        CreateTransitionPaths();      
        CreateHistory();
        CreateActions();              
      } 
    }
    
    public TransitionEvents : list[StateChartNode.Event]
    {
      get
      {
        events_map.Values().Filter(x => !x.InternalOnly);
      }
    }

    public IntTransitionEvents : list[StateChartNode.Event]
    {
      get
      {
        events_map.Values().Filter(x => x.InternalOnly);
      }
    }
    
    public Error : bool 
    {
      get
      {
            !Errors.IsEmpty()
      }
    }
      
    public guards : list[TransitionNode.Guard]
    {
        get
        {
            def guards=transitions.Values().FilterValues(x => x.guard);
            def guards=initial_transitions.Values().FilterValues(x => x.guard)+guards;            
            guards.RemoveDuplicatesSort((x,y) => StringComparator(x.Name,y.Name))
        }
    }
    
    public history_transitions : Map[string,StateTransition.Transition]
    {
        get
        {
            transitions.Filter((_,x) => x.HistoryTarget!=null);
        }        
    }
    
    public history_default_transitions : list[StateTransition.Default]
    {
        get
        {
            history_states.FilterValues(_.default).Filter(x => x.ActualTo!=null)
        }
    }
        
    public static StringComparator : string * string -> int = string.Compare(_,_,StringComparison.CurrentCulture);
    // TODO: сделать макрос сравнения строк с помощью одной установки
    public static StrEq : string * string -> bool = (x,y) => StringComparator(x,y)==0;        
    
    
    public TopState : FsmState {get;set;}
    
  }
}
