using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
    
  /// <summary>
  /// Путь перехода
  /// </summary>  
  partial class TransitionPath
  {
         
    mutable ToChoice : list[StateTransition]=[];
    mutable ChoiceState : FsmState;
    public mutable PreSetState : option[FsmState]=None();
    
	/// <summary>
	/// Обработка перехода в Final состояние
	/// </summary>       
    ProcessFinal(st : FsmState.FinalState, nodes : list[PathNode]) : FsmState * list[PathNode]
    {
      def parent=st.parent;
      if (parent==null) 
      {
        analyser.AddError(FsmError.StateHasNoParent($"$st"));
        (null,nodes)
      } else
      {
        def hist_clear=match (st.history) 
                        {
                          |ThreeOption.None => []
                          |h => [PathNode.ClearHistory(h.Value)]// создаем узел очистки                           
                        }
        // ищем переход по умолчанию      
        match (parent.FindTransitions(completion))
        {
          |[] => (st,nodes)
          // если есть переход по завершению без guard
          |[StateTransition.Transition(guard=None()) as tran] => 
             // если не определен путь completion перехода создаем его
              //def tran=StateTransition.ChangeSource(tran,transition.Source); // source это состояние
              tran.Used=true;
              def nodes=nodes+hist_clear+tran.PathNodes;// получаем узлы                           
              (tran.ActualTo,nodes) // создаем узлы для перехода и переходим в конечное состояние из final
          |lst =>               
              //def lst=lst |> StateTransition.ChangeSource(_,transition.Source);       
              def nodes=nodes+hist_clear;// получаем узлы
              PreSetState=Some(st);
              ChoiceState=parent;
              ToChoice=lst |> _ : StateTransition;
              ToChoice.Iter(x => x.Used=true);
              (null,nodes)
        }
      }
    }  
                       
    CreatePath(tran : StateTransition) : option[FsmState] * list[FsmState] * list[FsmState]
    {       
      |Initial(To=State(st),From=from) // initial и pseudo локальные переходы по умолчанию            
      |Default(To=State(st),From=from)
      |Transition(To=Final(st),From=from) => FindPath(from,st,[],[])
      |Transition(To=History(StateChartNode.History where (state=st)),From=from)
      |Transition(To=State(st),From=from) => FindLCA(from,st)
      |_ => (option.None(),[],[])
    }
    
    ProcessHistory(hist : StateChartNode.History,nodes : list[PathNode]) : FsmState * list[PathNode]
    {
      match (hist)
      {
        |StateChartNode.History(default=Some(StateTransition.Default(ToState=to) as tran)) as h => 
            h.Used=true; 
            tran.CreatePath();
            (to,nodes)
        |_ => (null,nodes)
      }
    }
        
    ProcessTransition(tran : StateTransition,nodes : list[PathNode]) : FsmState * list[PathNode]
    {              
      def source=tran.Source;
      def (_,exit1,_)=if (source!=null) 
                       {
                         FindPath(source,tran.From,[],[]);
                       } else 
                       {
                         tran.Source=tran.From;
                         (null,[],[]);
                       }
      //when (source==null) tran.Source=tran.From;                
                       
      def (_,exit,entry)=CreatePath(tran); // создаем путь
      def nodes=nodes+NodesCreate(exit1+exit,tran,entry); // создаем узлы для пути
      match (tran.To) 
      {
          // если начальное состояние с начальным переходом
        |State(FsmState where (initial=[]) as st) => st.Lived=true; // конечное состояние
            (st,nodes)
        |State(FsmState where (initial=[init])) => ProcessTransition(init,nodes) // рекурсивно обрабатываем переход
        |State(FsmState where (initial=init) as st) => ChoiceState=st;
            ToChoice=init |> (_ : StateTransition); // создаем динамический узел                
            (null,nodes)
        |Final(st) => ProcessFinal(st,nodes) // обрабатываем псевдосостояние
        |History(st) => ProcessHistory(st,nodes) // обрабатываем историю
        |_ => (null,nodes)
      }
    }
    /// <summary>
    /// Создаем путь перехода
    /// </summary>
    Create() : void
    {                                      
      def (to,nodes)=ProcessTransition(transition,[]); // обрабатываем переход      
      transition.ActualTo=if (ChoiceState!=null) 
                           {
                             transition.ToChoice=ToChoice;
                             ChoiceState
                           } else to;
      path=nodes;
    }
        
    public this(tran : StateTransition,analyser : FsmAnalyser)
    {
      transition=tran;      
      this.analyser=analyser;
      Create();            
    }
            
    public Actions : list[string]
    {
      get
      {
        path |>< Actions        
      }
    }
  }
    
}
