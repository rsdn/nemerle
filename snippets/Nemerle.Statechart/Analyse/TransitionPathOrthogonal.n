using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  
  using StateTransition;
  using PathNode;
  using TransitionDestination;
  using FsmState;
  
  /// <summary>
  /// Description of TransitionPathOrthogonal.
  /// </summary>
  partial class TransitionPath
  {
    
    TraverseToJoinTransition(join : PseudoStateNode.Join, tr : StateTransition) : TransitionDestination
    {
      def tran = join.transition;
      when (tran.Path == null) traverser.Add(tran); // add special transition from join
      tr.Used = true;
      Join(join)
    }
    
    TraverseJoinTransition(join : PseudoStateNode.Join, tr : StateTransition) : TransitionDestination
    {
      | (Join(joined_tran = jtran, region = reg), StateTransition where (From = from)) =>
      
          jtran.Iter(x => DefExitPath(x.Source, reg)); // unwind from source up to region of each joined transition      
       // unwind path from region up to transition begining (From)                                               
          DefPath(reg, from, tr); // creating path nodes                                   
          TraverseTarget(join.target); // traversing transition target          
    }
    
    TraverseFork(fork : PseudoStateNode.Fork, st : list[FsmState]) : TransitionDestination
    {                  
      def reg = st |> PartOfSubRegion;
      if (!reg.IsEmpty() && reg.All(x => x.HasValue))
      {
        def st = st.Sort((x, y) => x.PartOfSubRegion.Value.index - y.PartOfSubRegion.Value.index);
        def reg = reg |> Value;
        def dups = reg.Duplicates((x, y) => x.index - y.index);
        when (dups.Length != 0) analyser.AddError(FsmError.ForkMustGoToSeparateRegion(fork));
        def reg = reg.Head.contained_in;
        AddNode(EntryNodeCreate([reg]));
        def sub_trans = st |> StateTransition.Transition(reg, _, fork);
        traverser.Add(sub_trans |> _ : StateTransition);        
        reg.MayForkingFromOut = true;
        Fork(reg, sub_trans)
      } else 
      {
        analyser.AddError(FsmError.ForkMustGoToRegion(fork));
        Unknown()
      }      
    }
    
    TraverseOrthogonalRegion(reg : ConcurrentRegion) : TransitionDestination
    {
      def initial = reg.sub_regions |> Initial;
      when (!initial.All(x => !x.IsEmpty())) analyser.AddError(FsmError.RegionMustContainInitial(reg, transition));
      AddNode(EntryNodeCreate(reg.sub_regions |> _ : FsmState));
      def init = initial.Flatten();
      traverser.Add(init |> _ : StateTransition);
      Region(reg)
    }

    TraverseSubRegion(reg : ConcurrentSubRegion, st : FsmState, tran : StateTransition) : TransitionDestination
    {
      def region = reg.contained_in;
      def omitted = region.RegionsExcept(reg); // other omitted regions
      def initial = omitted |> Initial;
      DefPath(tran.Source, tran.From, tran); // unwind path from Source up to transition begining (From)                             
      // they must contain initial transitions
      when (!initial.All(x => !x.IsEmpty())) analyser.AddError(FsmError.SubRegionsMustContainInitial(omitted, transition));
      def init = initial.Flatten();
      region.DefineEnterPattern(omitted); // this must be compile time known patterns of exit
      traverser.Add(init |> _ : StateTransition);
      tran.Used = true;
      SubRegion(reg, st)
    }
    
    DefineRegionsExit(region : ConcurrentSubRegion) : void
    {      
      foreach (st in region.SubStates)
      {
        def (exit, _) = FindPath(st, region.SuperState, [], []); // exit state nested in region
        def exit = ExitNodeCreate(exit); // create exit state node      
        st.region_exit_path = exit;
      }
    }

    TraverseTransitionFromSubRegionState(reg : ConcurrentSubRegion, tran : StateTransition) : TransitionDestination
    {
      | (ConcurrentSubRegion(contained_in = region), StateTransition where (Source = src, From = from)) =>
                  
          region.sub_regions.Iter(DefineRegionsExit); // define exit actions from region          
          def regs = region.RegionsExcept(src); // regions except this state that must exit
          def reg_exit = SubRegionsExit(regs, region); // exit other regions      
          region.DefineExitPattern(regs); // this must be compile time known patterns of exit
          DefPath(src, from, tran, reg_exit);
          region.MayTakePlaceForcedTransitions = true;      
          tran.Used = true;
          TraverseTarget(tran.To) // traversing transition target      
    }
    
    TraverseTransitionFromRegion(region : ConcurrentRegion, tran : StateTransition) : TransitionDestination
    {
      region.sub_regions.Iter(DefineRegionsExit);
      def reg_exit = RegionExit(region); // exit whole regions      
      DefPath(region, tran.From, tran, reg_exit);
      if (tran.IsCompletion) tran.IsNeedCheckRegionFinal = Some(region) else region.MayTakePlaceForcedTransitions = true;      
      tran.Used = true;
      TraverseTarget(tran.To) // traversing transition target
    }
    
  }
}
