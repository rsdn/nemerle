using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of GeneratorDecls.
  /// </summary>
  partial class StaticGenerator
  {
    analyser : FsmAnalyser;
    ty : TypeBuilder;
    mutable tran_events : list[string];
    mutable int_tran_events : list[string];
    mutable events : list[string];
    mutable events_call : Map[string,PExpr];
    //mutable trans_body : Map[string,list[string]];
    mutable int_trans_body : Map[string,list[string]];
    mutable actions : Map[string,string];
    mutable decls : Map[string,ClassMember];
    mutable action_for : Map[string,string]; // source_name * dest_name
    mutable event_for : Map[string,string];
    mutable mask_type : TypeCode;
    mutable macro_actions : Map[string,list[PExpr]];
    mutable constructor : option[string];
    mutable history_save_nodes : Map[string,string];
    mutable guard_for : Map[string,string]; // сторожевые условия объявленные в классе
    mutable history_paths : Map[string,list[string]];
    mutable history_transitions : Map[string,list[string]];
    mutable history_def_transitions : Map[string,list[string]];            
    //mutable init_trans_body : Map[string,list[string]];
    
    ChartName : string;

    Define(f : ClassMember) : void
    {
      Define(ty,f);
    }

    Define(ty : TypeBuilder,f : ClassMember) : void
    {
      if (WithSources) _ = ty.DefineWithSource(f); else ty.Define(f);
    }

    Define(ty : TypeBuilder,lst : list[ClassMember]) : void
    {
      lst.Iter(Define(ty,_));
    }

    Define(lst : list[ClassMember]) : void
    {
      Define(ty,lst);
    }

    DefineNested(ty : TypeBuilder,f : ClassMember.TypeDeclaration) : TypeBuilder
    {
      when (WithSources)
      {
        def man=ty.TyManager;
        man.GenerateFakeSourceCode(f);
      }
      ty.DefineNestedType(f);
    }

    DefineNested(f : ClassMember.TypeDeclaration) : TypeBuilder
    {
      DefineNested(ty,f);
    }

    CreateExecActionNames(act : PathNode) : list[string]
    {
      |ClearHistory(st) => st |> $"$(_)Clear"
      | _ => CreateActionNames(act) |> $"On$_"
    }

    GetEndExecName(act : string,map : Map[string,string]) : string
    {
      if (IsDeclared(act,map)) map.Get(act) else $"On$act"
    }

    CreateExecActionName(act : string) : string
    {
      $"On$act"
    }

    CreateExecActionNames(act : list[PathNode]) : list[string]
    {
      act |>< CreateExecActionNames(_)
    }

    CreateActionNames(node : PathNode) : list[string]
    {
      |PathNode.Action(act) => create_act_name(act)
      |Entry(act,st) => $"$(st)Entry" :: create_act_name(act)
      |Exit(act,st) => $"$(st)Exit" :: create_act_name(act)
      |ClearHistory(st) => $[$"$(x)Clear",x in st,x.Used];
      | _ => []
    }

    //CreateActionNames(act : list[PathNode]) : list[string]
    //{
    //  act &>< CreateActionNames
    //}

    IsDeclared(act : string) : bool
    {
      IsDeclared(act,action_for);
    }

    IsDeclared(act : string,map : Map[string,string]) : bool
    {
      map.Exists((_,x) => FsmAnalyser.StrEq(act,x))
    }

    Declared(act : string,map : Map[string,string]) : string
    {
      if (map.Contains(act)) map.Get(act) else act
    }

    DeclaredEvent(act : string) : string
    {
      Declared(act,event_for);
    }

    DeclaredAction(act : string) : string
    {
      Declared(act,action_for);
    }

    create_act_name(act : TransitionNode.Actions) : list[string]
    {
      def (decl,act)=act.ActionList.Partition(IsDeclared);
      def names=decl.Map(DeclaredAction);

      names+(act |> $"$(_)Action");
    }
    
    GetActions(acts : list[string]) : PExpr
    {
        <[ {..$(acts |> <[$(_ : usesite)();]>)} ]>
    }

    GuardNeedBody(guard : TransitionNode.Guard) : bool
    {
      def expr=get_guard_cond_expr(guard);
      match (expr)
      {
        | <[ $(_ : name) ]>
        | PExpr.Call(<[ $(_ : name) ]>,[]) => false
        |_ => true
      }
    }

    get_guard_cond_expr(g : TransitionNode.Guard) : PExpr
    {
      def cond=g.condition;
      def name=GetEndExecName(cond,guard_for);
      if (IsDeclared(cond,guard_for))
      {        
        if (!decls.Contains(name)) <[ $(name : usesite)() ]> else
          match (decls.Get(name))
          {
            |Field(ParsedType = <[ bool ]>)
            |Property(returnType = <[ bool ]>) => <[ $(name : usesite) ]>
            |Field(ParsedType = <[ void -> bool ]>)
            |Property(returnType = <[ void -> bool ]>) => <[ if ($(name : usesite)!=null) $(name : usesite)() else false]>
            |Function
            |_ => <[ $(name : usesite)() ]>
          }
      } else
      {
        def name=GetEndExecName(g.Name,guard_for);
        <[$(name : usesite)()]>
      }
    }

    GetGuardedBody(tran : StateTransition,body : PExpr) : PExpr
    {
      match (tran)
      {
        // обработка сторожевого условия
        |StateTransition.Initial(guard=Some(g))  
        |StateTransition.Transition(guard=Some(g)) => def cond=get_guard_cond_expr(g);
                    <[
                    {
                     res:
                      {
                         def cond= $cond;
                         unless (cond) res(null);
                         $body
                      }
                     }]>
        |_ => body
      }
    }

    GetTransitionBody(tran : StateTransition, acts : list[PathNode]) : PExpr
    {
      //def body= GetTransitionBody(acts,to);      
      def acts=CreateExecActionNames(acts);
      def expr=GetActions(acts);
      def expr=match (tran.PreSetState)
      {
          |Some(st) => <[ $expr;cur_state = $($"State$st" : usesite); ]>
          |_ => expr
      }
      def target= match (tran.ToChoice)
                  {
                    |[] => def target=tran.ActualTo;
                           <[ $($"State$target" : usesite) ]>
                    |tr => DefineTransBody(tr,false);                    
                  }
                  
      def body= <[ $expr;$target ]>;      
      GetGuardedBody(tran,body)
    }

    //GetTransitionBody(acts : list[string],to : FsmState) : PExpr
    //{
    //    <[
    //    {$(GetActions(acts))}
    //    {$($"State$to" : usesite)}
    //    ]>;
    //}

    CreateStateMasks() : void
    {
      match (analyser.States.Length)
      {
        |x when x <= 32 => mask_type=TypeCode.UInt32
        |x when x <= 64 => mask_type=TypeCode.UInt64
        |_ => mask_type=TypeCode.Empty;
      }

      def create_mask(state)
      {
        when (state.Id!=0ul)
          state.Id= (1 : ulong << (state.Id :> int - 1) ) | state.parent.Id;
        state.sub_states.Iter(create_mask);
      }

      when (mask_type!=TypeCode.Empty)
      {
        _ = create_mask(analyser.TopState);
      }

    }

    Init() : void
    {
      def get_hist_save_name(n)
      {
        |FsmState where (history=ThreeOption where (HasValue=true) as h) as st => def h=h.Value.Head;
            def h=h.SimpleName; 
            ($"$(st)Exit",$"$(h)Save")
        |_ => ("","")
      }

      InitActionNames();
      CreateStateMasks(); // создаем маски состояний (идентификаторы)

      tran_events=analyser.TransitionEvents |> Name;
      int_tran_events=analyser.IntTransitionEvents |> Name;
      events=analyser.Events;
      events_call=Map(events |> (_,<[ cur_state.$(_ : usesite)() ]>));
      int_trans_body=Map(analyser.IntTransNodes |> (_,CreateExecActionNames(_[2])));
      def hist_names=analyser.HistoryStates |> get_hist_save_name(_.state);
      history_save_nodes=Map(hist_names);
      history_paths=Map(analyser.HistoryPaths |> (Name,CreateExecActionNames(_.Nodes)));
      history_transitions=Map(analyser.history_transitions |> (_,CreateExecActionNames(_[2].PathNodes)));
      history_def_transitions=Map(analyser.history_default_transitions |> (Name,CreateExecActionNames(_.PathNodes)));
    }

    InitActionNames() : void
    {
      def action_for_name(macros)
      {
        | <[ $_($name) ]> => name.ToString()
        |_ => macros.ToString()
      }


      def class_decls = ty.GetParsedMembers(false);//.MapFilterType();
      def macros=class_decls |> (Name,_.ParsedAttributsAndModifiers.GetMacroAttributes());
      def macros=macros.Filter((_,x) => !x.IsEmpty());
      macro_actions = Map(macros);
      decls=Map(class_decls |> (Name,_));

      def declared=decls.Keys();
      def action_for_decls= macros.FindSingleList(_ is <[ ActionFor($_) ]>);
      def event_for_decls= macros.FindSingleList(_ is <[ EventFor($_) ]>);
      def guard_for_decls=macros.FindSingleList(_ is <[ GuardFor($_) ]>);
      constructor= macros.FindSingle(_ is <[Constructor]>) %|> _;

      def decl=declared |> (_,_);
      def action=action_for_decls |> (action_for_name(_[2]),_);
      def evt=event_for_decls |> (action_for_name(_[2]),_);
      action_for=Map(action);
      event_for=Map(evt);
      def guard=guard_for_decls |> (action_for_name(_[2]),_);
      def guard=guard+decl;
      def guard=guard.RemoveDuplicatesSort(((k1,_),(k2,_)) => k1.CompareTo(k2));
      guard_for=Map(guard);      
      def acts=analyser.ActionNodes.Filter(x => !(x is PathNode.ClearHistory));
      def acts=(acts &>< CreateActionNames).RemoveDuplicatesSort(FsmAnalyser.StringComparator);      
      actions=Map(acts.Map(x => ($"On$x",x)));
    }       

    public WithSources : bool {get;set;}

    public this(analyser : FsmAnalyser,ty : TypeBuilder)
    {
      this.analyser=analyser;
      this.ty=ty;
      ChartName=ty.Name;
      WithSources=true;
    }

    public Generate() : void
    {
      Init();
      DefineInit();
      DefineEvents();
      DefineActions();
      DefineGuards();
      DefineTransitionActions();
      DefineHistoryTransitions();
    }

  }
}
