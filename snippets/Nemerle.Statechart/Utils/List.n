using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Утилиты для списков
  /// </summary>
  public module ListUtils
  {                
    
    public Split[First,Second,Third](this l : list[First * Second * Third]) : list[First] * list[Second] * list[Third]
    {
      def loop (acc1 : list [First], acc2 : list [Second], acc3 : list[Third],l : list[First * Second * Third]) 
      {
        match (l) {
          | (a, b, c ) :: t => loop (a :: acc1, b :: acc2, c :: acc3, t)
          | [] => (acc1.Rev(), acc2.Rev(), acc3.Rev())
        }
      }
      loop([], [],[], l)  
    }

    public Split[First,Second,Third,Fourth](this l : list[First * Second * Third * Fourth]) : list[First] * list[Second] * list[Third] * list[Fourth]
    {
      def loop (acc1 : list [First], acc2 : list [Second], acc3 : list[Third],acc4 : list[Fourth],l : list[First * Second * Third * Fourth]) 
      {
        match (l) {
          | (a, b, c, d ) :: t => loop (a :: acc1, b :: acc2, c :: acc3,d :: acc4, t)
          | [] => (acc1.Rev(), acc2.Rev(), acc3.Rev(),acc4.Rev())
        }
      }
      loop([], [],[],[], l)  
    }
    
    public SplitFirst[First,Second,Third](this l : list[First * Second * Third]) : list[First] * list[Second * Third]
    {
      def loop (acc1 : list [First], acc2 : list [Second * Third],l : list[First * Second * Third]) 
      {
        match (l) {
          | (a, b, c ) :: t => loop (a :: acc1, (b,c) :: acc2, t)
          | [] => (acc1.Rev(), acc2.Rev())
        }
      }
      loop([], [], l)  
    }  

    public SplitFirst[First,Second,Third,Fourth](this l : list[First * Second * Third * Fourth]) : list[First] * list[Second * Third * Fourth]
    {
      def loop (acc1 : list [First], acc2 : list [Second * Third * Fourth],l : list[First * Second * Third * Fourth]) 
      {
        match (l) 
        {
          | (a, b, c,d ) :: t => loop (a :: acc1, (b,c,d) :: acc2, t)
          | [] => (acc1.Rev(), acc2.Rev())
        }
      }
      loop([], [], l)  
    }  

    /// <summary>
    /// Поиск подсписка начинающегося с предиката
    /// </summary>        
    /// <param name="n">список</param>
    /// <param name="pred">начальный элемент соотв предикату</param>
    public FindList[T](this n : list[T],pred : T -> bool) : option[list[T]]
    {    
      match (n)
      {
        | head :: tail => if (pred(head)) 
                            option.Some(n) 
                          else 
                            FindList(tail,pred);   
        |_ => option.None();
      }
    }   

    public FindSub[T](this n : list[T],pred : T -> bool) : list[T]
    {    
      match (n)
      {
        | head :: tail => if (pred(head)) n
                          else 
                            FindSub(tail,pred);   
        |_ => []
      }
    }   
    
    /// <summary>
    /// Элементы до первого найденного, если не найден то возвращает весь лист
    /// </summary>   
    public FirstElems[T](this n : list[T],pred : T -> bool) : list[T]
    {      
      def loop(n,acc : list[T])
      {
        match (n)
        {
          | head :: tail => if (pred(head)) acc.Rev() else loop(tail,head :: acc);//FindList(tail,pred);          
          |_ => acc.Rev()
        }
      
      }
      loop(n,[]);
    }

    public FirstElemsInclude[T](this n : list[T],pred : T -> bool) : list[T]
    {      
      def loop(n,acc)
      {
        match (n)
        {
          | head :: tail => def res=head :: acc;
              if (pred(head)) res.Rev() else loop(tail,res);//FindList(tail,pred);          
          |_ => acc.Rev()
        }
      
      }
      loop(n,[]);
    }
    
    /// <summary>
    /// Поиск подсписка начинающегося с первого и заканчивающегося вторым предикатом
    /// </summary>        
    /// <param name="n">список</param>
    /// <param name="begin">начальный элемент соотв предикату</param>
    /// <param name="end">конечный элемент соотв предикату</param>
    public FindList[T](this n : list[T],begin : T -> bool,end : T -> bool) : option[list[T]]
    {    
      def lst=FindList(n,begin);
      lst.Map(x => x.Head ::FirstElems(x.Tail,end));               
    }

    /// <summary>
    /// Удаление дупликатов определяемых функцией сравнения
    /// </summary>        
    /// <param name="lst">список</param>
    /// <param name="eq_pred">Функция показывающая равенство двух элементов</param>
    public RemoveDuplicates[T](this lst : list [T],eq_pred : T * T -> bool) : list [T]
    {
      def loop (lst, acc)
      {
        match (lst)
        {
          | [] => acc.Reverse ();
          | [x] => (x :: acc).Reverse ();
          | x :: ((y :: _) as xs) =>
              if (eq_pred(x, y)) loop (xs, acc)
              else loop (xs, x :: acc)
        }
      }

      loop (lst, [])
    } 
     
    /// <summary>
    /// Удаление дупликатов определяемых функцией сравнения с автоматической сортировкой
    /// </summary>        
    /// <param name="lst">список</param>
    /// <param name="eq_pred">Функция показывающая сравнение двух элементов</param>
    public RemoveDuplicatesSort[T](this lst : list [T],eq_pred : T * T -> int) : list [T]
    {      
      def sorted=lst.Sort(eq_pred); // сортируем
      sorted.RemoveDuplicates((x1,x2) => eq_pred(x1,x2)==0); // удаляем дупликаты
    }
    /// <summary>
    /// Конверсия и фильтрация массива
    /// </summary>
    /// <param name="lst">массив</param>
    /// <param name="conv">функция конверсии</param>
    /// <param name="filter">функция фильтрации</param>
    public MapFilter[T,TRes](this lst : array[T],conv : T -> TRes,filter : TRes -> bool) : array[TRes]
    {
      def converted=lst.MapToArray(conv);
      converted.FilterToArray(filter);
    }
    
    /// <summary>
    /// Конвертация с дополнительным параметром
    /// </summary>
    /// <param name="arr">массив</param>
    /// <param name="init">начальное значение</param>
    /// <param name="conv">конвертер</param>
    /// <returns>результат</returns>
    public MapFold[T,TPar,TRes](this lst : list[T],init : TPar,conv : T * TPar -> TRes * TPar) : list[TRes]
    {
      def loop(lst,par,res)
      {
        match (lst)
        {
          | head :: tail => def (data,par)=conv(head,par);
              loop(tail,par,data :: res);
          |[] => res.Rev();
        }
      }
                  
      loop(lst,init,[]);
      
    }
    
    /// <summary>
    /// Конверсия с предыдущим и следующим элементом
    /// </summary>
    /// <param name="lst">список</param>
    /// <param name="conv">функция принимающая элемент * след * пред элементы</param>
    /// <returns>результирующий лист</returns>
    public MapNextPrev[T,TRes](this lst : list[T],conv : T * option[T] * option[T] -> TRes) : list[TRes]
    {
      def loop(lst,res,prev)
      {
        match (lst)
        { 
          | [] => res.Rev(); // результат с реверсом
          | head :: tail => def next=if (tail.IsEmpty()) option.None(); else option.Some(tail.Head); // получаем след. элемент                           
              def data= conv(head,next,prev); // конверсия с пред и след элементом
              loop(tail,data :: res,option.Some(head)); // продолжаем цикл
                                      
        }
      }
      
      loop(lst,[],option.None());
    }

    /// <summary>
    /// Конверсия с предыдущим и следующим элементом
    /// </summary>
    /// <param name="lst">список</param>
    /// <param name="conv">функция принимающая элемент * след * пред элементы</param>
    /// <returns>результирующий лист</returns>
    public IterNextPrev[T,TRes](this lst : list[T],func : T * option[T] * option[T] -> void) : void
    {
      def loop(lst,prev)
      {
        match (lst)
        {           
          | head :: tail => def next=if (tail.IsEmpty()) option.None(); else option.Some(tail.Head); // получаем след. элемент                           
              func(head,next,prev); // конверсия с пред и след элементом
              loop(tail,option.Some(head)); // продолжаем цикл
          | []
          |_ => ()
        }
      }
      
      loop(lst,option.None());
    }
    
    /// <summary>
    /// Максимальный элемент
    /// </summary>
    public MaxElement[T](this lst : list[T],selector : T -> int) : option[T]
    {
      def loop(lst,max,max_elem)
      {
        match (lst)
        {
          | head :: tail => def m=selector(head); // получаем значение элемента
              // если больше пред максимального то сохраняем новый, иначе оставляем старый
              def (max,elem)=if (m > max) (m,option.Some(head)) else (max,max_elem); 
              loop(tail,max,elem);
          |_ => max_elem
        }
      }
      
      loop(lst,0,option.None());
    }
    
    /// <summary>
    /// Инициализация элементов
    /// </summary>
    public Initialize[T](len : int,init_func : int -> T) : array[T]
    {
      def buf=array(len); // создаем массив
      
      for (mutable i=0;i<len;i++) // для всех элементов
      {
        buf[i]=init_func(i); // запускаем функцию инициализации
      }
      
      buf
    }
    
    /// <summary>
    /// Расширение массива до длины
    /// </summary>
    /// <param name="lst">массив</param>
    /// <param name="newlen">новая длина</param>
    /// <returns>результирующий массив</returns>
    public ExpandLength[T](this lst : array[T],newlen : int) : array[T] where T : new()
    {
      def len=lst.Length; // получаем длину тек массива
      if (len < newlen) // если длина меньше новой длины
      {
        def nlen=newlen-len; // вычитаем длину
        def new_buf=Initialize(nlen,_ => T()); // создаем новые элементы
        lst.Append(new_buf); // добавляем в старый массив
      } else lst;      
    }
    
    /// <summary>
    /// Получаем пары из элементов
    /// </summary>
    /// <param name="lst">список</param>    
    public MakePairs[T](this lst : list[T],pair_check : T -> bool) : list[T * T] * option[T] * option[T]
    {
      def loop(lst,prev,res,last)
      {
        match (lst)
        {
          | head :: tail => def second=pair_check(head);                                                        
                            // если последний
              def nlast=if (tail.IsEmpty() && !second) option.Some(head); else option.None();
              def next_res=if (second) (prev,head) :: res else res;  
              loop(tail,head,next_res,nlast);
          |[]                   
          | _ => (last,res.Rev())
        }
        
      }
      if (lst.NotEmpty())
      {
        def (first,lst)=if (pair_check(lst.Head)) (option.Some(lst.Head),lst.Tail) else (option.None(),lst);
      //if (lst.Length %&& 1) lst.
        def (last,lst)=loop(lst,default(T),[],option.None());
        (lst,first,last)
      } else ([],option.None(),option.None())
    }

    public MergeRegions[T](this lst : list[T],region_check : T -> bool,merge_func : list[T] -> T) : list[T]
    {
      def loop(lst,acc,res)
      {
        
        def get_acc(acc,res)
        {
          if (acc.NotEmpty())
          {                                  
            def nres=if (acc.Length==1) acc.First() else merge_func(acc.Rev());
            nres :: res                                 
          } else res;
        }
        
        match (lst)
        {
          | head :: tail => if (region_check(head))
                            {
                              loop(tail,head :: acc,res);
                            } else
                            {
                              def nres=get_acc(acc,res);
                              def ares=head :: nres;
                              loop(tail,[],ares);
                            }
          |_ => get_acc(acc,res).Rev();                              
        }
      }
      
      loop(lst,[],[]);
    }
    
    public MergePairs[T,TRes](this lst : list[T],pair_check : T -> bool,merge_func : T * T -> TRes) : list[TRes] * option[T] * option[T]
    {
      def (pairs,first,last)=lst.MakePairs(pair_check);
      def res=pairs.Map(merge_func);
      (res,first,last)
    }

    //MergePairs[T,TRes](this lst : list[T],first_elem : T -> bool,second_elem : T -> bool,null_val : T,map_func : T * T -> TRes) : list[TRes] * list[T] * list[T]
    //{      
    //  def pairs=lst.MakePairs(pair_check,null_val);
    //  def (good,bad)=pairs.Partition((x,y) => elem_good(x) && elem_good(y));
    //  def bad=bad.SplitNull(object.Equals(_,null_val));
    //  def converted=good.Map(map_func);
    //  (converted,bad)
    //}
        
    public SplitNull[T](this lst : list[T * T],null_func : T -> bool) : list[T]
    {
      def loop(lst,res : list[T])
      {
        match (lst)
        {          
          | (first,second) :: tail => def elem = if (null_func(first)) second else first;                                        
              loop(tail,if (null_func(elem)) res else elem :: res);
          |_ => res.Rev();
        }
      }
            
      loop(lst,[]);
    }
    
    /// <summary>
    /// Получаем элемент по индексу
    /// </summary>
    /// <param name="lst">список</param>            
    /// <param name="index">индекс</param>            
    public GetIndex[T](this lst : array[T],index : int) : T
    {
      def idx=if (index < 0) lst.Length-index else index;
      lst[idx]
    }

    /// <summary>
    /// Последний элемент
    /// </summary>
    /// <param name="lst">список</param>                
    public LastElem[T](this lst : array[T]) : T
    {
      lst.Last()
    }
    
    public NotEmpty[T](this lst : list[T]) : bool
    {
      !lst.IsEmpty()
    }
    
    public Exclude[T](this lst : array[T],lst2 : array[T]) : array[T]
    {
      if (lst2!=null)
        lst.FilterToArray(x => !lst2.Contains(x)); else lst
    }
    
    public NotEmpty[T](this lst : array[T]) : bool
    {
      lst.Length!=0
    }
    
    public PopLast[T](this lst : array[T]) : array[T] * T
    {
      def last=lst.Last();
      (lst.ChopLastN(1),last)
    }
        
    public Add[T](this lst : array[T],lst2 : array[T]) : array[T]
    {
      if (lst!=null) lst.Append(lst2) else lst2;
    }
    
    public NotEmpty[T](this lst : List[T]) : bool
    {
      lst.Count!=0
    }
    
    /// <summary>
    /// Выдает из списка только соответствующие результирующему типу     
    /// </summary>
    /// <param name="lst">список</param>                    
    /// <returns>результат * оставшиеся элементы</returns>
    public MapFilterType[T,TRes](this lst : list[T]) : list[TRes] * list[T]
    {
      //lst.MapFiltered(x : T => x is TRes,x : T => x :> TRes);
      def loop(lst : list[T],res,acc)
      {
        match (lst)
        {
          |(head is TRes) :: tail => loop(tail,head :: res,acc)
          |head :: tail => loop(tail,res,head :: acc);                     
          |_ => (res.Rev(),acc.Rev())
        }
      }
          
      loop(lst,[],[]);
      
    }

    /// <summary>
    /// Выдает из списка первый элемент соответствующий результирующему типу     
    /// </summary>
    /// <param name="lst">список</param>                    
    /// <returns>результат * оставшиеся элементы</returns>    
    public FindType[T,TRes](this lst : list[T]) : option[TRes] * list[T]
    {
      def loop(lst : list[T],res)
      {
        match (lst)
        {
          |(head is TRes) :: tail => (option.Some(head),res.Rev()+tail)
          |head :: tail => loop(tail,head :: res);
          |_ => (option.None(),res.Rev())
        }
      }
          
      loop(lst,[]);
    }

    /// <summary>
    /// Фильтрует только элементы с в которых есть значения
    /// </summary>
    /// <param name="lst">список</param>                    
    /// <returns>результат</returns>        
    public FilterValues[T](this lst : list[option[T]]) : list[T]
    {      
      $[x.Value,x in lst,x.HasValue]
    }

    public FilterValues[T,TRes](this lst : list[T],pred : T -> option[TRes]) : list[TRes]
    {      
      def loop(lst,res)
      {
        match (lst)
        {
          |head :: tail => match (pred(head))
              {
                |Some(val) => loop(tail,val :: res)
                |_ => loop(tail,res)
              }
          |_ => res.Rev()                 
        }
      }
    
      loop(lst,[])
    }

    public FilterType[T,TRes](this lst : list[T]) : list[TRes]
    {      
      def loop(lst : list[T],res)
      {
        match (lst)
        {
          |(head is TRes) :: tail => loop(tail,head :: res)
          |_ :: tail => loop(tail,res);
          |_ => res.Rev()
        }
      }
          
      loop(lst,[]);

    }
    
    public PairMap[T,TRes](this lst : list[T],cnv : T * T -> TRes) : list[TRes]
    {
      def loop(lst,res)
      {
        match (lst)
        {
          |first :: second :: tail => loop(tail,cnv(first,second) :: res);
          |_ => res.Rev()
        }
      }
        
      loop(lst,[]);
    }
    
    /// <summary>
    /// Выдает из списка элементы, которых нет во втором списке
    /// </summary>
    /// <param name="lst">список</param>                    
    /// <param name="lst2">список 2</param>                    
    /// <param name="eq">предикат сравнения</param>                    
    /// <returns>результат</returns>        
    public Exclude[T,T2](this lst : list[T],lst2 : IEnumerable[T2],eq : T * T2 -> bool) : list[T]
    {     
      lst.Filter(x => !lst2.Exists(y => eq(x,y)));
        //$[x,x in lst,y in lst2,!eq(x,y)]
    }
    
    public MapIndex[T,TRes](this lst : list[T],conv : (T * int) -> TRes) : list[TRes]
    {
      def loop(lst,idx,res)
      {
        match (lst)
        {
          |head :: tail => loop(tail,idx+1,conv(head,idx) :: res)
          |_ => res.Rev()
        }
      }
      
      loop(lst,0,[])
    }
    
    public FindSingle[T,T2](this lst : list[T * list[T2]],pred : T2 -> bool) : option[T * T2]
    {
      def loop(lst)
      {
        |(x,lst) :: tail => 
            match (lst.Find(pred)) 
            {
                |Some(v) => Some((x,v))
                |_ => loop(tail)
            }
        |_ => option.None()
      }
        //def a=lst.Find((x,y) => y.Find(pred).IsSome);
      loop(lst)
    }
    
    public FindSingleList[T,T2](this lst : list[T * list[T2]],pred : T2 -> bool) : list[T * T2]
    {
      def loop(lst,res)
      {
        match (lst)
        {
          |(x,lst) :: tail => 
              match (lst.Find(pred)) 
              {
                  |Some(val) => loop(tail,(x,val) :: res)
                  |_ => loop(tail,res)
              } 
          |_ => res.Rev()
        }
      }
        //def a=lst.Find((x,y) => y.Find(pred).IsSome);
      loop(lst,[])
    }
    
    public MapFirst[T,T2,T3](this lst : list[T * T2],conv : T -> T3) : list[T3]
    {
      lst %|> conv(_)
        //lst.Map((x,_) => pred(x))
    }
    
    public MapSecond[T,T2,T3](this lst : list[T * T2],conv : T2 -> T3) : list[T3]
    {
      lst ^|> conv(_)
        //lst.Map((_,x) => pred(x))
    }
    
    public MapDefault[T,T2](this opt : option[T],conv : T -> T2,default : T2) : T2
    {
      match (opt)
      {
        |Some(val) => conv(val)
        |_ => default
      }
    }
    
    public Duplicates[T](this lst : list[T],comp : T * T -> int) : list[T]
    {
      def sorted=lst.Sort(comp);
        
      def loop (lst, acc)
      {
        match (lst)
        {
          | [] => acc.Reverse();
          | [_] => acc.Reverse();
          | x :: ((y :: _) as xs) =>
              if (comp(x, y)!=0) loop (xs, acc)
              else loop (xs, x :: acc)
        }
      }

      loop (sorted, [])
        
    }

    public FindDelimited[T](this lst : list[T],pred : T -> bool) : list[list[T]]
    {
      def loop(lst,res,subres)
      {
        match (lst)
        {
          |head :: tail => if (pred(head)) loop(tail,subres.Rev() :: res,[]) else loop(tail,res,head :: subres)
          |_ => res.Rev()
        }
      }
        
      loop(lst,[],[])
    }
  }
  
}
