<?xml version="1.0"?>
<doc>
  <assembly>
    <name>C:\Temp\trunk-read-only\bin\Release\net-3.5\\Stage4\\Nemerle.xml</name>
  </assembly>
  <members>
    <member name="T:Nemerle.Concurrency.BitMask" />
    <member name="F:Nemerle.Concurrency.BitMask.i" />
    <member name="M:Nemerle.Concurrency.BitMask.Set(System.UInt32)" />
    <member name="M:Nemerle.Concurrency.BitMask.Clear(System.UInt32)" />
    <member name="M:Nemerle.Concurrency.BitMask.Match(System.UInt32)" />
    <member name="T:Nemerle.Concurrency.ThreadQueue" />
    <member name="M:Nemerle.Concurrency.ThreadQueue.#ctor" />
    <member name="F:Nemerle.Concurrency.ThreadQueue.signaled" />
    <member name="F:Nemerle.Concurrency.ThreadQueue.count" />
    <member name="M:Nemerle.Concurrency.ThreadQueue.get_Empty" />
    <member name="P:Nemerle.Concurrency.ThreadQueue.Empty" />
    <member name="M:Nemerle.Concurrency.ThreadQueue.Yield(System.Object)" />
    <member name="M:Nemerle.Concurrency.ThreadQueue.Wakeup" />
    <member name="T:Nemerle.Concurrency.DummyQueue" />
    <member name="M:Nemerle.Concurrency.DummyQueue.#ctor" />
    <member name="F:Nemerle.Concurrency.DummyQueue.count" />
    <member name="M:Nemerle.Concurrency.DummyQueue.Add" />
    <member name="M:Nemerle.Concurrency.DummyQueue.Take" />
    <member name="M:Nemerle.Concurrency.DummyQueue.get_IsEmpty" />
    <member name="P:Nemerle.Concurrency.DummyQueue.IsEmpty" />
    <member name="T:Nemerle.Core.AssertionException">
      <summary>
        <para>This namespace is always opened

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.AssertionException.#ctor" />
    <member name="M:Nemerle.Core.AssertionException.#ctor(System.String,System.Int32,System.String,System.String)" />
    <member name="T:Nemerle.Core.MatchFailureException" />
    <member name="M:Nemerle.Core.MatchFailureException.#ctor" />
    <member name="T:Nemerle.Core.NullMatchException" />
    <member name="M:Nemerle.Core.NullMatchException.#ctor" />
    <member name="M:Nemerle.Core.NullMatchException.raise_self" />
    <member name="T:Nemerle.Core.AssemblyFindException" />
    <member name="M:Nemerle.Core.AssemblyFindException.#ctor" />
    <member name="T:Nemerle.Core.byte" />
    <member name="T:Nemerle.Core.sbyte" />
    <member name="T:Nemerle.Core.short" />
    <member name="T:Nemerle.Core.ushort" />
    <member name="T:Nemerle.Core.int" />
    <member name="T:Nemerle.Core.uint" />
    <member name="T:Nemerle.Core.long" />
    <member name="T:Nemerle.Core.ulong" />
    <member name="T:Nemerle.Core.float" />
    <member name="T:Nemerle.Core.double" />
    <member name="T:Nemerle.Core.decimal" />
    <member name="T:Nemerle.Core.string" />
    <member name="T:Nemerle.Core.object" />
    <member name="T:Nemerle.Core.bool" />
    <member name="T:Nemerle.Core.char" />
    <member name="T:Nemerle.Hacks.IComparableClass" />
    <member name="M:Nemerle.Hacks.IComparableClass.#ctor" />
    <member name="M:Nemerle.Hacks.IComparableClass.CompareTo(Nemerle.Hacks.IComparableClass)" />
    <member name="T:Nemerle.Diagnostics.NDebug" />
    <member name="M:Nemerle.Diagnostics.NDebug.#cctor" />
    <member name="F:Nemerle.Diagnostics.NDebug.StackTraceDepth" />
    <member name="M:Nemerle.Diagnostics.NDebug.ToStringWitoutNs(System.Object)" />
    <member name="M:Nemerle.Diagnostics.NDebug.PrintStackTrace" />
    <member name="T:Nemerle.Utility.Getopt">
      <summary>
        <para>Command line options handling.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.Getopt._N_parse_opts_9652(Nemerle.Utility.Getopt._N_closure_9527,Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Utility.Getopt._N_parse_opt_9646(Nemerle.Utility.Getopt._N_closure_9527,System.String,Nemerle.Core.option{System.String})" />
    <member name="M:Nemerle.Utility.Getopt._N_need_following_arg_9626(Nemerle.Utility.Getopt._N_closure_9527,System.String)" />
    <member name="M:Nemerle.Utility.Getopt._N_is_option_9610(Nemerle.Utility.Getopt._N_closure_9527,System.String)" />
    <member name="M:Nemerle.Utility.Getopt._N_argument_name_9592(System.String)" />
    <member name="M:Nemerle.Utility.Getopt._N_option_name_9572(System.String)" />
    <member name="M:Nemerle.Utility.Getopt._N_stdsuff_9420(Nemerle.Utility.Getopt._N_closure_9403)" />
    <member name="M:Nemerle.Utility.Getopt._N_stdpref_9412(Nemerle.Utility.Getopt._N_closure_9403,Nemerle.Utility.Getopt._N_closure_9378)" />
    <member name="M:Nemerle.Utility.Getopt._N_concat_9384(Nemerle.Utility.Getopt._N_closure_9378,System.String,Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Utility.Getopt.Usage(Nemerle.Core.list{Nemerle.Utility.Getopt.CliOption})" />
    <member name="M:Nemerle.Utility.Getopt.Parse(Nemerle.Builtins.FunctionVoid{System.String},Nemerle.Core.list{Nemerle.Utility.Getopt.CliOption},Nemerle.Core.list{System.String})">
      <summary>
        <para>Parses the command line options.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.Getopt.Error(System.String)" />
    <member name="M:Nemerle.Utility.Getopt.Parse(Nemerle.Core.list{Nemerle.Utility.Getopt.CliOption})" />
    <member name="T:Nemerle.Utility.Getopt.CliOption" />
    <member name="T:Nemerle.Collections.Hashtable`2">
      <summary>
        <para>This is a subtype of Generic.Dictionary, which provides some additional
  functional-style methods to its base type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:Nemerle.Collections.Hashtable`2"></see> class that is empty, has the default initial capacity, and uses the default equality comparer for the key type.</para>
      </summary>

</member>
    <member name="M:Nemerle.Collections.Hashtable`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
        <para>Initializes a new instance of the <see cref="T:Nemerle.Collections.Hashtable`2"></see> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2"></see> and uses the default equality comparer for the key type.</para>
      </summary>
 <param name="dictionary"><para>The <see cref="T:System.Collections.Generic.IDictionary`2"></see> whose elements are copied to the new <see cref="T:Nemerle.Collections.Hashtable`2"></see>.</para></param>
 <exception cref="T:System.ArgumentException"><para>dictionary contains one or more duplicate keys.</para></exception>
 <exception cref="T:System.ArgumentNullException"><para>dictionary is null.</para></exception>

</member>
    <member name="M:Nemerle.Collections.Hashtable`2.#ctor(System.Collections.Generic.IEnumerable{Nemerle.Builtins.Tuple{`0,`1}})">
      <summary>
        <para>Initializes a new instance of the <see cref="T:Nemerle.Collections.Hashtable`2"></see> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IEnumerable`1"></see> and uses the default equality comparer for the key type.</para>
      </summary>
 <param name="dictionary"><para>The <see cref="T:System.Collections.Generic.IEnumerable`1"></see> whose elements are copied to the new <see cref="T:Nemerle.Collections.Hashtable`2"></see>.</para></param>

</member>
    <member name="M:Nemerle.Collections.Hashtable`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
        <para>Initializes a new instance of the Hashtable[,] class that is empty, has the default
 initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see>.</para>
      </summary>
 <param name="comparer"><para>The <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"></see> for the type of the key.</para></param>

</member>
    <member name="M:Nemerle.Collections.Hashtable`2.#ctor(System.Int32)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:Nemerle.Collections.Hashtable`2"></see> class that is empty, has the specified initial capacity, and uses the default equality comparer for the key type.</para>
      </summary>
 <param name="capacity"><para>The initial number of elements that the <see cref="T:Nemerle.Collections.Hashtable`2"></see> can contain.</para></param>
 <exception cref="T:System.ArgumentOutOfRangeException"><para>capacity is less than 0.</para></exception>

</member>
    <member name="M:Nemerle.Collections.Hashtable`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
        <para>Initializes a new instance of the <see cref="T:Nemerle.Collections.Hashtable`2"></see> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2"></see> and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see>.</para>
      </summary>
 <param name="dictionary"><para>The <see cref="T:System.Collections.Generic.IDictionary`2"></see> whose elements are copied to the new <see cref="T:Nemerle.Collections.Hashtable`2"></see>.</para></param>
 <param name="comparer"><para>The <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"></see> for the type of the key.</para></param>
 <exception cref="T:System.ArgumentException"><para>dictionary contains one or more duplicate keys.</para></exception>
 <exception cref="T:System.ArgumentNullException"><para>dictionary is null.</para></exception>

</member>
    <member name="M:Nemerle.Collections.Hashtable`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
        <para>Initializes a new instance of the <see cref="T:Nemerle.Collections.Hashtable`2"></see> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see>.</para>
      </summary>
 <param name="capacity"><para>The initial number of elements that the <see cref="T:Nemerle.Collections.Hashtable`2"></see> can contain.</para></param>
 <param name="comparer"><para>The <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"></see> for the type of the key.</para></param>
 <exception cref="T:System.ArgumentOutOfRangeException"><para>capacity is less than 0.</para></exception>

</member>
    <member name="M:Nemerle.Collections.Hashtable`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:System.Collections.Generic.Dictionary`2"></see> class with serialized data.</para>
      </summary>
 <param name="context"><para>A <see cref="T:System.Runtime.Serialization.StreamingContext"></see> structure containing the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.Dictionary`2"></see>.</para></param>
 <param name="info"><para>A <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> object containing the information required to serialize the <see cref="T:System.Collections.Generic.Dictionary`2"></see>.</para></param>

</member>
    <member name="M:Nemerle.Collections.Hashtable`2.Get(`0)">
      <summary>
        <para>Returns an optional value associated with the specified key.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.TryGetValue(`0)" />
    <member name="M:Nemerle.Collections.Hashtable`2.GetValueOrDefault(`0)">
      <summary>
        <para>Returns value associated with the specified key or default value (null for
 referece type and result of parameterless constractor for value type).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.GetValueOrDefault(`0,`1)">
      <summary>
        <para>Returns value associated with the specified key or defaultValue.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.GetValueOrGetDefault(`0,Nemerle.Builtins.Function{`1})">
      <summary>
        <para>Returns value associated with the specified key or result of call getDefaultValue().
 The getDefaultValue() called only if key not exists in collection.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.GetValue(`0,Nemerle.Builtins.Function{`1})">
      <summary>
        <para>Returns value associated with the specified key or new value.
 The new value obtain by call getNewValue(). The new value add
 to collection before return to caller.
 The getNewValue() called only if key not exists in collection.
 Example:
 def map = Hashtable();
 Console.WriteLine(map.GetValue("1", () =&gt; 1)); // Write "1"
 Console.WriteLine(map.GetValue("1", () =&gt; 2)); // Write "1"
 Console.WriteLine(map["1"]);                   // Write "1"

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.Set(`0,`1)">
      <summary>
        <para>This is different from add, which can fail if the key is
 already in the underlying Framework hashtable.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.Update(`0,`1,Nemerle.Builtins.Function{`1,`1})">
      <summary>
        <para>Updates value associated with the specified key.
 If key not exists defaultValue used instead.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.Update(`0,Nemerle.Builtins.Function{`1},Nemerle.Builtins.Function{`1,`1})" />
    <member name="M:Nemerle.Collections.Hashtable`2.Clone">
      <summary>
        <para>Clones this hashtable.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.Contains(`0)">
      <summary>
        <para>Returns `true' if the hashtable contains the specified key.

</para>
      </summary> <remarks><para>NOTE: this is the same as ContainsKey.

</para></remarks></member>
    <member name="M:Nemerle.Collections.Hashtable`2.Fold``1(``0,Nemerle.Builtins.Function{`0,`1,``0,``0})">
      <summary>
        <para>Folds a function over the key/value pairs.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.Iter(Nemerle.Builtins.FunctionVoid{`0,`1})">
      <summary>
        <para>Iterates a function over the key/value pairs in the hashtable.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.Map``2(Nemerle.Builtins.Function{`0,`1,Nemerle.Builtins.Tuple{``0,``1}})">
      <summary>
        <para>Maps a given function defined of key-value pairs to the contents
 of this hashtable. A new hashtable object is created, containing
 the results of the application.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.Filter(Nemerle.Builtins.Function{`0,`1,System.Boolean})">
      <summary>
        <para>Removes elements for which predicate is false

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.Remove(`0)" />
    <member name="M:Nemerle.Collections.Hashtable`2.get_KeyValuePairs" />
    <member name="P:Nemerle.Collections.Hashtable`2.KeyValuePairs">
      <summary>
        <para>Returns a collection of the key/value pairs from this hashtable

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Hashtable`2.better_to_string(System.Object)" />
    <member name="M:Nemerle.Collections.Hashtable`2.ToString" />
    <member name="T:Nemerle.Collections.EmptyHeap">
      <summary>
        <para>A handy shortcut for the EmptyCollection exception.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.EmptyHeap.#ctor" />
    <member name="T:Nemerle.Collections.Heap`1">
      <summary>
        <para>General usage heap, can be used as priority queue.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.System#Collections#IEnumerable#GetEnumerator" />
    <member name="M:Nemerle.Collections.Heap`1.#ctor(`0[])">
      <summary>
        <para>Creates new heap that will initialy contain elements from array a.
 All the elements are copied into the heap, so later modifications of a
 do not influence the heap. This operation takes time O(n), where n
 is the number of elements in array a.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
        <para>Creates new heap initially filled with elements from given collection

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.#ctor(System.Int32)">
      <summary>
        <para>Creates a new empty heap with given initial capacity.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.#ctor">
      <summary>
        <para>Private constructor, do not use from outside this class.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.get_IsEmpty" />
    <member name="P:Nemerle.Collections.Heap`1.IsEmpty">
      <summary>
        <para>Checks if the heap is empty.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.get_Count" />
    <member name="P:Nemerle.Collections.Heap`1.Count">
      <summary>
        <para>Returns number of elements in the heap.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.get_CurrentCapacity" />
    <member name="P:Nemerle.Collections.Heap`1.CurrentCapacity">
      <summary>
        <para>Returns the number of elements that this heap can store
 without the need to grow.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.get_IsReadOnly" />
    <member name="P:Nemerle.Collections.Heap`1.IsReadOnly">
      <summary>
        <para>Returns false.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.get_Capacity" />
    <member name="P:Nemerle.Collections.Heap`1.Capacity">
      <summary>
        <para>Returns the number of elements that this heap can store
 without the need to grow.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.Insert(`0)">
      <summary>
        <para>Inserts a new element into the heap.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.Add(`0)" />
    <member name="M:Nemerle.Collections.Heap`1.Clear">
      <summary>
        <para>Count is set to 0, and references to other objects from elements of the collection are also released.

</para>
      </summary> <remarks><para>Capacity remains unchanged.

</para></remarks></member>
    <member name="M:Nemerle.Collections.Heap`1.Top">
      <summary>
        <para>Returns the first (with maximal priority) element from the heap
 without removing it. Throws EmptyHeap exception.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.ExtractFirst">
      <summary>
        <para>Returns the first (with maximal priority) element from the heap,
 removing it. Throws EmptyHeap exception.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.CopyTo(`0[],System.Int32)">
      <summary>
        <para>Copies elements from heap to given array, starting at specified index in target array

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.Contains(`0)">
      <summary>
        <para>Checks if given value is contained in heap. This is O(n) operation in worst case.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.Map``1(Nemerle.Builtins.Function{`0,``0})">
      <summary>
        <para>Creates new heap of elements of type 'b. New heap is totally independent, i.e.
 any changes in original heap do not influence the second one and vice versa.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.Iter(Nemerle.Builtins.FunctionVoid{`0})">
      <summary>
        <para>Calls the specified function for all elements of this heap.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.Fold``1(Nemerle.Builtins.Function{``0,`0,``0},``0)">
      <summary>
        <para>Folds this heap's elements using the specified function
 and an initial value.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.GetEnumerator" />
    <member name="M:Nemerle.Collections.Heap`1.Remove(`0)" />
    <member name="M:Nemerle.Collections.Heap`1.grow">
      <summary>
        <para>Grows the table that is used to store heap elements
 multiplying size by 2.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.is_greater(System.Int32,System.Int32)">
      <summary>
        <para>Checks if the element at index k is greater than the element at index l.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.parent(System.Int32)">
      <summary>
        <para>Calculates the index of the parent of element at index i.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.left(System.Int32)">
      <summary>
        <para>Calculates the index of the left child of element at index i.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.right(System.Int32)">
      <summary>
        <para>Calculates the index of the right child of element at index i.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.heapify(System.Int32)">
      <summary>
        <para>Repairs the heap structure starting from element at index i, moving down.
 For explanations see Cormen, Leiserson, Rivest "Introduction to algorithms".

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Heap`1.build_heap">
      <summary>
        <para>Builds the heap from elements stored in the m_heap array.
 This is done in time O (m_heap.Length).

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Collections.Heap`1.m_heap">
      <summary>
        <para>An array that stores the heap, elements are stored in heap[1]..heap[count]

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Collections.Heap`1.m_elements_count">
      <summary>
        <para>The number of the elements that are in the heap right now

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Extensions.IAnonymous">
      <summary>
        <para>This interface is implemented by any Nemerle anonymous class.
</para>
      </summary>

</member>
    <member name="M:Nemerle.Extensions.IAnonymous.get_Item(System.String)" />
    <member name="P:Nemerle.Extensions.IAnonymous.Item">
      <summary>
        <para>Field indexer. Returns null when specified field does not exist.
</para>
      </summary>

</member>
    <member name="M:Nemerle.Extensions.IAnonymous.GetFields">
      <summary>
        <para>List of fields that anonymous class instance has.
</para>
      </summary>

</member>
    <member name="M:Nemerle.Extensions.IAnonymous.GetContent">
      <summary>
        <para>Entire content of anonymous type depending on number of fields:
a) null if there is not fields,
b) value of single field,
c) tuple when there are more than one field,
d) list if there are more fields than tuple can hold.
</para>
      </summary>

</member>
    <member name="T:Nemerle.Extensions.Anonymous" />
    <member name="F:Nemerle.Extensions.Anonymous._N_cache_5261" />
    <member name="M:Nemerle.Extensions.Anonymous.FieldsAreEqual(System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.Collections.ObjectModel.ReadOnlyCollection{System.String})" />
    <member name="M:Nemerle.Extensions.Anonymous.Equals(Nemerle.Extensions.IAnonymous,Nemerle.Extensions.IAnonymous)" />
    <member name="T:Nemerle.ICloneable`1" />
    <member name="M:Nemerle.ICloneable`1.Clone" />
    <member name="T:Nemerle.Collections.EmptyCollection">
      <summary>
        <para>Exception thrown when an element access operation is performed
 on an empty ICollection object.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Collections.EmptyCollection.msg" />
    <member name="M:Nemerle.Collections.EmptyCollection.#ctor(System.String)" />
    <member name="T:Nemerle.Collections.ICovariantEnumerator`1" />
    <member name="M:Nemerle.Collections.ICovariantEnumerator`1.MoveNext" />
    <member name="M:Nemerle.Collections.ICovariantEnumerator`1.get_Current" />
    <member name="P:Nemerle.Collections.ICovariantEnumerator`1.Current" />
    <member name="M:Nemerle.Collections.ICovariantEnumerator`1.Reset" />
    <member name="T:Nemerle.Collections.ICovariantEnumerable`1" />
    <member name="M:Nemerle.Collections.ICovariantEnumerable`1.GetEnumerator" />
    <member name="T:Nemerle.Collections.ICovariantList`1" />
    <member name="M:Nemerle.Collections.ICovariantList`1.get_IsEmpty" />
    <member name="P:Nemerle.Collections.ICovariantList`1.IsEmpty" />
    <member name="M:Nemerle.Collections.ICovariantList`1.get_Head" />
    <member name="P:Nemerle.Collections.ICovariantList`1.Head" />
    <member name="M:Nemerle.Collections.ICovariantList`1.get_CovariantTail" />
    <member name="P:Nemerle.Collections.ICovariantList`1.CovariantTail" />
    <member name="T:Nemerle.Collections.ICollection`1">
      <summary>
        <para>The collection interface.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.get_IsEmpty" />
    <member name="P:Nemerle.Collections.ICollection`1.IsEmpty">
      <summary>
        <para>Returns `true' if the collection is empty.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.First">
      <summary>
        <para>Returns the first of the collection elements, if there is one.
 Throws EmptyCollection exception otherwise.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.Clone">
      <summary>
        <para>Creates a shallow copy of this collection.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.Fold``1(Nemerle.Builtins.Function{`0,``0,``0},``0)">
      <summary>
        <para>Folds the collection using the specified fold function and an initial
 value. Order in which the elements are folded is unspecified.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.Map``1(Nemerle.Builtins.Function{`0,``0})">
      <summary>
        <para>Maps the supplied function to the elements of this collection,
 creating a new collection.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.Iter(Nemerle.Builtins.FunctionVoid{`0})">
      <summary>
        <para>Calls the supplied function for all the elements of this collection.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.ForAll(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Checks if all the members of this collection satisfy the supplied
 predicate.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.Exists(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Checks if there exists a member of collection that satisfies
 the supplied condition.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.Filter(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Filters the collection removing all elements that do not satisfy
 the supplied predicate.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ICollection`1.Partition(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Partitions collection into two collections: elements that satisfy
 and elements that do not satisfy the supplied predicate.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.IO">
      <summary>
        <para>Helper functions for handling the standard input stream

</para>
      </summary>
    </member>
    <member name="M:Nemerle.IO.ConsumeWhiteSpace(System.IO.TextReader)" />
    <member name="M:Nemerle.IO.ReadIntDigits(System.IO.TextReader)">
      <summary>
        <para>Read digital characters returning integer value of read string

</para>
      </summary>
    </member>
    <member name="M:Nemerle.IO.ReadString(System.IO.TextReader)">
      <summary>
        <para>Read digital characters returning real value of read string

</para>
      </summary> <remarks><para>Reads characters up to first occurence of whitespace and returns
 read string

</para></remarks></member>
    <member name="M:Nemerle.IO.ReadChar(System.IO.TextReader)" />
    <member name="M:Nemerle.IO.CheckInput(System.String,System.IO.TextReader)">
      <summary>
        <para>Checks if input consist exactly of given string (all consecutive
 sequences of whitespaces in string and input are treated as single
 whitespace character, thus they match each other)

</para>
      </summary>
    </member>
    <member name="T:Nemerle.IO.InvalidInput" />
    <member name="T:Nemerle.Compiler.SystemTypeExtensions">
      <summary>
        <para>System.Type.FullName is null if it contains free generic parameters.
 Here is replacement which doesn't return null and should be suitable.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.SystemTypeExtensions.TypeFullName(System.Type)" />
    <member name="T:Nemerle.Internal.NemerleAttribute" />
    <member name="M:Nemerle.Internal.NemerleAttribute.#ctor" />
    <member name="T:Nemerle.Internal.IgnoreFieldAttribute" />
    <member name="M:Nemerle.Internal.IgnoreFieldAttribute.#ctor" />
    <member name="T:Nemerle.Internal.IgnoreConstructorAttribute" />
    <member name="M:Nemerle.Internal.IgnoreConstructorAttribute.#ctor" />
    <member name="T:Nemerle.Internal.VolatileModifier">
      <summary>
        <para>Marks a volatile field

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Internal.VolatileModifier.#ctor" />
    <member name="T:Nemerle.Internal.ImmutableAttribute">
      <summary>
        <para>Marks an immutable field

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Internal.ImmutableAttribute.#ctor" />
    <member name="T:Nemerle.Internal.ExtensionAttribute" />
    <member name="M:Nemerle.Internal.ExtensionAttribute.#ctor" />
    <member name="T:Nemerle.Internal.OperatorAttribute">
      <summary>
        <para>Used to store the custom operator priorities loaded as syntax extensions

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Internal.OperatorAttribute.env" />
    <member name="F:Nemerle.Internal.OperatorAttribute.name" />
    <member name="F:Nemerle.Internal.OperatorAttribute.isUnary" />
    <member name="F:Nemerle.Internal.OperatorAttribute.left" />
    <member name="F:Nemerle.Internal.OperatorAttribute.right" />
    <member name="M:Nemerle.Internal.OperatorAttribute.ToString" />
    <member name="M:Nemerle.Internal.OperatorAttribute.get_Env" />
    <member name="P:Nemerle.Internal.OperatorAttribute.Env" />
    <member name="M:Nemerle.Internal.OperatorAttribute.get_Name" />
    <member name="P:Nemerle.Internal.OperatorAttribute.Name" />
    <member name="M:Nemerle.Internal.OperatorAttribute.get_IsUnary" />
    <member name="P:Nemerle.Internal.OperatorAttribute.IsUnary" />
    <member name="M:Nemerle.Internal.OperatorAttribute.get_Left" />
    <member name="P:Nemerle.Internal.OperatorAttribute.Left" />
    <member name="M:Nemerle.Internal.OperatorAttribute.get_Right" />
    <member name="P:Nemerle.Internal.OperatorAttribute.Right" />
    <member name="M:Nemerle.Internal.OperatorAttribute.#ctor(System.String,System.String,System.Boolean,System.Int32,System.Int32)">
      <summary>
        <para>Used to store the custom operator priorities loaded as syntax extensions

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Internal.VariantAttribute">
      <summary>
        <para>Marks a Nemerle variant type

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Internal.VariantAttribute.variantOptions" />
    <member name="M:Nemerle.Internal.VariantAttribute.ToString" />
    <member name="M:Nemerle.Internal.VariantAttribute.get_VariantOptions" />
    <member name="P:Nemerle.Internal.VariantAttribute.VariantOptions" />
    <member name="M:Nemerle.Internal.VariantAttribute.#ctor(System.String)">
      <summary>
        <para>Marks a Nemerle variant type

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Internal.VariantOptionAttribute">
      <summary>
        <para>Marks a Nemerle variant option

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Internal.VariantOptionAttribute.#ctor" />
    <member name="T:Nemerle.Internal.ConstantVariantOptionAttribute">
      <summary>
        <para>Marks a constant Nemerle variant option

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Internal.ConstantVariantOptionAttribute.#ctor" />
    <member name="T:Nemerle.Internal.TypeAliasAttribute">
      <summary>
        <para>Container for type aliases.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Internal.TypeAliasAttribute.aliasedType" />
    <member name="M:Nemerle.Internal.TypeAliasAttribute.ToString" />
    <member name="M:Nemerle.Internal.TypeAliasAttribute.get_AliasedType" />
    <member name="P:Nemerle.Internal.TypeAliasAttribute.AliasedType" />
    <member name="M:Nemerle.Internal.TypeAliasAttribute.#ctor(System.String)">
      <summary>
        <para>Container for type aliases.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Internal.ContainsMacroAttribute">
      <summary>
        <para>Used on assembly to list contained macros.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Internal.ContainsMacroAttribute.name" />
    <member name="M:Nemerle.Internal.ContainsMacroAttribute.ToString" />
    <member name="M:Nemerle.Internal.ContainsMacroAttribute.get_Name" />
    <member name="P:Nemerle.Internal.ContainsMacroAttribute.Name" />
    <member name="M:Nemerle.Internal.ContainsMacroAttribute.#ctor(System.String)">
      <summary>
        <para>Used on assembly to list contained macros.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Internal.MacroAttribute" />
    <member name="F:Nemerle.Internal.MacroAttribute.name" />
    <member name="F:Nemerle.Internal.MacroAttribute.global_ctx" />
    <member name="F:Nemerle.Internal.MacroAttribute.parameters" />
    <member name="M:Nemerle.Internal.MacroAttribute.ToString" />
    <member name="M:Nemerle.Internal.MacroAttribute.#ctor(System.String,System.Int32,System.String)" />
    <member name="T:Nemerle.Internal.ExtensionPatternEncodingAttribute" />
    <member name="F:Nemerle.Internal.ExtensionPatternEncodingAttribute.name" />
    <member name="F:Nemerle.Internal.ExtensionPatternEncodingAttribute.identifiers" />
    <member name="F:Nemerle.Internal.ExtensionPatternEncodingAttribute.pattern" />
    <member name="M:Nemerle.Internal.ExtensionPatternEncodingAttribute.ToString" />
    <member name="M:Nemerle.Internal.ExtensionPatternEncodingAttribute.get_Name" />
    <member name="P:Nemerle.Internal.ExtensionPatternEncodingAttribute.Name" />
    <member name="M:Nemerle.Internal.ExtensionPatternEncodingAttribute.get_Identifiers" />
    <member name="P:Nemerle.Internal.ExtensionPatternEncodingAttribute.Identifiers" />
    <member name="M:Nemerle.Internal.ExtensionPatternEncodingAttribute.get_Pattern" />
    <member name="P:Nemerle.Internal.ExtensionPatternEncodingAttribute.Pattern" />
    <member name="M:Nemerle.Internal.ExtensionPatternEncodingAttribute.#ctor(System.String,System.String,System.String)" />
    <member name="T:Nemerle.Internal.RegisterParserAttribute" />
    <member name="F:Nemerle.Internal.RegisterParserAttribute.name" />
    <member name="F:Nemerle.Internal.RegisterParserAttribute.extension" />
    <member name="M:Nemerle.Internal.RegisterParserAttribute.ToString" />
    <member name="M:Nemerle.Internal.RegisterParserAttribute.get_Name" />
    <member name="P:Nemerle.Internal.RegisterParserAttribute.Name" />
    <member name="M:Nemerle.Internal.RegisterParserAttribute.get_Extension" />
    <member name="P:Nemerle.Internal.RegisterParserAttribute.Extension" />
    <member name="M:Nemerle.Internal.RegisterParserAttribute.#ctor(System.String,System.String)" />
    <member name="T:Nemerle.Utility.Identity`2" />
    <member name="M:Nemerle.Utility.Identity`2.#cctor" />
    <member name="M:Nemerle.Utility.Identity`2.#ctor" />
    <member name="F:Nemerle.Utility.Identity`2.Instance" />
    <member name="M:Nemerle.Utility.Identity`2.apply(`0)" />
    <member name="T:Nemerle.Builtins.Array1`1" />
    <member name="T:Nemerle.Builtins.Array2`1" />
    <member name="T:Nemerle.Builtins.Array3`1" />
    <member name="T:Nemerle.Builtins.Array4`1" />
    <member name="T:Nemerle.Builtins.Array5`1" />
    <member name="T:Nemerle.Builtins.Array6`1" />
    <member name="T:Nemerle.Builtins.Array7`1" />
    <member name="T:Nemerle.Builtins.Array8`1" />
    <member name="T:Nemerle.Builtins.Array9`1" />
    <member name="T:Nemerle.Builtins.Array10`1" />
    <member name="T:Nemerle.Builtins.Function`1" />
    <member name="M:Nemerle.Builtins.Function`1.#ctor" />
    <member name="M:Nemerle.Builtins.Function`1.apply" />
    <member name="M:Nemerle.Builtins.Function`1.apply(System.Object)" />
    <member name="T:Nemerle.Builtins.FunctionVoid" />
    <member name="M:Nemerle.Builtins.FunctionVoid.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid.apply_void" />
    <member name="M:Nemerle.Builtins.FunctionVoid.apply" />
    <member name="T:Nemerle.Builtins.Function`2" />
    <member name="M:Nemerle.Builtins.Function`2.#ctor" />
    <member name="M:Nemerle.Builtins.Function`2.op_RightShift``1(Nemerle.Builtins.Function{`0,``0},Nemerle.Builtins.Function{``0,`1})" />
    <member name="M:Nemerle.Builtins.Function`2.op_RightShift``1(Nemerle.Builtins.Function{``0},Nemerle.Builtins.Function{``0,`1})" />
    <member name="M:Nemerle.Builtins.Function`2.op_LeftShift``1(Nemerle.Builtins.Function{``0,`1},Nemerle.Builtins.Function{`0,``0})" />
    <member name="M:Nemerle.Builtins.Function`2.op_LeftShift``1(Nemerle.Builtins.Function{``0,`1},Nemerle.Builtins.Function{``0})" />
    <member name="M:Nemerle.Builtins.Function`2.|&gt;(`0,Nemerle.Builtins.Function{`0,`1})" />
    <member name="M:Nemerle.Builtins.Function`2.|&gt;(`0,Nemerle.Builtins.FunctionVoid{`0})" />
    <member name="M:Nemerle.Builtins.Function`2.&lt;|(Nemerle.Builtins.Function{`0,`1},`0)" />
    <member name="M:Nemerle.Builtins.Function`2.&lt;|(Nemerle.Builtins.FunctionVoid{`0},`0)" />
    <member name="M:Nemerle.Builtins.Function`2.apply(`0)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`1" />
    <member name="M:Nemerle.Builtins.FunctionVoid`1.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`1.apply_void(`0)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`1.apply(`0)" />
    <member name="T:Nemerle.Builtins.Function`3" />
    <member name="M:Nemerle.Builtins.Function`3.#ctor" />
    <member name="M:Nemerle.Builtins.Function`3.apply(`0,`1)" />
    <member name="M:Nemerle.Builtins.Function`3.apply(Nemerle.Builtins.Tuple{`0,`1})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`3" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`3.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`3.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1},`2})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`3.apply(`0,`1)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`2" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`2.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`2.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`2.apply_void(`0,`1)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`2" />
    <member name="M:Nemerle.Builtins.FunctionVoid`2.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`2.apply_void(`0,`1)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`2.apply_void(Nemerle.Builtins.Tuple{`0,`1})" />
    <member name="T:Nemerle.Builtins.Tuple`2" />
    <member name="M:Nemerle.Builtins.Tuple`2.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`2.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`2.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`2.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`2.Field1" />
    <member name="M:Nemerle.Builtins.Tuple`2.#ctor(`0,`1)" />
    <member name="T:Nemerle.Builtins.Function`4" />
    <member name="M:Nemerle.Builtins.Function`4.#ctor" />
    <member name="M:Nemerle.Builtins.Function`4.apply(`0,`1,`2)" />
    <member name="M:Nemerle.Builtins.Function`4.apply(Nemerle.Builtins.Tuple{`0,`1,`2})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`4" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`4.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`4.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2},`3})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`4.apply(`0,`1,`2)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`3" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`3.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`3.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`3.apply_void(`0,`1,`2)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`3" />
    <member name="M:Nemerle.Builtins.FunctionVoid`3.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`3.apply_void(`0,`1,`2)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`3.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2})" />
    <member name="T:Nemerle.Builtins.Tuple`3" />
    <member name="M:Nemerle.Builtins.Tuple`3.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`3.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`3.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`3.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`3.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`3.Field2" />
    <member name="M:Nemerle.Builtins.Tuple`3.#ctor(`0,`1,`2)" />
    <member name="T:Nemerle.Builtins.Function`5" />
    <member name="M:Nemerle.Builtins.Function`5.#ctor" />
    <member name="M:Nemerle.Builtins.Function`5.apply(`0,`1,`2,`3)" />
    <member name="M:Nemerle.Builtins.Function`5.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`5" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`5.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`5.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3},`4})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`5.apply(`0,`1,`2,`3)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`4" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`4.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`4.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`4.apply_void(`0,`1,`2,`3)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`4" />
    <member name="M:Nemerle.Builtins.FunctionVoid`4.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`4.apply_void(`0,`1,`2,`3)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`4.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3})" />
    <member name="T:Nemerle.Builtins.Tuple`4" />
    <member name="M:Nemerle.Builtins.Tuple`4.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`4.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`4.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`4.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`4.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`4.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`4.Field3" />
    <member name="M:Nemerle.Builtins.Tuple`4.#ctor(`0,`1,`2,`3)" />
    <member name="T:Nemerle.Builtins.Function`6" />
    <member name="M:Nemerle.Builtins.Function`6.#ctor" />
    <member name="M:Nemerle.Builtins.Function`6.apply(`0,`1,`2,`3,`4)" />
    <member name="M:Nemerle.Builtins.Function`6.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`6" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`6.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`6.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4},`5})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`6.apply(`0,`1,`2,`3,`4)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`5" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`5.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`5.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`5.apply_void(`0,`1,`2,`3,`4)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`5" />
    <member name="M:Nemerle.Builtins.FunctionVoid`5.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`5.apply_void(`0,`1,`2,`3,`4)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`5.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4})" />
    <member name="T:Nemerle.Builtins.Tuple`5" />
    <member name="M:Nemerle.Builtins.Tuple`5.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`5.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`5.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`5.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`5.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`5.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`5.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`5.Field4" />
    <member name="M:Nemerle.Builtins.Tuple`5.#ctor(`0,`1,`2,`3,`4)" />
    <member name="T:Nemerle.Builtins.Function`7" />
    <member name="M:Nemerle.Builtins.Function`7.#ctor" />
    <member name="M:Nemerle.Builtins.Function`7.apply(`0,`1,`2,`3,`4,`5)" />
    <member name="M:Nemerle.Builtins.Function`7.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`7" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`7.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`7.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5},`6})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`7.apply(`0,`1,`2,`3,`4,`5)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`6" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`6.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`6.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`6.apply_void(`0,`1,`2,`3,`4,`5)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`6" />
    <member name="M:Nemerle.Builtins.FunctionVoid`6.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`6.apply_void(`0,`1,`2,`3,`4,`5)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`6.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5})" />
    <member name="T:Nemerle.Builtins.Tuple`6" />
    <member name="M:Nemerle.Builtins.Tuple`6.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`6.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`6.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`6.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`6.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`6.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`6.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`6.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`6.Field5" />
    <member name="M:Nemerle.Builtins.Tuple`6.#ctor(`0,`1,`2,`3,`4,`5)" />
    <member name="T:Nemerle.Builtins.Function`8" />
    <member name="M:Nemerle.Builtins.Function`8.#ctor" />
    <member name="M:Nemerle.Builtins.Function`8.apply(`0,`1,`2,`3,`4,`5,`6)" />
    <member name="M:Nemerle.Builtins.Function`8.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`8" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`8.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`8.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6},`7})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`8.apply(`0,`1,`2,`3,`4,`5,`6)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`7" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`7.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`7.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`7.apply_void(`0,`1,`2,`3,`4,`5,`6)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`7" />
    <member name="M:Nemerle.Builtins.FunctionVoid`7.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`7.apply_void(`0,`1,`2,`3,`4,`5,`6)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`7.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6})" />
    <member name="T:Nemerle.Builtins.Tuple`7" />
    <member name="M:Nemerle.Builtins.Tuple`7.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`7.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`7.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`7.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`7.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`7.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`7.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`7.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`7.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`7.Field6" />
    <member name="M:Nemerle.Builtins.Tuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)" />
    <member name="T:Nemerle.Builtins.Function`9" />
    <member name="M:Nemerle.Builtins.Function`9.#ctor" />
    <member name="M:Nemerle.Builtins.Function`9.apply(`0,`1,`2,`3,`4,`5,`6,`7)" />
    <member name="M:Nemerle.Builtins.Function`9.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`9" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`9.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`9.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7},`8})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`9.apply(`0,`1,`2,`3,`4,`5,`6,`7)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`8" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`8.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`8.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`8.apply_void(`0,`1,`2,`3,`4,`5,`6,`7)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`8" />
    <member name="M:Nemerle.Builtins.FunctionVoid`8.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`8.apply_void(`0,`1,`2,`3,`4,`5,`6,`7)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`8.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7})" />
    <member name="T:Nemerle.Builtins.Tuple`8" />
    <member name="M:Nemerle.Builtins.Tuple`8.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`8.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`8.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`8.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`8.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`8.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`8.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`8.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`8.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`8.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`8.Field7" />
    <member name="M:Nemerle.Builtins.Tuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)" />
    <member name="T:Nemerle.Builtins.Function`10" />
    <member name="M:Nemerle.Builtins.Function`10.#ctor" />
    <member name="M:Nemerle.Builtins.Function`10.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8)" />
    <member name="M:Nemerle.Builtins.Function`10.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`10" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`10.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`10.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8},`9})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`10.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`9" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`9.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`9.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`9.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`9" />
    <member name="M:Nemerle.Builtins.FunctionVoid`9.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`9.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`9.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8})" />
    <member name="T:Nemerle.Builtins.Tuple`9" />
    <member name="M:Nemerle.Builtins.Tuple`9.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`9.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`9.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`9.Field8" />
    <member name="M:Nemerle.Builtins.Tuple`9.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8)" />
    <member name="T:Nemerle.Builtins.Function`11" />
    <member name="M:Nemerle.Builtins.Function`11.#ctor" />
    <member name="M:Nemerle.Builtins.Function`11.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)" />
    <member name="M:Nemerle.Builtins.Function`11.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`11" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`11.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`11.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9},`10})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`11.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`10" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`10.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`10.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`10.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`10" />
    <member name="M:Nemerle.Builtins.FunctionVoid`10.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`10.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`10.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})" />
    <member name="T:Nemerle.Builtins.Tuple`10" />
    <member name="M:Nemerle.Builtins.Tuple`10.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`10.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`10.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`10.Field9" />
    <member name="M:Nemerle.Builtins.Tuple`10.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)" />
    <member name="T:Nemerle.Builtins.Function`12" />
    <member name="M:Nemerle.Builtins.Function`12.#ctor" />
    <member name="M:Nemerle.Builtins.Function`12.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10)" />
    <member name="M:Nemerle.Builtins.Function`12.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`12" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`12.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`12.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10},`11})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`12.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`11" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`11.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`11.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`11.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`11" />
    <member name="M:Nemerle.Builtins.FunctionVoid`11.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`11.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`11.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})" />
    <member name="T:Nemerle.Builtins.Tuple`11" />
    <member name="M:Nemerle.Builtins.Tuple`11.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`11.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`11.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`11.Field10" />
    <member name="M:Nemerle.Builtins.Tuple`11.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10)" />
    <member name="T:Nemerle.Builtins.Function`13" />
    <member name="M:Nemerle.Builtins.Function`13.#ctor" />
    <member name="M:Nemerle.Builtins.Function`13.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11)" />
    <member name="M:Nemerle.Builtins.Function`13.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`13" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`13.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`13.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11},`12})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`13.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`12" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`12.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`12.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`12.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`12" />
    <member name="M:Nemerle.Builtins.FunctionVoid`12.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`12.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`12.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})" />
    <member name="T:Nemerle.Builtins.Tuple`12" />
    <member name="M:Nemerle.Builtins.Tuple`12.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`12.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`12.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`12.Field11" />
    <member name="M:Nemerle.Builtins.Tuple`12.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11)" />
    <member name="T:Nemerle.Builtins.Function`14" />
    <member name="M:Nemerle.Builtins.Function`14.#ctor" />
    <member name="M:Nemerle.Builtins.Function`14.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12)" />
    <member name="M:Nemerle.Builtins.Function`14.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`14" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`14.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`14.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12},`13})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`14.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`13" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`13.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`13.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`13.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`13" />
    <member name="M:Nemerle.Builtins.FunctionVoid`13.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`13.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`13.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})" />
    <member name="T:Nemerle.Builtins.Tuple`13" />
    <member name="M:Nemerle.Builtins.Tuple`13.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`13.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`13.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field11" />
    <member name="F:Nemerle.Builtins.Tuple`13.Field12" />
    <member name="M:Nemerle.Builtins.Tuple`13.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12)" />
    <member name="T:Nemerle.Builtins.Function`15" />
    <member name="M:Nemerle.Builtins.Function`15.#ctor" />
    <member name="M:Nemerle.Builtins.Function`15.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13)" />
    <member name="M:Nemerle.Builtins.Function`15.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`15" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`15.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`15.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13},`14})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`15.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`14" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`14.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`14.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`14.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`14" />
    <member name="M:Nemerle.Builtins.FunctionVoid`14.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`14.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`14.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})" />
    <member name="T:Nemerle.Builtins.Tuple`14" />
    <member name="M:Nemerle.Builtins.Tuple`14.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`14.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`14.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field11" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field12" />
    <member name="F:Nemerle.Builtins.Tuple`14.Field13" />
    <member name="M:Nemerle.Builtins.Tuple`14.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13)" />
    <member name="T:Nemerle.Builtins.Function`16" />
    <member name="M:Nemerle.Builtins.Function`16.#ctor" />
    <member name="M:Nemerle.Builtins.Function`16.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14)" />
    <member name="M:Nemerle.Builtins.Function`16.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`16" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`16.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`16.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14},`15})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`16.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`15" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`15.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`15.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`15.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`15" />
    <member name="M:Nemerle.Builtins.FunctionVoid`15.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`15.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`15.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})" />
    <member name="T:Nemerle.Builtins.Tuple`15" />
    <member name="M:Nemerle.Builtins.Tuple`15.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`15.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`15.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field11" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field12" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field13" />
    <member name="F:Nemerle.Builtins.Tuple`15.Field14" />
    <member name="M:Nemerle.Builtins.Tuple`15.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14)" />
    <member name="T:Nemerle.Builtins.Function`17" />
    <member name="M:Nemerle.Builtins.Function`17.#ctor" />
    <member name="M:Nemerle.Builtins.Function`17.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15)" />
    <member name="M:Nemerle.Builtins.Function`17.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`17" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`17.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`17.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15},`16})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`17.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`16" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`16.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`16.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`16.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`16" />
    <member name="M:Nemerle.Builtins.FunctionVoid`16.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`16.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`16.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15})" />
    <member name="T:Nemerle.Builtins.Tuple`16" />
    <member name="M:Nemerle.Builtins.Tuple`16.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`16.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`16.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field11" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field12" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field13" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field14" />
    <member name="F:Nemerle.Builtins.Tuple`16.Field15" />
    <member name="M:Nemerle.Builtins.Tuple`16.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15)" />
    <member name="T:Nemerle.Builtins.Function`18" />
    <member name="M:Nemerle.Builtins.Function`18.#ctor" />
    <member name="M:Nemerle.Builtins.Function`18.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16)" />
    <member name="M:Nemerle.Builtins.Function`18.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`18" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`18.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`18.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16},`17})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`18.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`17" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`17.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`17.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`17.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`17" />
    <member name="M:Nemerle.Builtins.FunctionVoid`17.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`17.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`17.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16})" />
    <member name="T:Nemerle.Builtins.Tuple`17" />
    <member name="M:Nemerle.Builtins.Tuple`17.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`17.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`17.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field11" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field12" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field13" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field14" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field15" />
    <member name="F:Nemerle.Builtins.Tuple`17.Field16" />
    <member name="M:Nemerle.Builtins.Tuple`17.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16)" />
    <member name="T:Nemerle.Builtins.Function`19" />
    <member name="M:Nemerle.Builtins.Function`19.#ctor" />
    <member name="M:Nemerle.Builtins.Function`19.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17)" />
    <member name="M:Nemerle.Builtins.Function`19.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`19" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`19.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`19.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17},`18})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`19.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`18" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`18.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`18.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`18.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`18" />
    <member name="M:Nemerle.Builtins.FunctionVoid`18.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`18.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`18.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17})" />
    <member name="T:Nemerle.Builtins.Tuple`18" />
    <member name="M:Nemerle.Builtins.Tuple`18.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`18.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`18.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field11" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field12" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field13" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field14" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field15" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field16" />
    <member name="F:Nemerle.Builtins.Tuple`18.Field17" />
    <member name="M:Nemerle.Builtins.Tuple`18.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17)" />
    <member name="T:Nemerle.Builtins.Function`20" />
    <member name="M:Nemerle.Builtins.Function`20.#ctor" />
    <member name="M:Nemerle.Builtins.Function`20.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18)" />
    <member name="M:Nemerle.Builtins.Function`20.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`20" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`20.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`20.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18},`19})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`20.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`19" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`19.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`19.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`19.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`19" />
    <member name="M:Nemerle.Builtins.FunctionVoid`19.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`19.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`19.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18})" />
    <member name="T:Nemerle.Builtins.Tuple`19" />
    <member name="M:Nemerle.Builtins.Tuple`19.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`19.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`19.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field11" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field12" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field13" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field14" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field15" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field16" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field17" />
    <member name="F:Nemerle.Builtins.Tuple`19.Field18" />
    <member name="M:Nemerle.Builtins.Tuple`19.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18)" />
    <member name="T:Nemerle.Builtins.Function`21" />
    <member name="M:Nemerle.Builtins.Function`21.#ctor" />
    <member name="M:Nemerle.Builtins.Function`21.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19)" />
    <member name="M:Nemerle.Builtins.Function`21.apply(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})" />
    <member name="T:Nemerle.Builtins.FunctionFromTuple`21" />
    <member name="F:Nemerle.Builtins.FunctionFromTuple`21.fn" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`21.#ctor(Nemerle.Builtins.Function{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19},`20})" />
    <member name="M:Nemerle.Builtins.FunctionFromTuple`21.apply(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19)" />
    <member name="T:Nemerle.Builtins.FunctionVoidFromTuple`20" />
    <member name="F:Nemerle.Builtins.FunctionVoidFromTuple`20.fn" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`20.#ctor(Nemerle.Builtins.FunctionVoid{Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19}})" />
    <member name="M:Nemerle.Builtins.FunctionVoidFromTuple`20.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19)" />
    <member name="T:Nemerle.Builtins.FunctionVoid`20" />
    <member name="M:Nemerle.Builtins.FunctionVoid`20.#ctor" />
    <member name="M:Nemerle.Builtins.FunctionVoid`20.apply_void(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19)" />
    <member name="M:Nemerle.Builtins.FunctionVoid`20.apply_void(Nemerle.Builtins.Tuple{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19})" />
    <member name="T:Nemerle.Builtins.Tuple`20" />
    <member name="M:Nemerle.Builtins.Tuple`20.Equals(System.Object)" />
    <member name="M:Nemerle.Builtins.Tuple`20.ToString" />
    <member name="M:Nemerle.Builtins.Tuple`20.GetHashCode" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field0" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field1" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field2" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field3" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field4" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field5" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field6" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field7" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field8" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field9" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field10" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field11" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field12" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field13" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field14" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field15" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field16" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field17" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field18" />
    <member name="F:Nemerle.Builtins.Tuple`20.Field19" />
    <member name="M:Nemerle.Builtins.Tuple`20.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,`16,`17,`18,`19)" />
    <member name="T:Nemerle.LazyValue`1">
      <summary>
        <para>class representing a lazy value (delayed computation of some function)
 it is constructed using Nemerle.lazy(complex_code()) macro

</para>
      </summary>
    </member>
    <member name="F:Nemerle.LazyValue`1.val">
      <summary>
        <para>memoized value

</para>
      </summary>
    </member>
    <member name="F:Nemerle.LazyValue`1.computation">
      <summary>
        <para>function to obtain the value

</para>
      </summary>
    </member>
    <member name="M:Nemerle.LazyValue`1.#ctor(Nemerle.Builtins.Function{`0})">
      <summary>
        <para>Create lazy value with given computation function to create the value
 when needed

</para>
      </summary>
    </member>
    <member name="M:Nemerle.LazyValue`1.FromValue(`0)">
      <summary>
        <para>Create already initialized value

</para>
      </summary>
    </member>
    <member name="M:Nemerle.LazyValue`1.#ctor(`0,Nemerle.Builtins.Function{`0})">
      <summary>
        <para>Create lazy value with fully specified state

</para>
      </summary>
    </member>
    <member name="M:Nemerle.LazyValue`1.op_Implicit(Nemerle.LazyValue{`0})~`0" />
    <member name="M:Nemerle.LazyValue`1.op_Implicit(`0)~Nemerle.LazyValue{`0}" />
    <member name="M:Nemerle.LazyValue`1.ToString" />
    <member name="M:Nemerle.LazyValue`1.Equals(System.Object)" />
    <member name="M:Nemerle.LazyValue`1.GetHashCode" />
    <member name="M:Nemerle.LazyValue`1.get_Value" />
    <member name="P:Nemerle.LazyValue`1.Value">
      <summary>
        <para>Get the underlying value stored in lazy computation. Perform computation
 if it the value was not fethed before

</para>
      </summary> <remarks><para>This function is thread safe. Exceptions are rethrowed, but if one occurs during
 computation, then in future it will be always thrown when fetching value.

</para></remarks></member>
    <member name="T:Nemerle.DelayedValue`1">
      <summary>
        <para>result of asyncronous operation
If called Value calling thread is waiting for operation to compleate

</para>
      </summary>
    </member>
    <member name="F:Nemerle.DelayedValue`1.thread" />
    <member name="F:Nemerle.DelayedValue`1.val" />
    <member name="M:Nemerle.DelayedValue`1.#ctor(Nemerle.Builtins.Function{`0})" />
    <member name="M:Nemerle.DelayedValue`1.#ctor(System.String,Nemerle.Builtins.Function{`0})" />
    <member name="M:Nemerle.DelayedValue`1.op_Implicit(Nemerle.DelayedValue{`0})~`0" />
    <member name="M:Nemerle.DelayedValue`1.get_HasValue" />
    <member name="P:Nemerle.DelayedValue`1.HasValue" />
    <member name="M:Nemerle.DelayedValue`1.Join" />
    <member name="M:Nemerle.DelayedValue`1.Join(System.Int32)" />
    <member name="T:Nemerle.Collections.LinkedList`1">
      <summary>
        <para>Doubly linked mutable list.

</para>
      </summary>  <remarks><para>Insert and Remove operations on this list require constant time irrespective of whether it is
  a single item or another LinkedList object, that is added.

</para></remarks></member>
    <member name="M:Nemerle.Collections.LinkedList`1.#ctor" />
    <member name="M:Nemerle.Collections.LinkedList`1.#ctor(Nemerle.Core.list{`0})">
      <summary>
        <para>Constructor initiliasing object with contents of a Nemerle list.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.concat_helper(System.String,System.Text.StringBuilder)" />
    <member name="M:Nemerle.Collections.LinkedList`1.ToString">
      <summary>
        <para>Returns string representing contents of the list.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.ToString(System.String)">
      <summary>
        <para>Constructs string out of list contents using given argument as a separator.
 </para>
      </summary>
      <param name="separator">
        <para>String to use a separator - it will be put between each
  two items of the list.</para>
      </param>

</member>
    <member name="M:Nemerle.Collections.LinkedList`1.Equals(Nemerle.Collections.LinkedList{`0})">
      <summary>
        <para>Compares two lists item by item using Equals method of contained objects.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Reverse">
      <summary>
        <para>Reverses elements of the list. Complexity is O(n).
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Prepend(`0)">
      <summary>
        <para>Adds item at the beginning of the list.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Prepend(Nemerle.Collections.LinkedList{`0})">
      <summary>
        <para>Add given list at the beginning. The source will be cleared.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Append(`0)">
      <summary>
        <para>Append item to the list.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Append(Nemerle.Collections.LinkedList{`0})">
      <summary>
        <para>Append another list to an end. The source list will be cleared.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.get_IsEmpty" />
    <member name="P:Nemerle.Collections.LinkedList`1.IsEmpty">
      <summary>
        <para>Returns true, if the list is empty.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Add(`0)">
      <summary>
        <para>Adds item at the beginning of the list.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.First">
      <summary>
        <para>Returns first element of the list as an option.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Clone">
      <summary>
        <para>Returns shallow copy of the list.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Fold``1(Nemerle.Builtins.Function{`0,``0,``0},``0)">
      <summary>
        <para>Folds the list using the specified fold function and an initial
 value. Elements are folded in order of appearance.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Map``1(Nemerle.Builtins.Function{`0,``0})">
      <summary>
        <para>Creates new list with elements from the original with supplied
 function applied.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Iter(Nemerle.Builtins.FunctionVoid{`0})">
      <summary>
        <para>Calls the supplied function for all the elements of the list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.ForAll(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Checks if all the members of this list satisfy the supplied
 predicate.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Exists(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Checks if there exists a member of list that satisfies
 the supplied condition.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Filter(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Filters the list removing all elements that do not satisfy
 the supplied predicate.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Partition(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Partitions list into two lists: elements that satisfy
 and elements that do not satisfy the supplied predicate.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Remove(`0)">
      <summary>
        <para>Remove all occurences of item from list
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.LinkedList`1.Equals(System.Object)">
      <summary>
        <para>Compares two lists item by item using Equals method of contained objects.
</para>
      </summary>
    </member>
    <member name="T:Nemerle.Core.list`1">
      <summary>
        <para>The core datastructure allowing easy manipulating of small
      and medium sized collections of elements.

</para>
      </summary>      <remarks><para>It has a builtin syntax [] for empty list, x :: xs for creating list
      from head element and tail.

</para></remarks></member>
    <member name="M:Nemerle.Core.list`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
        <para>Creates enumerator for elements of list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.System#Collections#Generic#IEnumerable#GetEnumerator" />
    <member name="M:Nemerle.Core.list`1.#ctor">
      <summary>
        <para>The core datastructure allowing easy manipulating of small
      and medium sized collections of elements.

</para>
      </summary>      <remarks><para>It has a builtin syntax [] for empty list, x :: xs for creating list
      from head element and tail.

</para></remarks></member>
    <member name="M:Nemerle.Core.list`1.ToString" />
    <member name="M:Nemerle.Core.list`1.ToString(System.String)" />
    <member name="M:Nemerle.Core.list`1.get_CovariantTail" />
    <member name="P:Nemerle.Core.list`1.CovariantTail" />
    <member name="M:Nemerle.Core.list`1.op_Equality(Nemerle.Core.list{`0},Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Core.list`1.op_Inequality(Nemerle.Core.list{`0},Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Core.list`1.Equals(Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Core.list`1.Equals``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{`0,``0,System.Boolean})" />
    <member name="M:Nemerle.Core.list`1.GetHashCode" />
    <member name="M:Nemerle.Core.list`1.get_Length" />
    <member name="P:Nemerle.Core.list`1.Length" />
    <member name="M:Nemerle.Core.list`1.GetElementType" />
    <member name="M:Nemerle.Core.list`1.get_IsEmpty" />
    <member name="P:Nemerle.Core.list`1.IsEmpty">
      <summary>
        <para>Returns true if the given list is empty.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.get_Head" />
    <member name="P:Nemerle.Core.list`1.Head">
      <summary>
        <para>Returns head (first element) of list.
 Given empty list throws System.ArgumentException.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.get_Tail" />
    <member name="P:Nemerle.Core.list`1.Tail">
      <summary>
        <para>Returns tail (all elements except the first one) of list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.get_Last" />
    <member name="P:Nemerle.Core.list`1.Last">
      <summary>
        <para>Returns last element of list.
 Given empty list throws InvalidArgument exception.
 Works in time O(n) and memory O(1).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.GetEnumerator">
      <summary>
        <para>Creates enumerator for elements of list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.op_Addition(Nemerle.Core.list{`0},Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Core.list`1.FirstN(System.Int32)">
      <summary>
        <para>Returns first n elements of the list.
 Works in time and memory O(n).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.ChopFirstN(System.Int32)">
      <summary>
        <para>Return [this] without first [n] elements. Works in time O(n)
        and constant memory. Throws ArgumentException when called on
        too short list.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.LastN(System.Int32)" />
    <member name="M:Nemerle.Core.list`1.Nth(System.Int32)" />
    <member name="M:Nemerle.Core.list`1.Reverse">
      <summary>
        <para>Returns reversed list, i.e. [1,2,3].Reverse().Equals ([3,2,1]).
 Works in time and memory O(n).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.Append(Nemerle.Core.list{`0})">
      <summary>
        <para>Returns list made from appending list y at end of list x.
 Original list are not modified.
 Works in time and memory O(length(x)).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.RevAppend(Nemerle.Core.list{`0})">
      <summary>
        <para>Equivalent to Reverse().Append(y), but faster.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.Remove(`0)">
      <summary>
        <para>Returns current list without elements equal to x.
 Equals method is used to compare elements.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.DivideLast">
      <summary>
        <para>Returns a list without its last element and the list's last element

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.Iter(Nemerle.Builtins.FunctionVoid{`0})" />
    <member name="M:Nemerle.Core.list`1.IterI(System.Int32,Nemerle.Builtins.FunctionVoid{System.Int32,`0})" />
    <member name="M:Nemerle.Core.list`1.Map``1(Nemerle.Builtins.Function{`0,``0})" />
    <member name="M:Nemerle.Core.list`1.Zip``1(Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Core.list`1.MapFiltered``1(Nemerle.Builtins.Function{`0,System.Boolean},Nemerle.Builtins.Function{`0,``0})" />
    <member name="M:Nemerle.Core.list`1.RevMap``1(Nemerle.Builtins.Function{`0,``0})" />
    <member name="M:Nemerle.Core.list`1.FoldLeft``1(``0,Nemerle.Builtins.Function{`0,``0,``0})" />
    <member name="M:Nemerle.Core.list`1.FoldRight``1(``0,Nemerle.Builtins.Function{`0,``0,``0})" />
    <member name="M:Nemerle.Core.list`1.Group(Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="M:Nemerle.Core.list`1.ForAll(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Returns 'true' if all of the 'l' list's elements satisfy
 the condition 'f'.

</para>
      </summary> <remarks><para>Example of use:

</para>   <para>NList.ForAll ([2, 4, 6, 8], fun (x) { x % 2 == 0 })

</para> <para>evaluates to 'true' as all the list's elements are even.

</para></remarks></member>
    <member name="M:Nemerle.Core.list`1.ForAll2``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{`0,``0,System.Boolean})" />
    <member name="M:Nemerle.Core.list`1.Exists(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Returns 'true' if at least one of the 'l' list's elements
 satisfies the condition 'f'.

</para>
      </summary> <remarks><para>Example of use:

</para>   <para>NList.Exists (["a", "b", "abc", "d", "e"], fun (x) { x.Length &gt; 2 })

</para> <para>evaluates to 'true' as there is one string of length 3 on the list.

</para></remarks></member>
    <member name="M:Nemerle.Core.list`1.Contains(`0)">
      <summary>
        <para>NList membership test, using the `Equals' method to compare objects.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.Find(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Finds the first elements for which a predicate is true.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.FindWithDefault(`0,Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Finds the first elements for which a predicate is true.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.FilteredLength(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Returns the number of elements for which a predicate is true.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.Filter(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Removes elements for which predicate is false

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.RevFilter(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Removes elements for which predicate is false.
 The resulting list is reversed (operation is faster this way).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.RevFilterWhenNeeded(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Return list, reversed or not, with elements not fulfilling [f] removed.
 Avoid allocation if possible.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.FindAll(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>This is an alias for ``Filter''

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.Partition(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Partitions a list into two sublists according to a predicate.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.Rev">
      <summary>
        <para>Returns reversed list, i.e. Rev([1,2,3]) = [3,2,1].
 Works in time and memory O(n).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.Sort(Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="M:Nemerle.Core.list`1.IsOrdered``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,``0,System.Boolean})" />
    <member name="M:Nemerle.Core.list`1.IsOrdered``1(Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Core.list`1.RemoveDuplicates" />
    <member name="M:Nemerle.Core.list`1.get_NToArray" />
    <member name="P:Nemerle.Core.list`1.NToArray" />
    <member name="M:Nemerle.Core.list`1.ToArray" />
    <member name="M:Nemerle.Core.list`1.CopyTo(`0[],System.Int32)">
      <summary>
        <para>Copies first [len] elements from current list to specified array beginning with index 0

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.CopyTo(`0[])">
      <summary>
        <para>Copies all elements from current list to specified array beginning with index 0

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.list`1.MapToArray``1(Nemerle.Builtins.Function{`0,``0})" />
    <member name="M:Nemerle.Core.list`1.Flatten``1(Nemerle.Builtins.FunctionVoid{`0,System.Collections.Generic.List{``0}})" />
    <member name="M:Nemerle.Core.list`1.Flatten``1(Nemerle.Builtins.Function{`0,System.Collections.Generic.IEnumerable{``0}})" />
    <member name="M:Nemerle.Core.list`1.Equals(System.Object)" />
    <member name="M:Nemerle.Core.list`1._N_GetVariantCode">
      <summary>
        <para>The core datastructure allowing easy manipulating of small
      and medium sized collections of elements.

</para>
      </summary>      <remarks><para>It has a builtin syntax [] for empty list, x :: xs for creating list
      from head element and tail.

</para></remarks></member>
    <member name="M:Nemerle.Core.list`1._N_GetVariantCodeSafe(Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Core.list`1._N_GetVariantCodeObject(System.Object)" />
    <member name="T:Nemerle.Core.list`1.Cons`0" />
    <member name="T:Nemerle.Core.list`1.Nil`0" />
    <member name="T:Nemerle.Collections.NList" />
    <member name="M:Nemerle.Collections.NList._N_extend_17283``1(Nemerle.Collections.NList._N_closure_17269{``0},``0,Nemerle.Core.list{Nemerle.Core.list{Nemerle.Core.list{``0}}},Nemerle.Core.list{Nemerle.Core.list{Nemerle.Core.list{``0}}})" />
    <member name="M:Nemerle.Collections.NList._N_push_17274``1(``0,Nemerle.Core.list{Nemerle.Core.list{``0}},Nemerle.Core.list{Nemerle.Core.list{``0}},Nemerle.Core.list{Nemerle.Core.list{Nemerle.Core.list{``0}}})" />
    <member name="M:Nemerle.Collections.NList._N_extend_17178``1(Nemerle.Core.list{``0},Nemerle.Core.list{``0},Nemerle.Core.list{Nemerle.Core.list{``0}})" />
    <member name="M:Nemerle.Collections.NList._N_walk_16968``1(Nemerle.Collections.NList._N_closure_16960{``0},Nemerle.Core.list{``0},Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Collections.NList.Equals``1(Nemerle.Core.list{``0},Nemerle.Core.list{``0})">
      <summary>
        <para>Tests equality of two lists.  Uses Equal method of
 objects to test wether they are the same.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Compare``1(Nemerle.Core.list{``0},Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,``0,System.Int32})">
      <summary>
        <para>Compare two lists lexicographically over the order defined on
 their elements with function [cmp].  Returns [-1] if [l1] is smaller,
 [1] if [l2] is smaller, and [0] if they equal.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Compare``1(Nemerle.Core.list{``0},Nemerle.Core.list{``0})">
      <summary>
        <para>Compare two lists lexicographically over the order defined on
 their elements.  Returns [-1] if [l1] is smaller, [1] if [l2]
 is smaller, and [0] if they equal.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.RemoveDuplicates``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Returns [l] with duplicates removed with respect to Equals method
 It is assumed that equal elements of [l] are next to each other,
 or that the list is sorted.

</para>
      </summary> <remarks><para>Example:

</para> <para>def result = RemoveDuplicates ([1, 2, 2, 3, 4, 4]);
     // result = [1, 2, 3, 4]

</para></remarks></member>
    <member name="M:Nemerle.Collections.NList.FromArray``1(``0[])">
      <summary>
        <para>Converts an array into a list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.ToListRev``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NList.ToListRev``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NList.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NList.AsList``1(System.Collections.Generic.IList{``0})" />
    <member name="M:Nemerle.Collections.NList.ToList``1(System.Collections.Generic.IList{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NList.ToList``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NList.IsEmpty``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Returns true if the given list is empty of null.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Length``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Returns length of given list. Time O(n), Mem O(1).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Head``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Returns head (first element) of list.
 Given empty list throws System.ArgumentException.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Hd``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Alias for l.Head.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Tail``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Returns tail (all elements except first one) of list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Tl``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Alias for Tail(l).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Nth``1(Nemerle.Core.list{``0},System.Int32)">
      <summary>
        <para>Returns n-th element of list, where 0-th is head.
 Throws InvalidArgument exception when given too short list.
 Works in time O(n) and memory O(1).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Last``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Returns last element of list.
 Given empty list throws InvalidArgument exception.
 Works in time O(n) and memory O(1).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Rev``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Returns reversed list, i.e. Rev([1, 2, 3]) = [3, 2, 1].
 Works in time and memory O(n).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Append``1(Nemerle.Core.list{``0},Nemerle.Core.list{``0})">
      <summary>
        <para>Returns list made from appending list y at end of list x.
 Original list are not modified.
 Works in time and memory O(length(x)).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.RevAppend``1(Nemerle.Core.list{``0},Nemerle.Core.list{``0})">
      <summary>
        <para>Equivalent to Append(Rev(x),y).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Concat``1(Nemerle.Core.list{Nemerle.Core.list{``0}})">
      <summary>
        <para>Makes list one level more flat, i.e. Concat([[1, 2], [3, 4]]) = [1, 2, 3, 4].
 Does not work deeper, i.e. Concat([[[1, 2], [3]], [[4]]]) = [[1, 2], [3], [4]].

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.ConcatRev``1(Nemerle.Core.list{Nemerle.Core.list{``0}})">
      <summary>
        <para>Equivalent to Concat(Rev(l))

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Flatten``1(Nemerle.Core.list{Nemerle.Core.list{``0}})">
      <summary>
        <para>Alias for Concat(l).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Remove``1(Nemerle.Core.list{``0},``0)">
      <summary>
        <para>Returns list l without elements equal to x.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.DivideLast``1(Nemerle.Core.list{``0})">
      <summary>
        <para>Returns a list without its last element and the list's last element

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Iter``1(Nemerle.Core.list{``0},Nemerle.Builtins.FunctionVoid{``0})" />
    <member name="M:Nemerle.Collections.NList.MapFiltered``2(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NList.Map``2(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NList.RevMap``2(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NList.RevMapFiltered``2(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NList.FoldLeft``2(Nemerle.Core.list{``0},``1,Nemerle.Builtins.Function{``0,``1,``1})" />
    <member name="M:Nemerle.Collections.NList.FoldRight``2(Nemerle.Core.list{``0},``1,Nemerle.Builtins.Function{``0,``1,``1})" />
    <member name="M:Nemerle.Collections.NList.MapFromArray``2(``0[],Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NList.Iter2``2(Nemerle.Core.list{``0},Nemerle.Core.list{``1},Nemerle.Builtins.FunctionVoid{``0,``1})" />
    <member name="M:Nemerle.Collections.NList.Map2``3(Nemerle.Core.list{``0},Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NList.RevMap2``3(Nemerle.Core.list{``0},Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NList.FoldLeft2``3(Nemerle.Core.list{``0},Nemerle.Core.list{``1},``2,Nemerle.Builtins.Function{``0,``1,``2,``2})" />
    <member name="M:Nemerle.Collections.NList.FoldRight2``3(Nemerle.Core.list{``0},Nemerle.Core.list{``1},``2,Nemerle.Builtins.Function{``0,``1,``2,``2})" />
    <member name="M:Nemerle.Collections.NList.ForAll``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Returns 'true' if all of the 'l' list's elements satisfy
 the condition 'f'.

</para>
      </summary> <remarks><para>Example of use:

</para>   <para>NList.ForAll ([2, 4, 6, 8], fun (x) { x % 2 == 0 })

</para> <para>evaluates to 'true' as all the list's elements are even.

</para></remarks></member>
    <member name="M:Nemerle.Collections.NList.Equals``2(Nemerle.Core.list{``0},Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NList.Exists``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Returns 'true' if at least one of the 'l' list's elements
 satisfies the condition 'f'.

</para>
      </summary> <remarks><para>Example of use:

</para>   <para>NList.Exists (["a", "b", "abc", "d", "e"], fun (x) { x.Length &gt; 2 })

</para> <para>evaluates to 'true' as there is one string of length 3 on the list.

</para></remarks></member>
    <member name="M:Nemerle.Collections.NList.ForAll2``2(Nemerle.Core.list{``0},Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NList.Exists2``2(Nemerle.Core.list{``0},Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NList.Member``1(Nemerle.Core.list{``0},``0)">
      <summary>
        <para>NList membership test, using the `Equals' method to compare objects.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.ContainsRef``1(Nemerle.Core.list{``0},``0)">
      <summary>
        <para>NList membership test, using the reference equality.

</para>
      </summary> <remarks><para>Returns true if and only if list [Collection] contains object with reference
 equal to [Obj] object

</para></remarks></member>
    <member name="M:Nemerle.Collections.NList.Contains``1(Nemerle.Core.list{``0},``0)">
      <summary>
        <para>NList membership test, using the `Equals' method to compare objects.

</para>
      </summary> <remarks><para>This is an alias for the `Member' method.

</para></remarks></member>
    <member name="M:Nemerle.Collections.NList.Find``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Finds the first elements for which a predicate is true.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.FilteredLength``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Returns the number of elements for which a predicate is true.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Filter``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Removes elements for which predicate is false

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.RevFilter``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Removes elements for which predicate is false.
 The resulting list is reversed (operation is faster this way).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.FindAll``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>This is an alias for ``Filter''

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Partition``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Partitions a list into two sublists according to a predicate.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Group``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,``0,System.Int32})">
      <summary>
        <para>Groups equal element into lists

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Assoc``2(Nemerle.Core.list{Nemerle.Builtins.Tuple{``0,``1}},``0)" />
    <member name="M:Nemerle.Collections.NList.MemAssoc``2(Nemerle.Core.list{Nemerle.Builtins.Tuple{``0,``1}},``0)" />
    <member name="M:Nemerle.Collections.NList.RemoveAssoc``2(Nemerle.Core.list{Nemerle.Builtins.Tuple{``0,``1}},``0)" />
    <member name="M:Nemerle.Collections.NList.Split``2(Nemerle.Core.list{Nemerle.Builtins.Tuple{``0,``1}})" />
    <member name="M:Nemerle.Collections.NList.Combine``2(Nemerle.Core.list{``0},Nemerle.Core.list{``1})" />
    <member name="M:Nemerle.Collections.NList.MergeSort``1(Nemerle.Builtins.Function{``0,``0,System.Int32},Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Collections.NList.Sort``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,``0,System.Int32})" />
    <member name="M:Nemerle.Collections.NList.Copy``1(Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Collections.NList.Product``1(Nemerle.Core.list{``0},Nemerle.Core.list{Nemerle.Core.list{``0}})">
      <summary>
        <para>Assumes that [prod] is a product of n - 1 lists, and extends
 product by adding every possible element of [x] to these lists.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Product``1(Nemerle.Core.list{Nemerle.Core.list{``0}})">
      <summary>
        <para>Returns a product of lists stored in list [list].  Elements of
 result are lists of the same length = NList.Length (list).

</para>
      </summary> <remarks><para>E.g.:
    Product ([[1, 2], [3, 4, 5]]) =
        [[1, 3],
         [1, 4],
         [1, 5],
         [2, 3],
         [2, 4],
         [2, 5]]

</para>    <para>Product ([[1, 2], [3, 4, 5], []]) = []

</para></remarks></member>
    <member name="M:Nemerle.Collections.NList.SubsetsPartitions``1(Nemerle.Core.list{``0},System.Int32)">
      <summary>
        <para>Return a list of all possible partitions of [set] into [count] subsets.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Singletons``1(Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Collections.NList.SizeSubsets``1(Nemerle.Core.list{``0},System.Int32)">
      <summary>
        <para>Return list of all possible [n]-element subsets of set [list].

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Repeat``1(``0,System.Int32)">
      <summary>
        <para>Return list consisting of [count] references to [elem].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Range(System.Int32)">
      <summary>
        <para>Return a list of integers from 0 to [end], excluding [end].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Range(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Return a list of values incremented by [step], beginning
 with [beg], up/down to [end], excluding [end] itself.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Range(System.Char)">
      <summary>
        <para>Return a list of characters from 'a' to [end], excluding [end].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NList.Range(System.Char,System.Char,System.Int32)">
      <summary>
        <para>Return a list of characters, which values are incremented by [step],
 beginning with [beg], up/down to [end], excluding [end] itself.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Collections.ListEnumState">
      <summary>
        <para>The state of a list enumerator.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Collections.ListEnumState.value__" />
    <member name="F:Nemerle.Collections.ListEnumState.BeforeFirst" />
    <member name="F:Nemerle.Collections.ListEnumState.Correct" />
    <member name="F:Nemerle.Collections.ListEnumState.AfterLast" />
    <member name="T:Nemerle.Collections.ListEnumerator`1">
      <summary>
        <para>An enumerator for lists.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ListEnumerator`1.System#Collections#IEnumerator#get_Current" />
    <member name="M:Nemerle.Collections.ListEnumerator`1._N_doMove_17517(Nemerle.Collections.ListEnumerator._N_closure_17509{`0})" />
    <member name="M:Nemerle.Collections.ListEnumerator`1.#ctor(Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Collections.ListEnumerator`1.Dispose" />
    <member name="M:Nemerle.Collections.ListEnumerator`1.MoveNext">
      <summary>
        <para>-- PUBLIC METHODS ----------------------------------------------------

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.ListEnumerator`1.Reset" />
    <member name="M:Nemerle.Collections.ListEnumerator`1.get_Current" />
    <member name="P:Nemerle.Collections.ListEnumerator`1.Current" />
    <member name="F:Nemerle.Collections.ListEnumerator`1.m_list" />
    <member name="F:Nemerle.Collections.ListEnumerator`1.m_current" />
    <member name="F:Nemerle.Collections.ListEnumerator`1.m_rest" />
    <member name="F:Nemerle.Collections.ListEnumerator`1.m_state" />
    <member name="T:Nemerle.MacroTargets" />
    <member name="T:Nemerle.MacroPhase" />
    <member name="F:Nemerle.MacroPhase.value__" />
    <member name="F:Nemerle.MacroPhase.None" />
    <member name="F:Nemerle.MacroPhase.BeforeInheritance" />
    <member name="F:Nemerle.MacroPhase.BeforeTypedMembers" />
    <member name="F:Nemerle.MacroPhase.WithTypedMembers" />
    <member name="T:Nemerle.MacroUsageAttribute" />
    <member name="F:Nemerle.MacroUsageAttribute.valid_on" />
    <member name="F:Nemerle.MacroUsageAttribute.allow_multiple" />
    <member name="F:Nemerle.MacroUsageAttribute.inherited" />
    <member name="F:Nemerle.MacroUsageAttribute.phase" />
    <member name="M:Nemerle.MacroUsageAttribute.#ctor(Nemerle.MacroPhase,System.AttributeTargets)" />
    <member name="M:Nemerle.MacroUsageAttribute.get_AllowMultiple" />
    <member name="M:Nemerle.MacroUsageAttribute.set_AllowMultiple(System.Boolean)" />
    <member name="P:Nemerle.MacroUsageAttribute.AllowMultiple" />
    <member name="M:Nemerle.MacroUsageAttribute.get_Inherited" />
    <member name="M:Nemerle.MacroUsageAttribute.set_Inherited(System.Boolean)" />
    <member name="P:Nemerle.MacroUsageAttribute.Inherited" />
    <member name="M:Nemerle.MacroUsageAttribute.get_ValidOn" />
    <member name="P:Nemerle.MacroUsageAttribute.ValidOn" />
    <member name="T:Nemerle.TailRecursionTransparentAttribute" />
    <member name="F:Nemerle.TailRecursionTransparentAttribute.is_transparent" />
    <member name="M:Nemerle.TailRecursionTransparentAttribute.#ctor(System.Boolean)" />
    <member name="M:Nemerle.TailRecursionTransparentAttribute.get_IsTransparent" />
    <member name="P:Nemerle.TailRecursionTransparentAttribute.IsTransparent" />
    <member name="T:Nemerle.Collections.Map`2" />
    <member name="M:Nemerle.Collections.Map`2.System#Collections#IEnumerable#GetEnumerator" />
    <member name="F:Nemerle.Collections.Map`2._tree" />
    <member name="F:Nemerle.Collections.Map`2._cmp" />
    <member name="F:Nemerle.Collections.Map`2._size" />
    <member name="M:Nemerle.Collections.Map`2.MakeNodeComparer(Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="M:Nemerle.Collections.Map`2.DefaultComparer" />
    <member name="M:Nemerle.Collections.Map`2.#ctor" />
    <member name="M:Nemerle.Collections.Map`2.#ctor(Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="M:Nemerle.Collections.Map`2.#ctor(System.Collections.Generic.IEnumerable{Nemerle.Builtins.Tuple{`0,`1}})" />
    <member name="M:Nemerle.Collections.Map`2.#ctor(System.Collections.Generic.IEnumerable{Nemerle.Builtins.Tuple{`0,`1}},Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="M:Nemerle.Collections.Map`2.#ctor(System.Int32,Nemerle.Collections.TwoThreeTree.Node{Nemerle.Collections.Map.Node{`0,`1}},Nemerle.Builtins.Function{Nemerle.Collections.Map.Node{`0,`1},Nemerle.Collections.Map.Node{`0,`1},System.Int32},System.Collections.Generic.IEnumerable{Nemerle.Builtins.Tuple{`0,`1}})" />
    <member name="M:Nemerle.Collections.Map`2.#ctor(System.Int32,Nemerle.Collections.TwoThreeTree.Node{Nemerle.Collections.Map.Node{`0,`1}},Nemerle.Builtins.Function{Nemerle.Collections.Map.Node{`0,`1},Nemerle.Collections.Map.Node{`0,`1},System.Int32})" />
    <member name="M:Nemerle.Collections.Map`2.Contains(`0)" />
    <member name="M:Nemerle.Collections.Map`2.Clear" />
    <member name="M:Nemerle.Collections.Map`2.Add(`0,`1)" />
    <member name="M:Nemerle.Collections.Map`2.AddRange(System.Collections.Generic.IEnumerable{Nemerle.Builtins.Tuple{`0,`1}})" />
    <member name="M:Nemerle.Collections.Map`2.AddList(Nemerle.Core.list{Nemerle.Builtins.Tuple{`0,`1}})" />
    <member name="M:Nemerle.Collections.Map`2.Remove(`0)" />
    <member name="M:Nemerle.Collections.Map`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})" />
    <member name="M:Nemerle.Collections.Map`2.RemoveList(Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Collections.Map`2.Replace(`0,`1)" />
    <member name="M:Nemerle.Collections.Map`2.ReplaceRange(System.Collections.Generic.IEnumerable{Nemerle.Builtins.Tuple{`0,`1}})" />
    <member name="M:Nemerle.Collections.Map`2.ReplaceList(Nemerle.Core.list{Nemerle.Builtins.Tuple{`0,`1}})" />
    <member name="M:Nemerle.Collections.Map`2.Fold``1(``0,Nemerle.Builtins.Function{`0,`1,``0,``0})" />
    <member name="M:Nemerle.Collections.Map`2.FoldLeft``1(``0,Nemerle.Builtins.Function{`0,`1,``0,``0})" />
    <member name="M:Nemerle.Collections.Map`2.FoldRight``1(``0,Nemerle.Builtins.Function{`0,`1,``0,``0})" />
    <member name="M:Nemerle.Collections.Map`2.Iter(Nemerle.Builtins.FunctionVoid{`0,`1})" />
    <member name="M:Nemerle.Collections.Map`2.IterLeft(Nemerle.Builtins.FunctionVoid{`0,`1})" />
    <member name="M:Nemerle.Collections.Map`2.IterRight(Nemerle.Builtins.FunctionVoid{`0,`1})" />
    <member name="M:Nemerle.Collections.Map`2.Filter(Nemerle.Builtins.Function{`0,`1,System.Boolean})" />
    <member name="M:Nemerle.Collections.Map`2.Partition(Nemerle.Builtins.Function{`0,`1,System.Boolean})" />
    <member name="M:Nemerle.Collections.Map`2.ForAll(Nemerle.Builtins.Function{`0,`1,System.Boolean})" />
    <member name="M:Nemerle.Collections.Map`2.Exists(Nemerle.Builtins.Function{`0,`1,System.Boolean})" />
    <member name="M:Nemerle.Collections.Map`2.Find(`0)" />
    <member name="M:Nemerle.Collections.Map`2.Get(`0)" />
    <member name="M:Nemerle.Collections.Map`2.ToList" />
    <member name="M:Nemerle.Collections.Map`2.ToArray" />
    <member name="M:Nemerle.Collections.Map`2.MapToList``1(Nemerle.Builtins.Function{`0,`1,``0})" />
    <member name="M:Nemerle.Collections.Map`2.MapToArray``1(Nemerle.Builtins.Function{`0,`1,``0})" />
    <member name="M:Nemerle.Collections.Map`2.get_IsEmpty" />
    <member name="P:Nemerle.Collections.Map`2.IsEmpty" />
    <member name="M:Nemerle.Collections.Map`2.GetEnumerator" />
    <member name="M:Nemerle.Collections.Map`2.CopyTo(Nemerle.Builtins.Tuple{`0,`1}[],System.Int32)" />
    <member name="M:Nemerle.Collections.Map`2.get_IsReadOnly" />
    <member name="P:Nemerle.Collections.Map`2.IsReadOnly" />
    <member name="M:Nemerle.Collections.Map`2.get_Count" />
    <member name="P:Nemerle.Collections.Map`2.Count" />
    <member name="M:Nemerle.Collections.Map`2.ToString" />
    <member name="T:Nemerle.Collections.Map`2.Node`0" />
    <member name="T:Nemerle.Collections.Seq`1" />
    <member name="T:Nemerle.Collections.NCollectionsExtensions" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions._N_loop_21001``3(Nemerle.Collections.NCollectionsExtensions._N_closure_20991{``0,``1,``2},Nemerle.Core.list{``1},System.Int32,``2)" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions._N_loop_20967``3(Nemerle.Collections.NCollectionsExtensions._N_closure_20957{``0,``1,``2},Nemerle.Core.list{``0},System.Int32,``2)" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions._N_loop_20863``3(Nemerle.Collections.NCollectionsExtensions._N_closure_20853{``0,``1,``2},Nemerle.Core.list{``1},System.Int32)" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions._N_loop_20831``3(Nemerle.Collections.NCollectionsExtensions._N_closure_20821{``0,``1,``2},Nemerle.Core.list{``0},System.Int32)" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Grouping``3(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,Nemerle.Builtins.Tuple{``1,``2}})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Flatten``2(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ZipLazy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Map2Lazy``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Map2ToArray``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Map2ToArray``3(``0[],``1[],Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ZipToArray``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ZipToArray``2(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ZipToArray``2(``0[],``1[])" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ForAll2``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ForAll2``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ForAll2``2(``0[],``1[],Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.IsEmpty(System.Collections.ICollection)" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.IsEmpty``1(``0[])" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.IsEmpty``1(Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NLastN``1(``0[],System.Int32)" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NCount``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NLast``1(System.Collections.Generic.IList{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NLast``1(``0[])" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NLast``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NFirst``1(System.Collections.Generic.IList{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NFirst``1(``0[])" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NFirst``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapLazy``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>Convert a sequence of one type to sequence of another type.
 Convertion execute in lazy manner.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapLazyFiltered``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean},Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>Convert a sequence of one type to sequence of another type with filtration.
 Convertion execute in lazy manner.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapLazyFiltered``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,Nemerle.Builtins.Tuple{System.Boolean,``1}})">
      <summary>
        <para>Convert a sequence of one type to sequence of another type with filtration.
 Convertion execute in lazy manner.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FilterLazy``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Filter elements of sequence in lazy manner.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ExcludeLazy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Iter``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.FunctionVoid{``0})">
      <summary>
        <para>Iterate sequence and call action for each it elements.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FindIndex``1(``0[],Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FindIndex``1(System.Collections.Generic.IList{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FindIndex``1(System.Collections.Generic.List{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FoldLeft``2(System.Collections.Generic.IEnumerable{``1},``0,Nemerle.Builtins.Function{``1,``0,``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FoldRight``2(System.Collections.Generic.IEnumerable{``1},``0,Nemerle.Builtins.Function{``1,``0,``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Fold``2(System.Collections.Generic.IEnumerable{``1},``0,Nemerle.Builtins.Function{``1,``0,``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.BinarySearch``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,Nemerle.Builtins.Function{``0,System.Int32})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.BinarySearch``1(System.Collections.Generic.IList{``0},Nemerle.Builtins.Function{``0,System.Int32})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NToList``1(``0[])" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NToList``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NToArray``1(System.Collections.Generic.ICollection{``0})">
      <summary>
        <para>Convert collection to array.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NToArray``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
        <para>Convert sequence to array.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.UpCastToArray``2(System.Collections.Generic.ICollection{``0})">
      <summary>
        <para>Copy a collection of one type to an array of another type (with cast it elements to To type).
 Throw System.InvalidCastException if some elements can't be cast (VladD2: I hope :) ).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapToArray``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>// Convert a collection of one type to an array of another type.
// Convert collection of one type to array of another type. (Alias for MapToArray)
 Convert a sequence of one type to an array of another type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ConvertToArray``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>Convert sequence of one type to array of another type. (Alias for MapToArray)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ToArrayFiltered``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Convert sequence to array with filtration.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.NToArrayFiltered``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.InternalMapToArrayFiltered``2(``0[],Nemerle.Builtins.Function{``0,System.Boolean},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapToArrayFiltered``2(``0[],Nemerle.Builtins.Function{``0,System.Boolean},Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>Convert sequence to array with filtration.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapToArrayFiltered``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean},Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>Convert sequence to array with filtration.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ConvertToArrayFiltered``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapToList``2(``0[],Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapToList``2(System.Collections.Generic.IList{``0},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.MapToList``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Map``2(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Filter``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FilterToArray``1(``0[],Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Convert sequence to array with filtration.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FilterToArray``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.InternalFilterToArray``1(``0[],Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
        <para>Convert sequence to string.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.RightHand``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
        <para>Return right-hand element or new object (if id does not exists).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.LeftHand``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
        <para>Return left-hand element or new object (if id does not exists).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Find``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FindObject``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Find reference type object. Return reference to found objec of null.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FindValue``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Append``1(``0[],``0)" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Append``1(``0[],``0[])" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Iter``1(``0[],Nemerle.Builtins.FunctionVoid{``0})">
      <summary>
        <para>Iterates a function over an array.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ChopFirstN``1(``0[],System.Int32)">
      <summary>
        <para>Return a fresh copy of[arr] with first[n] elements removed.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ChopLastN``1(``0[],System.Int32)">
      <summary>
        <para>Return a fresh copy of[arr] with last[n] elements removed.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.IterI``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.FunctionVoid{System.Int32,``0})">
      <summary>
        <para>Iterates a function over a sequence, passing both the item index
 and value as the iterated function parameters.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.IterI``1(``0[],Nemerle.Builtins.FunctionVoid{System.Int32,``0})">
      <summary>
        <para>Iterates a function over an array, passing both the array index
 and value as the iterated function parameters.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Map``2(``0[],Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ConvertAll``2(``0[],Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>Convert array of one type to other. (This is a alias for Map().)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Map``2(System.Type,``0[],Nemerle.Builtins.Function{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Fold``2(``1[],``0,Nemerle.Builtins.Function{``1,``0,``0})">
      <summary>
        <para>Folds a function over an array.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FoldI``2(``1[],``0,Nemerle.Builtins.Function{System.Int32,``1,``0,``0})">
      <summary>
        <para>Folds a function over an array, passing the array index
 as an additional parameter to the folded function parameters.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Exists``1(System.Collections.Generic.IEnumerable{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Exists``1(``0[],Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Returns 'true' if at least one of the 'l' arrays's elements
 satisfies the condition 'f'.

</para>
      </summary> <remarks><para>Example of use:

</para>   <para>assert(array["a", "b", "abc", "d", "e"].Exists(x =&gt; x.Length &gt; 2));

</para> <para>evaluates to 'true' as there is one string of length 3 on the list.

</para></remarks></member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ForAll``1(``0[],Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Returns 'true' if exactly all of the 'l' arrays's elements
 satisfy the condition 'f'.

</para>
      </summary> <remarks><para>Example of use:

</para>   <para>array[2, 4, 6, 8, 10].ForAll(x =&gt; x % 2 == 0)

</para> <para>evaluates to 'true' as all the array's elements are even integers.

</para></remarks></member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FromList``1(System.Type,Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ToNList``1(``0[])" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Iter2``2(Nemerle.Core.list{``0},``1[],Nemerle.Builtins.FunctionVoid{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Iter2``2(``0[],Nemerle.Core.list{``1},Nemerle.Builtins.FunctionVoid{``0,``1})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Iter2``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},Nemerle.Builtins.FunctionVoid{``0,``1})">
      <summary>
        <para>Iterate over two collection

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.IterX``1(Nemerle.Builtins.FunctionVoid{``0[]},System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
        <para>Iterate over several collections

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Map2``3(Nemerle.Core.list{``0},``1[],Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Map2``3(``0[],Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.RevMap2``3(Nemerle.Core.list{``0},``1[],Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.RevMap2``3(``0[],Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FoldLeft2``3(Nemerle.Core.list{``0},``1[],``2,Nemerle.Builtins.Function{``0,``1,``2,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FoldLeft2``3(``0[],Nemerle.Core.list{``1},``2,Nemerle.Builtins.Function{``0,``1,``2,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FoldRight2``3(Nemerle.Core.list{``0},``1[],``2,Nemerle.Builtins.Function{``0,``1,``2,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.FoldRight2``3(``0[],Nemerle.Core.list{``1},``2,Nemerle.Builtins.Function{``0,``1,``2,``2})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ForAll2``2(Nemerle.Core.list{``0},``1[],Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ForAll2``2(``0[],Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Exists2``2(``0[],Nemerle.Core.list{``1},Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Exists2``2(Nemerle.Core.list{``0},``1[],Nemerle.Builtins.Function{``0,``1,System.Boolean})" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Filter``1(``0[],Nemerle.Builtins.Function{``0,System.Boolean})">
      <summary>
        <para>Filter elements to list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ToBase``2(``0[])">
      <summary>
        <para>Cast array to covariant subtype.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.SortInplace``1(``0[],System.Comparison{``0})">
      <summary>
        <para>Attention! It's inplace sort.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Sort``2(``0[],Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>Attention! It's inplace sort.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.NCollectionsExtensions.Clone``1(``0)" />
    <member name="M:Nemerle.Collections.NCollectionsExtensions.ToString``1(``0[],System.String)">
      <summary>
        <para>Convert array to string.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Collections.NemerleCollectionsComparer" />
    <member name="M:Nemerle.Collections.NemerleCollectionsComparer.#ctor" />
    <member name="T:Nemerle.Collections.NemerleCollectionsComparer.Comparer`1" />
    <member name="T:Nemerle.Collections.NemerleCollectionsComparer.GenericComparer`1" />
    <member name="T:Nemerle.Utility.NString" />
    <member name="M:Nemerle.Utility.NString.EndsWith(System.String,System.Char)" />
    <member name="M:Nemerle.Utility.NString.EndsWith(System.String,System.Char,System.Char)" />
    <member name="M:Nemerle.Utility.NString.StartsWith(System.String,System.Char,System.Char)" />
    <member name="M:Nemerle.Utility.NString.EndsWith(System.String,System.String[])" />
    <member name="M:Nemerle.Utility.NString.EndsWith(System.String,System.StringComparison,System.String[])" />
    <member name="M:Nemerle.Utility.NString.StartsWith(System.String,System.String[])" />
    <member name="M:Nemerle.Utility.NString.StartsWith(System.String,System.StringComparison,System.String[])" />
    <member name="M:Nemerle.Utility.NString.SplitToList(System.String,System.Char[])" />
    <member name="M:Nemerle.Utility.NString.Split(System.String,System.Char[])">
      <summary>
        <para>Splits the string at positions of occurrence of one
 of the characters from the given array.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.Split(System.String,Nemerle.Core.list{System.Char})">
      <summary>
        <para>Splits the string at positions of occurrence of one
 of the characters from the given list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.Concat(System.String,Nemerle.Core.list{System.String})">
      <summary>
        <para>Concatenates strings from the list, inserting given
 separator between them.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.SeparatedCalls``1(System.String,Nemerle.Core.list{``0},Nemerle.Builtins.FunctionVoid{``0},System.Text.StringBuilder)">
      <summary>
        <para>Calls the given function on elements of given list, appending
 given separator to string builder between those calls.

</para>
      </summary> <remarks><para>NOTE: the `f' function should be taking `acc' as a parameter,
       so that this function looks more Fold-like.

</para></remarks></member>
    <member name="M:Nemerle.Utility.NString.Map(System.String,Nemerle.Builtins.Function{System.Char,System.Char})">
      <summary>
        <para>Same as [Implode (NList.Map (Explode (s), f))] but a lot faster.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.MapCS(System.String,Nemerle.Builtins.Function{System.Char,System.String})">
      <summary>
        <para>Same as [Concat ("", NList.Map (Explode (s), f))] but a lot faster.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.Iter(System.String,Nemerle.Builtins.FunctionVoid{System.Char})">
      <summary>
        <para>Call [f] for all characters in [s] in turn.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.IterI(System.String,Nemerle.Builtins.FunctionVoid{System.Char,System.Int32})">
      <summary>
        <para>Call [f] for all characters in [s] in turn, passing the current
        index as the additional paramter.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.Fold``1(System.String,``0,Nemerle.Builtins.Function{System.Char,``0,``0})" />
    <member name="M:Nemerle.Utility.NString.Fold2``1(System.String,System.String,``0,Nemerle.Builtins.Function{System.Char,System.Char,``0,``0})" />
    <member name="M:Nemerle.Utility.NString.ForAll(System.String,Nemerle.Builtins.Function{System.Char,System.Boolean})">
      <summary>
        <para>Return [true] if [f] is returns [true] for all of the characters
        in the string [s].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.Exists(System.String,Nemerle.Builtins.Function{System.Char,System.Boolean})">
      <summary>
        <para>Return [true] if [f] is returns [true] for any of the characters
        in the string [s].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.NString.Explode(System.String)">
      <summary>
        <para>Changes string into a corresponding list of characters.

</para>
      </summary>        <remarks><para>Warning: this should not be used in performance critical parts of
        the program, because of list's memory overheads.
</para></remarks></member>
    <member name="M:Nemerle.Utility.NString.Implode(Nemerle.Core.list{System.Char})">
      <summary>
        <para>Constructs a string out of a list of characters.

</para>
      </summary>        <remarks><para>Warning: this should not be used in performance critical parts of
        the program, because of list's memory overheads.
</para></remarks></member>
    <member name="T:Nemerle.Utility.NStringBuilder" />
    <member name="T:Nemerle.Utility.NStringBuilderExtensions" />
    <member name="M:Nemerle.Utility.NStringBuilderExtensions._N_loop_21837(Nemerle.Utility.NStringBuilderExtensions._N_closure_21825,System.Int32)" />
    <member name="M:Nemerle.Utility.NStringBuilderExtensions._N_loop_21803``1(Nemerle.Utility.NStringBuilderExtensions._N_closure_21791{``0},System.Int32)" />
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendSeq``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="sep"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendSeq``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.String,Nemerle.Builtins.Function{``0,System.String})">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="sep"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendSeqByConvert``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.String,Nemerle.Builtins.FunctionVoid{``0})">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="sep"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendSeq``1(System.Text.StringBuilder,Nemerle.Core.list{``0},System.String)">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="sep"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendList``1(System.Text.StringBuilder,Nemerle.Core.list{``0},System.String)">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="seperator"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendList``1(System.Text.StringBuilder,Nemerle.Core.list{``0},Nemerle.Builtins.Function{System.Text.StringBuilder,``0,System.Text.StringBuilder},System.String)">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="append"><para>A function used to append elements. </para></param>
 <param name="seperator"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendWhen(System.Text.StringBuilder,System.Boolean,Nemerle.Builtins.Function{System.Text.StringBuilder,System.Text.StringBuilder})">
      <summary>
        <para>Appends to the end of a <see cref="NStringBuilder"></see> instance if a condition is true.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="condition"><para>true to cause a message to be written; otherwise, false. </para></param>
 <param name="append"><para>A function used to append elements. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendUnless(System.Text.StringBuilder,System.Boolean,Nemerle.Builtins.Function{System.Text.StringBuilder,System.Text.StringBuilder})">
      <summary>
        <para>Appends to the end of a <see cref="NStringBuilder"></see> instance if a condition is false.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="condition"><para>true to cause a message to be written; otherwise, false. </para></param>
 <param name="append"><para>A function used to append elements. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendNTimes``1(System.Text.StringBuilder,System.Int32,``0,System.String)">
      <summary>
        <para>Appends the string representation of a specified item to the end of a <see cref="NStringBuilder"></see> instance number of times.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="count"><para>The number of times when the item should be written. </para></param>
 <param name="a"><para>The item. </para></param>
 <param name="seperator"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendNTimes(System.Text.StringBuilder,System.Int32,Nemerle.Builtins.Function{System.Text.StringBuilder,System.Text.StringBuilder},System.String)">
      <summary>
        <para>Appends to the end of a <see cref="NStringBuilder"></see> instance number of times.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="count"><para>The number of times when the function should be invoked. </para></param>
 <param name="append"><para>A function used to append elements. </para></param>
 <param name="seperator"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendSeq``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.String,System.String,Nemerle.Builtins.Function{``0,System.String})">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="sep"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendSeq``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="sep"><para>The string used as element separator. </para></param>

</member>
    <member name="M:Nemerle.Utility.NStringBuilderExtensions.AppendSeqByConvert``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.String,System.String,Nemerle.Builtins.FunctionVoid{``0})">
      <summary>
        <para>Appends the string representation of a specified list items to the end of a <see cref="NStringBuilder"></see> instance.</para>
      </summary>
 <returns><para>A reference to the NStringBuilder instance after the append operation has completed.</para></returns>
 <param name="builder"><para>A <see cref="NStringBuilder"></see> instance pointer. </para></param>
 <param name="l"><para>A list. </para></param>
 <param name="sep"><para>The string used as element separator. </para></param>

</member>
    <member name="T:Nemerle.Core.option`1">
      <summary>
        <para>The optional value variant.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.option`1.#ctor" />
    <member name="M:Nemerle.Core.option`1.ToString">
      <summary>
        <para>Pretty prints the optional value.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.option`1.Equals(Nemerle.Core.option{`0})">
      <summary>
        <para>Typesafe equality checks.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.option`1.GetHashCode">
      <summary>
        <para>Structural HashCode provider

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.option`1.get_IsSome" />
    <member name="P:Nemerle.Core.option`1.IsSome" />
    <member name="M:Nemerle.Core.option`1.get_IsNone" />
    <member name="P:Nemerle.Core.option`1.IsNone" />
    <member name="M:Nemerle.Core.option`1.WithDefault(`0)" />
    <member name="M:Nemerle.Core.option`1.get_HasValue" />
    <member name="P:Nemerle.Core.option`1.HasValue" />
    <member name="M:Nemerle.Core.option`1.get_Value" />
    <member name="P:Nemerle.Core.option`1.Value" />
    <member name="M:Nemerle.Core.option`1.op_Implicit``1(System.Nullable{``0})~Nemerle.Core.option{``0}" />
    <member name="M:Nemerle.Core.option`1.Equals(System.Object)">
      <summary>
        <para>Typesafe equality checks.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.option`1._N_GetVariantCode">
      <summary>
        <para>The optional value variant.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.option`1._N_GetVariantCodeSafe(Nemerle.Core.option{`0})" />
    <member name="M:Nemerle.Core.option`1._N_GetVariantCodeObject(System.Object)" />
    <member name="T:Nemerle.Core.option`1.None`0" />
    <member name="T:Nemerle.Core.option`1.Some`0" />
    <member name="T:Nemerle.Core.Option">
      <summary>
        <para>Operations on optional values

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.Option.Equals``1(Nemerle.Core.option{``0},Nemerle.Core.option{``0})">
      <summary>
        <para>Safe equality check

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.Option.Map``2(Nemerle.Core.option{``0},Nemerle.Builtins.Function{``0,``1})">
      <summary>
        <para>Safe optional value mapping.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.Option.Iter``1(Nemerle.Core.option{``0},Nemerle.Builtins.FunctionVoid{``0})">
      <summary>
        <para>Same as ignore (Map (x, f)).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.Option.IsSome``1(Nemerle.Core.option{``0})">
      <summary>
        <para>Checks if the optional value is present.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.Option.IsNone``1(Nemerle.Core.option{``0})">
      <summary>
        <para>Returns `true' if the optional value is not present.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.Option.UnSome``1(Nemerle.Core.option{``0})">
      <summary>
        <para>Unwraps an optional value; throws an argument exception
 if the value is not present.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Core.Option.ToOption``1(System.Nullable{``0})">
      <summary>
        <para>Converts nullable value to optional value.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Core.ValueOption`1" />
    <member name="F:Nemerle.Core.ValueOption`1._value" />
    <member name="M:Nemerle.Core.ValueOption`1.get_Value" />
    <member name="P:Nemerle.Core.ValueOption`1.Value" />
    <member name="M:Nemerle.Core.ValueOption`1.GetValueOrDefault" />
    <member name="F:Nemerle.Core.ValueOption`1.HasValue" />
    <member name="M:Nemerle.Core.ValueOption`1.get_IsSome" />
    <member name="P:Nemerle.Core.ValueOption`1.IsSome" />
    <member name="M:Nemerle.Core.ValueOption`1.get_IsNone" />
    <member name="P:Nemerle.Core.ValueOption`1.IsNone" />
    <member name="M:Nemerle.Core.ValueOption`1.#ctor(`0)" />
    <member name="M:Nemerle.Core.ValueOption`1.None" />
    <member name="M:Nemerle.Core.ValueOption`1.Some(`0)" />
    <member name="T:Nemerle.Utility.Pair">
      <summary>
        <para>Special methods for handling pairs (two-element tuples)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.Pair.First``2(``0,``1)">
      <summary>
        <para>Returns the first element of a pair

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.Pair.Second``2(``0,``1)">
      <summary>
        <para>Returns the second element of a pair

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Utility.Pair.Swap``2(``0,``1)">
      <summary>
        <para>Swaps the elements of a pair, creating a new pair.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.IO.PipeReader" />
    <member name="F:Nemerle.IO.PipeReader.input_reader" />
    <member name="F:Nemerle.IO.PipeReader.filter" />
    <member name="F:Nemerle.IO.PipeReader.input_ptr" />
    <member name="F:Nemerle.IO.PipeReader.line" />
    <member name="M:Nemerle.IO.PipeReader.#ctor(System.IO.TextReader,Nemerle.Builtins.Function{System.String,System.String})" />
    <member name="M:Nemerle.IO.PipeReader.fill_buffer" />
    <member name="M:Nemerle.IO.PipeReader.Dispose(System.Boolean)" />
    <member name="M:Nemerle.IO.PipeReader.Peek" />
    <member name="M:Nemerle.IO.PipeReader.Read" />
    <member name="M:Nemerle.IO.PipeReader.ReadToEnd" />
    <member name="M:Nemerle.IO.PipeReader.ReadLine" />
    <member name="T:Nemerle.IO.PipeWriter" />
    <member name="F:Nemerle.IO.PipeWriter.output_writer" />
    <member name="F:Nemerle.IO.PipeWriter.filter" />
    <member name="F:Nemerle.IO.PipeWriter.line" />
    <member name="M:Nemerle.IO.PipeWriter.#ctor(System.IO.TextWriter,Nemerle.Builtins.Function{System.String,System.String})" />
    <member name="M:Nemerle.IO.PipeWriter.get_Encoding" />
    <member name="P:Nemerle.IO.PipeWriter.Encoding" />
    <member name="M:Nemerle.IO.PipeWriter.flush_line" />
    <member name="M:Nemerle.IO.PipeWriter.Dispose(System.Boolean)" />
    <member name="M:Nemerle.IO.PipeWriter.Flush" />
    <member name="M:Nemerle.IO.PipeWriter.Write(System.Char)" />
    <member name="T:Nemerle.Collections.Queue`1">
      <summary>
        <para>Class representing first-in-first-out queue.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.#ctor">
      <summary>
        <para>Create a new empty queue.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.#ctor(System.Int32)" />
    <member name="M:Nemerle.Collections.Queue`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
    <member name="M:Nemerle.Collections.Queue`1.get_IsEmpty" />
    <member name="P:Nemerle.Collections.Queue`1.IsEmpty">
      <summary>
        <para>Return `true` iff the queue is empty.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.get_Length" />
    <member name="P:Nemerle.Collections.Queue`1.Length">
      <summary>
        <para>Alias for Count.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Push(`0)">
      <summary>
        <para>Alias for Enqueue.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Add(`0)">
      <summary>
        <para>Alias for Enqueue.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Take">
      <summary>
        <para>Return the first element of the queue and remove it.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Pop">
      <summary>
        <para>Alias for Take.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Top">
      <summary>
        <para>Alias for Peek.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.First">
      <summary>
        <para>Return some element from the queue, implements ICollection.First.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Clone">
      <summary>
        <para>Create a shallow copy of the queue.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Iter(Nemerle.Builtins.FunctionVoid{`0})">
      <summary>
        <para>Call supplied function for every element of the queue.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Fold``1(Nemerle.Builtins.Function{`0,``0,``0},``0)">
      <summary>
        <para>Fold elements of the queue with supplied function and initial
 value.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Transfer(Nemerle.Collections.Queue{`0})">
      <summary>
        <para>Transfer all elements of the queue q to the end of this queue.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.ForAll(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Return `true' iff every element of the queue satisfy predicate f.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Exists(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Return true iff the queue contains an element that
 satisfies predicate f.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Filter(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Remove from queue every element that does not satisfy
 predicate f.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Map``1(Nemerle.Builtins.Function{`0,``0})">
      <summary>
        <para>Map queue to a new queue using mapping f.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.Partition(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Partition the queue into two queues: first with elements
 that satisfy predicate f, second with the rest.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.concat_helper(System.String,System.Text.StringBuilder)" />
    <member name="M:Nemerle.Collections.Queue`1.ToString">
      <summary>
        <para>Returns string representing contents of the queue.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Queue`1.ToString(System.String)">
      <summary>
        <para>Constructs string out of queue contents using given argument as a separator.
 </para>
      </summary>
      <param name="separator">
        <para>String to use a separator - it will be put between each
  two items of the list.</para>
      </param>

</member>
    <member name="T:Nemerle.Collections.Pair`1">
      <summary>
        <para>An auxillary data-structure for RList used instead of a regular
      tuple (which is a struct) for performance reasons.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Pair`1.System#Collections#IEnumerable#GetEnumerator" />
    <member name="F:Nemerle.Collections.Pair`1.fst" />
    <member name="F:Nemerle.Collections.Pair`1.snd" />
    <member name="M:Nemerle.Collections.Pair`1.Equals(Nemerle.Collections.Pair{`0})" />
    <member name="M:Nemerle.Collections.Pair`1.ToString" />
    <member name="M:Nemerle.Collections.Pair`1.GetEnumerator" />
    <member name="M:Nemerle.Collections.Pair`1.Equals(System.Object)" />
    <member name="M:Nemerle.Collections.Pair`1.#ctor(`0,`0)">
      <summary>
        <para>An auxillary data-structure for RList used instead of a regular
      tuple (which is a struct) for performance reasons.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Collections.RList`1">
      <summary>
        <para>RList is short for Random Access List. It is a purely functional
      data-structure. This implementation is based on the SML sources
      found in Chris Okasaki's "Purely Functional Data Structures"
      (Cambridge University Press, 1999).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.RList`1.System#Collections#IEnumerable#GetEnumerator" />
    <member name="M:Nemerle.Collections.RList`1.#cctor">
      <summary>
        <para>RList is short for Random Access List. It is a purely functional
      data-structure. This implementation is based on the SML sources
      found in Chris Okasaki's "Purely Functional Data Structures"
      (Cambridge University Press, 1999).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.RList`1.#ctor" />
    <member name="F:Nemerle.Collections.RList`1.Empty">
      <summary>
        <para>Returns an empty RList.
        Time complexity: O (1).
        </para>
      </summary>
      <returns>
          <para>An empty RList.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.IsEmpty(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Checks, whether the RList [xs] is empty.
        Time complexity: O (1).
        </para>
      </summary>
      <param name="xs">
          <para>The list to check for emptiness.
        </para></param>
        <returns>
          <para>true if the [xs] is empty,
          false otherwise.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.IsEmpty">
      <summary>
        <para>Checks, whether [this] is an empty RList.
        Time complexity: O (1).
        </para>
      </summary>
      <returns>
          <para>true if [this] is an empty RList,
          false otherwise.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Equals(Nemerle.Collections.RList{`0},Nemerle.Collections.RList{`0})">
      <summary>
        <para>Checks, whether two RLists are equal, by cheking if their
        respective elements are equal.
        Time complexity: O (min (|xs|, |ys|)).
        </para>
      </summary>
      <param name="xs">
          <para>The first compared RList.
        </para></param>
        <param name="ys">
          <para>The second compared RList.
        </para></param>
        <returns>
          <para>true if [xs] and [ys] are equal,
          false otherwise.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Equals(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Checks, whether [this] and [ys] are equal RLists, by cheking if their
        respective elements are equal.
        Time complexity: O (min (|this|, |ys|)).
        </para>
      </summary>
      <param name="ys">
          <para>The RList [this] is compared to.
        </para></param>
        <returns>
          <para>true if [this] and [ys] are equal,
          false otherwise.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Cons(`0,Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns a new RList composed by adding [x], to the head of the RList [xs].
        Time complexity: O (log (|xs|)).
        </para>
      </summary>
      <param name="x">
          <para>The element being added to the head of [xs].
        </para></param>
        <param name="xs">
          <para>The RList, to which head [x] is being added.
        </para></param>
        <returns>
          <para>A new RList composed of [x] as the new head and [xs] as the new tail.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Cons(`0)">
      <summary>
        <para>Returns a new RList composed by adding [x], to the head of the RList [this].
        Time complexity: O (log (|this|)).
        </para>
      </summary>
      <param name="x">
          <para>The element being added to the head of [this].
        </para></param>
        <returns>
          <para>A new RList composed of [x] as the new head and [this] as the new tail.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.UnCons(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Separates and returns the head and tail of the RList [xs].
        Time complexity: O (log (|xs|)).
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which tail is going to be returned along with the separated head.
        </para></param>
        <returns>
          <para>The head and tail of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.UnCons">
      <summary>
        <para>Separates and returns the head and tail of the RList [this].
        Time complexity: O (log (|this|)).
        </para>
      </summary>
      <returns>
          <para>The head and tail of [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Head(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns the head of the RList [xs].
        Time complexity: O (log (|xs|)).
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which head is going to be returned.
        </para></param>
        <returns>
          <para>The head of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Head">
      <summary>
        <para>Returns the head of the RList [this].
        Time complexity: O (log (|this|)).
        </para>
      </summary>
      <returns>
          <para>The head of [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Hd(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns the head of the RList [xs].
        Time complexity: O (log (|xs|)).
        An alias for Head.
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which head is going to be returned.
        </para></param>
        <returns>
          <para>The head of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Hd">
      <summary>
        <para>Returns the head of the RList [this].
        Time complexity: O (log (|this|)).
        An alias for Head.
        </para>
      </summary>
      <returns>
          <para>The head of [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Tail(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns the tail of the RList [xs].
        Time complexity: O (log (|xs|)).
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which tail is going to be returned.
        </para></param>
        <returns>
          <para>The tail of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Tail">
      <summary>
        <para>Returns the tail of the RList [this].
        Time complexity: O (log (|this|)).
        </para>
      </summary>
      <returns>
          <para>The tail of [this].
         </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Tl(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns the tail of the RList [xs].
        Time complexity: O (log (|xs|)).
        An alias for Tail.
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which tail is going to be returned.
        </para></param>
        <returns>
          <para>The tail of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Tl">
      <summary>
        <para>Returns the tail of the RList [this].
        Time complexity: O (log (|this|)).
        An alias fot Tail.
        </para>
      </summary>
      <returns>
          <para>The tail of [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Last(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns the last element of the RList [xs].
        Time complexity: O (log (|xs|)).
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which last element is going to be returned.
        </para></param>
        <returns>
          <para>The last element of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Last">
      <summary>
        <para>Returns the last element of the RList [this].
        Time complexity: O (log (|this|)).
        </para>
      </summary>
      <returns>
          <para>The last element of [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1._Length(Nemerle.Collections.RList{`0},System.Int32,System.Int32)" />
    <member name="M:Nemerle.Collections.RList`1.get_Length" />
    <member name="P:Nemerle.Collections.RList`1.Length">
      <summary>
        <para>Returns the length of the RList [this].
        Time complexity: O (log (|this|)).
        </para>
      </summary>
      <returns>
          <para>The length of [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Exists(Nemerle.Collections.RList{`0},Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Returns true if there exists an element on [xs], that
        satisfies the predicate [f] (that is f (elem) == true).
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The RList containing the tested elements.
        </para></param>
        <param name="f">
          <para>The predicate used during the tests.
        </para></param>
        <returns>
          <para>Returns true if for any element on the RList [xs],
          applying [f] to that element returns true, otherwise
          returns false.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Exists(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>Returns true if there exists an element on [this], that
        satisfies the predicate [f] (that is f (elem) == true).
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="f">
          <para>The predicate used during the tests.
        </para></param>
        <returns>
          <para>Returns true if for any element on the RList [this],
          applying [f] to that element returns true, otherwise
          returns false.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Member(Nemerle.Collections.RList{`0},`0)">
      <summary>
        <para>Returns true if the element [elem] exists on the
        RList [xs].
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The RList containing the tested elements.
        </para></param>
        <param name="elem">
          <para>The element, which existence on the RList [xs] is
          being tested.
        </para></param>
        <returns>
          <para>Returns true if for any element on the RList [xs],
          element.Equals ([elem]), otherwise returns false.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Member(`0)">
      <summary>
        <para>Returns true if the element [elem] exists on the
        RList [this].
        Time complexity: O (|this|).
        </para>
      </summary>
      <param name="elem">
          <para>The element, which existence on the RList [this] is
          being tested.
        </para></param>
        <returns>
          <para>Returns true if for any element on the RList [this],
          element.Equals ([elem]), otherwise returns false.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Contains(Nemerle.Collections.RList{`0},`0)">
      <summary>
        <para>Returns true if the element [elem] exists on the
        RList [xs].
        Time complexity: O (|xs|).
        An alias for Member.
        </para>
      </summary>
      <param name="xs">
          <para>The RList containing the tested elements.
        </para></param>
        <param name="elem">
          <para>The element, which existence on the RList [xs] is
          being tested.
        </para></param>
        <returns>
          <para>Returns true if for any element on the RList [xs],
          element.Equals ([elem]), otherwise returns false.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Contains(`0)">
      <summary>
        <para>Returns true if the element [elem] exists on the
        RList [this].
        Time complexity: O (|this|).
        An alias for Member.
        </para>
      </summary>
      <param name="elem">
          <para>The element, which existence on the RList [this] is
          being tested.
        </para></param>
        <returns>
          <para>Returns true if for any element on the RList [this],
          element.Equals ([elem]), otherwise returns false.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Nth(Nemerle.Collections.RList{`0},System.Int32)">
      <summary>
        <para>Returns the [i]-th element of the RList [xs].
        Time complexity: O (log (|xs|)).
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which [i]-th element is going to be returned.
        </para></param>
        <param name="i">
          <para>The index under which the return element is located in [xs].
        </para></param>
        <returns>
          <para>The [i]-th element of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Nth(System.Int32)">
      <summary>
        <para>Returns the [i]-th element of the RList [this].
        Time complexity: O (log (|this|)).
        </para>
      </summary>
      <param name="i">
          <para>The index under which the return element is located in [this].
        </para></param>
        <returns>
          <para>The [i]-th element of [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1._Update(Nemerle.Builtins.Function{`0,`0},System.Int32,Nemerle.Collections.RList{`0})" />
    <member name="M:Nemerle.Collections.RList`1.Update(System.Int32,`0,Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns a new RList composed by substituting the [i]-th element
        of the RList [xs], with [x].
        Time complexity: O (log (|xs|)).
        </para>
      </summary>
      <param name="xs">
          <para>The RList used in composing the return value.
        </para></param>
        <param name="i">
          <para>The index under which the element to be substituted resides in [xs].
        </para></param>
        <returns>
          <para>A new RList composed by substituting the [i]-th element
          of the RList [xs], with [x].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Update(System.Int32,`0)">
      <summary>
        <para>Returns a new RList composed by substituting the [i]-th element
        of the RList [this], with [x].
        Time complexity: O (log (|this|)).
        </para>
      </summary>
      <param name="i">
          <para>The index under which the element to be substituted resides in [this].
        </para></param>
        <returns>
          <para>A new RList composed by substituting the [i]-th element
          of the RList [this], with [x].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.FoldLeft``1(Nemerle.Collections.RList{`0},``0,Nemerle.Builtins.Function{`0,``0,``0})">
      <summary>
        <para>Iterates over the RList [xs] from left to right, composing the return
        value, by applying [f], to each of [xs]'s elements and the current [acc].
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The RList over which FoldLeft is going to iterate.
        </para></param>
        <param name="acc">
          <para>The accumulator being updated on each level of recursion, to
          finally become the return value of FoldLeft.
          The supplied value will be used by [f] in the first step.
        </para></param>
        <param name="f">
          <para>The function being applied to ([RList-elem], [acc]) in each step.
        </para></param>
        <returns>
          <para>Acc in it's final state at the last step of recursion
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.FoldLeft``1(``0,Nemerle.Builtins.Function{`0,``0,``0})">
      <summary>
        <para>Iterates over the RList [this] from left to right, composing the return
        value, by applying [f], to each of [this]' elements and the current [acc].
        Time complexity: O (|this|).
        </para>
      </summary>
      <param name="acc">
          <para>The accumulator being updated on each level of recursion, to
          finally become the return value of FoldLeft.
          The supplied value will be used by [f] in the first step.
        </para></param>
        <param name="f">
          <para>The function being applied to ([RList-elem], [acc]) in each step.
        </para></param>
        <returns>
          <para>Acc in it's final state at the last step of recursion
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.FoldRight``1(Nemerle.Collections.RList{`0},``0,Nemerle.Builtins.Function{`0,``0,``0})">
      <summary>
        <para>Iterates over the RList [xs] from right to left, composing the return
        value, by applying [f], to each of [xs]'s elements and the current [acc].
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The RList over which FoldRight is going to iterate.
        </para></param>
        <param name="acc">
          <para>The accumulator updated on each level of recursion and used by [f].
          The supplied value will be used by [f] in the last step.
        </para></param>
        <param name="f">
          <para>The function being applied to ([RList-elem], [acc]) in each step.
        </para></param>
        <returns>
          <para>The result of applying [f] to each element of [xs] and the current [acc].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.FoldRight``1(``0,Nemerle.Builtins.Function{`0,``0,``0})">
      <summary>
        <para>Iterates over the RList [this] from right to left, composing the return
        value, by applying [f], to each of [this]' elements and the current [acc].
        Time complexity: O (|this|).
        </para>
      </summary>
      <param name="acc">
          <para>The accumulator updated on each level of recursion and used by [f].
          The supplied value will be used by [f] in the last step.
        </para></param>
        <param name="f">
          <para>The function being applied to ([RList-elem], [acc]) in each step.
        </para></param>
        <returns>
          <para>The result of applying [f] to each element of [xs] and the current [acc].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Map``1(Nemerle.Collections.RList{`0},Nemerle.Builtins.Function{`0,``0})">
      <summary>
        <para>Returns a new RList composed from [xs] by applying [f]
        to every element on that RList.
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The source RList from which the return RList is composed by
          applying [f] to each of its elements.
        </para></param>
        <param name="f">
          <para>The function being applied to every [xs] element. The values
          it returns will make up the new RList returned by Map.
        </para></param>
        <returns>
          <para>A new RList composed from [xs] by applying [f] to every
          element on that RList.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Map``1(Nemerle.Builtins.Function{`0,``0})">
      <summary>
        <para>Returns a new RList composed from [this] by applying [f]
        to every element on that RList.
        Time complexity: O (|this|).
        </para>
      </summary>
      <param name="f">
          <para>The function being applied to every [this] element. The values
          it returns will make up the new RList returned by Map.
        </para></param>
        <returns>
          <para>A new RList composed from [this] by applying [f] to every
          element on that RList.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Iter(Nemerle.Collections.RList{`0},Nemerle.Builtins.FunctionVoid{`0})">
      <summary>
        <para>Iterates over [xs] applying [f] to each of its elements.
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The RList on which [f] is iterated.
        </para></param>
        <param name="f">
          <para>The function being applied to every [xs] element during
          iteration.
        </para></param>

</member>
    <member name="M:Nemerle.Collections.RList`1.Iter(Nemerle.Builtins.FunctionVoid{`0})">
      <summary>
        <para>Iterates over [this] applying [f] to each of its elements.
        Time complexity: O (|this|).
        </para>
      </summary>
      <param name="f">
          <para>The function being applied to every [this] element during
          iteration.
        </para></param>

</member>
    <member name="M:Nemerle.Collections.RList`1.Rev(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns an RList composed by reversing [xs].
        Time complexity: O (|xs| * log (|xs|)).
        </para>
      </summary>
      <param name="xs">
          <para>The RList used when composing the return value.
        </para></param>
        <returns>
          <para>An RList composed by reversing [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Rev">
      <summary>
        <para>Returns an RList composed by reversing [this].
        Time complexity: O (|this| * log (|this|)).
        </para>
      </summary>
      <returns>
          <para>An RList composed by reversing [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Append(Nemerle.Collections.RList{`0},Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns an a new RList composed by appending [ys]
        at the end of [xs].
        Time complexity: roughly O (|xs| * log (|ys| + |xs|)).
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which elements come first in the resulting RList.
        </para></param>
        <param name="ys">
          <para>The RList, which elements come second in the resulting RList.
        </para></param>
        <returns>
          <para>An RList composed by appending [ys] at the end of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.Append(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns an a new RList composed by appending [ys]
        at the end of [this].
        Time complexity: roughly O (|this| * log (|this| + |ys|)).
        </para>
      </summary>
      <param name="ys">
          <para>The RList, which elements come second in the resulting RList.
        </para></param>
        <returns>
          <para>An RListcomposed by appending [ys] at the end of [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.op_Addition(Nemerle.Collections.RList{`0},Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns an a new RList composed by appending [ys]
        at the end of [xs].
        Time complexity: roughly O (|xs| * log (|ys| + |xs|)).
        An alias for Append.
        </para>
      </summary>
      <param name="xs">
          <para>The RList, which elements come first in the resulting RList.
        </para></param>
        <param name="ys">
          <para>The RList, which elements come second in the resulting RList.
        </para></param>
        <returns>
          <para>An RList composed by appending [ys] at the end of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.FromList(Nemerle.Core.list{`0})">
      <summary>
        <para>Returns an RList composed of the elements of list [xs].
        Use RList (xs, |xs|) if |xs| is known.
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The list used when composing the return value.
        </para></param>
        <returns>
          <para>An RList composed of the elements of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.FromList(Nemerle.Core.list{`0},System.Int32)">
      <summary>
        <para>Returns an RList composed of the elements of list [xs], of
        length [i].
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The list used when composing the return value.
        </para></param>
        <param name="i">
          <para>The length of [xs] and therefore of the return value as well.
        </para></param>
        <returns>
          <para>An RList composed of the elements of [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1._FromList``1(Nemerle.Core.list{``0},System.Int32,Nemerle.Builtins.Function{Nemerle.Core.list{``0},Nemerle.Builtins.Tuple{`0,Nemerle.Core.list{``0}}})" />
    <member name="M:Nemerle.Collections.RList`1.ToList(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns a list of elements of the RList [xs] in the same order.
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The RList used when composing the return value.
        </para></param>
        <returns>
          <para>A list of elements of the RList [xs] in the same order.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.ToList">
      <summary>
        <para>Returns a list of elements of the RList [this] in the same order.
        Time complexity: O (|this|).
        </para>
      </summary>
      <returns>
          <para>A list of elements of the RList [this] in the same order.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.ToString(Nemerle.Collections.RList{`0})">
      <summary>
        <para>Returns a string representation of the RList [xs].
        Time complexity: O (|xs|).
        </para>
      </summary>
      <param name="xs">
          <para>The RList used when composing the return value.
        </para></param>
        <returns>
          <para>A string representation of the RList [xs].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.ToString">
      <summary>
        <para>Returns a string representation of the RList [this].
        Time complexity: O (|this|).
        </para>
      </summary>
      <returns>
          <para>A string representation of the RList [this].
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1.GetEnumerator" />
    <member name="M:Nemerle.Collections.RList`1.get_Item(System.Int32)" />
    <member name="P:Nemerle.Collections.RList`1.Item" />
    <member name="M:Nemerle.Collections.RList`1.Equals(System.Object)">
      <summary>
        <para>Checks, whether [this] and [ys] are equal RLists, by cheking if their
        respective elements are equal.
        Time complexity: O (min (|this|, |ys|)).
        </para>
      </summary>
      <param name="ys">
          <para>The RList [this] is compared to.
        </para></param>
        <returns>
          <para>true if [this] and [ys] are equal,
          false otherwise.
        </para></returns>

</member>
    <member name="M:Nemerle.Collections.RList`1._N_GetVariantCode">
      <summary>
        <para>RList is short for Random Access List. It is a purely functional
      data-structure. This implementation is based on the SML sources
      found in Chris Okasaki's "Purely Functional Data Structures"
      (Cambridge University Press, 1999).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.RList`1._N_GetVariantCodeSafe(Nemerle.Collections.RList{`0})" />
    <member name="M:Nemerle.Collections.RList`1._N_GetVariantCodeObject(System.Object)" />
    <member name="T:Nemerle.Collections.RList`1.Nil`0" />
    <member name="T:Nemerle.Collections.RList`1.Zero`0" />
    <member name="T:Nemerle.Collections.RList`1.One`0" />
    <member name="T:Nemerle.Collections.Set`1" />
    <member name="M:Nemerle.Collections.Set`1.System#Collections#IEnumerable#GetEnumerator" />
    <member name="F:Nemerle.Collections.Set`1._tree" />
    <member name="F:Nemerle.Collections.Set`1._cmp" />
    <member name="F:Nemerle.Collections.Set`1._size" />
    <member name="M:Nemerle.Collections.Set`1.#ctor" />
    <member name="M:Nemerle.Collections.Set`1.#ctor(Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="M:Nemerle.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
    <member name="M:Nemerle.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0},Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="M:Nemerle.Collections.Set`1.#ctor(System.Int32,Nemerle.Collections.TwoThreeTree.Node{`0},Nemerle.Builtins.Function{`0,`0,System.Int32},System.Collections.Generic.IEnumerable{`0})" />
    <member name="M:Nemerle.Collections.Set`1.#ctor(System.Int32,Nemerle.Collections.TwoThreeTree.Node{`0},Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="M:Nemerle.Collections.Set`1.Clear" />
    <member name="M:Nemerle.Collections.Set`1.Add(`0)" />
    <member name="M:Nemerle.Collections.Set`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
    <member name="M:Nemerle.Collections.Set`1.AddList(Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Collections.Set`1.Remove(`0)" />
    <member name="M:Nemerle.Collections.Set`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})" />
    <member name="M:Nemerle.Collections.Set`1.RemoveList(Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Collections.Set`1.Replace(`0)" />
    <member name="M:Nemerle.Collections.Set`1.ReplaceRange(System.Collections.Generic.IEnumerable{`0})" />
    <member name="M:Nemerle.Collections.Set`1.ReplaceList(Nemerle.Core.list{`0})" />
    <member name="M:Nemerle.Collections.Set`1.Fold``1(``0,Nemerle.Builtins.Function{`0,``0,``0})" />
    <member name="M:Nemerle.Collections.Set`1.FoldLeft``1(``0,Nemerle.Builtins.Function{`0,``0,``0})" />
    <member name="M:Nemerle.Collections.Set`1.FoldRight``1(``0,Nemerle.Builtins.Function{`0,``0,``0})" />
    <member name="M:Nemerle.Collections.Set`1.Iter(Nemerle.Builtins.FunctionVoid{`0})" />
    <member name="M:Nemerle.Collections.Set`1.IterLeft(Nemerle.Builtins.FunctionVoid{`0})" />
    <member name="M:Nemerle.Collections.Set`1.IterRight(Nemerle.Builtins.FunctionVoid{`0})" />
    <member name="M:Nemerle.Collections.Set`1.Filter(Nemerle.Builtins.Function{`0,System.Boolean})" />
    <member name="M:Nemerle.Collections.Set`1.Partition(Nemerle.Builtins.Function{`0,System.Boolean})" />
    <member name="M:Nemerle.Collections.Set`1.ForAll(Nemerle.Builtins.Function{`0,System.Boolean})" />
    <member name="M:Nemerle.Collections.Set`1.Exists(Nemerle.Builtins.Function{`0,System.Boolean})" />
    <member name="M:Nemerle.Collections.Set`1.Contains(`0)" />
    <member name="M:Nemerle.Collections.Set`1.get_Item(`0)" />
    <member name="P:Nemerle.Collections.Set`1.Item" />
    <member name="M:Nemerle.Collections.Set`1.Sum(Nemerle.Collections.Set{`0})" />
    <member name="M:Nemerle.Collections.Set`1.Subtract(Nemerle.Collections.Set{`0})" />
    <member name="M:Nemerle.Collections.Set`1.Intersect(Nemerle.Collections.Set{`0})" />
    <member name="M:Nemerle.Collections.Set`1.Xor(Nemerle.Collections.Set{`0})" />
    <member name="M:Nemerle.Collections.Set`1.ToList" />
    <member name="M:Nemerle.Collections.Set`1.ToArray" />
    <member name="M:Nemerle.Collections.Set`1.MapToList``1(Nemerle.Builtins.Function{`0,``0})" />
    <member name="M:Nemerle.Collections.Set`1.MapToArray``1(Nemerle.Builtins.Function{`0,``0})" />
    <member name="M:Nemerle.Collections.Set`1.get_IsEmpty" />
    <member name="P:Nemerle.Collections.Set`1.IsEmpty" />
    <member name="M:Nemerle.Collections.Set`1.GetEnumerator" />
    <member name="M:Nemerle.Collections.Set`1.CopyTo(`0[],System.Int32)" />
    <member name="M:Nemerle.Collections.Set`1.get_IsReadOnly" />
    <member name="P:Nemerle.Collections.Set`1.IsReadOnly" />
    <member name="M:Nemerle.Collections.Set`1.get_Count" />
    <member name="P:Nemerle.Collections.Set`1.Count" />
    <member name="M:Nemerle.Collections.Set`1.Remove_Invalid(`0)" />
    <member name="M:Nemerle.Collections.Set`1.Clear_Invalid" />
    <member name="M:Nemerle.Collections.Set`1.Add_Invalid(`0)" />
    <member name="M:Nemerle.Collections.Set`1.ToString" />
    <member name="M:Nemerle.Collections.Set`1.GetHashCode" />
    <member name="M:Nemerle.Collections.Set`1.Equals(System.Object)" />
    <member name="M:Nemerle.Collections.Set`1.CompareTo(Nemerle.Collections.Set{`0})" />
    <member name="M:Nemerle.Collections.Set`1.Sum(Nemerle.Core.list{Nemerle.Collections.Set{`0}})" />
    <member name="M:Nemerle.Collections.Set`1.Sum(Nemerle.Core.list{Nemerle.Collections.Set{`0}},Nemerle.Builtins.Function{`0,`0,System.Int32})" />
    <member name="T:Nemerle.Collections.Stack`1">
      <summary>
        <para>A stack

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.RemoveLast" />
    <member name="M:Nemerle.Collections.Stack`1.Add(`0)" />
    <member name="M:Nemerle.Collections.Stack`1.#ctor" />
    <member name="M:Nemerle.Collections.Stack`1.#ctor(System.Int32)" />
    <member name="M:Nemerle.Collections.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
    <member name="M:Nemerle.Collections.Stack`1.get_IsEmpty" />
    <member name="P:Nemerle.Collections.Stack`1.IsEmpty">
      <summary>
        <para>Returns `true' iff the stack is empty.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.get_Length" />
    <member name="P:Nemerle.Collections.Stack`1.Length">
      <summary>
        <para>An alias for `Count'.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.get_Height" />
    <member name="P:Nemerle.Collections.Stack`1.Height">
      <summary>
        <para>An alias for `Count'.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.get_Top" />
    <member name="M:Nemerle.Collections.Stack`1.set_Top(`0)" />
    <member name="P:Nemerle.Collections.Stack`1.Top">
      <summary>
        <para>When read -- peeks at the object on the top of the stack. When
 written -- replaces the topmost element with specified value (there
 has to be one).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.First">
      <summary>
        <para>Same as Peek, but does not throw an exception
 -- instead it returns an optional result.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.Clone">
      <summary>
        <para>Creates a shallow copy of this stack

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.Iter(Nemerle.Builtins.FunctionVoid{`0})">
      <summary>
        <para>See NList.Iter.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.Map``1(Nemerle.Builtins.Function{`0,``0})">
      <summary>
        <para>See NList.Map.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.Filter(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>See NList.Filter.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.ForAll(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>See NList.ForAll.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.Exists(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>See NList.Exists.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.Fold``1(Nemerle.Builtins.Function{`0,``0,``0},``0)">
      <summary>
        <para>See NList.FoldLeft.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.Partition(Nemerle.Builtins.Function{`0,System.Boolean})">
      <summary>
        <para>See NList.Partition.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.concat_helper(System.String,System.Text.StringBuilder)" />
    <member name="M:Nemerle.Collections.Stack`1.ToString">
      <summary>
        <para>Returns string representing contents of the queue.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Collections.Stack`1.ToString(System.String)">
      <summary>
        <para>Constructs string out of queue contents using given argument as a separator.
 </para>
      </summary>
      <param name="separator">
        <para>String to use a separator - it will be put between each
  two items of the list.</para>
      </param>

</member>
    <member name="T:Nemerle.Collections.TwoThreeTree" />
    <member name="T:Nemerle.Collections.TwoThreeTree.InsertOptions" />
    <member name="T:Nemerle.Collections.TwoThreeTree.DeleteOptions" />
    <member name="T:Nemerle.Collections.TwoThreeTree.Node`1" />
  </members>
</doc>