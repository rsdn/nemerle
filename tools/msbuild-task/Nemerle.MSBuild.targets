
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <UsingTask
      TaskName="Nemerle.Tools.MSBuildTask.Ncc" 
      AssemblyFile="Nemerle.MSBuild.Tasks.dll"/>


    <PropertyGroup>
        <MSBuildAllProjects>$(MSBuildAllProjects);Nemerle.MSBuild.targets</MSBuildAllProjects>
        <DefaultLanguageSourceExtension>.n</DefaultLanguageSourceExtension>
        <Language>Nemerle</Language>
    </PropertyGroup>

    <!--
    The CreateManifestResourceNames target create the manifest resource names
	from the .RESX files.

        [IN]
        @(ResxWithNoCulture) - The names the non-culture .RESX files.
        @(ResxWithCulture) - The names the culture .RESX files.
        @(NonResxWithNoCulture) - The names of the non-culture non-RESX
		                          files (like bitmaps, etc).
								  
        @(NonResxWithCulture) - The names of the culture non-RESX
		                       files (like bitmaps, etc).

        [OUT]
        @(ManifestResourceWithNoCultureName) - The corresponding manifest
		                                       resource name (.RESOURCE)
											   
        @(ManifestResourceWithCultureName) - The corresponding manifest
		                                     resource name (.RESOURCE)
											 
        @(ManifestNonResxWithNoCulture) - The corresponding manifest
		                                  resource name.
										  
        @(ManifestNonResxWithCulture) - The corresponding manifest
		                               resource name.

    For Nemerle applications the transformation is like:

        Resources1.resx => RootNamespace.Resources1 => Build into main assembly
        
		SubFolder\Resources1.resx =>
			RootNamespace.SubFolder.Resources1 =>
				Build into main assembly
        
		Resources1.fr.resx =>
			RootNamespace.Resources1.fr =>
				Build into satellite assembly
				
        Resources1.notaculture.resx =>
			RootNamespace.Resources1.notaculture =>
				Build into main assembly

    For other project systems, this transformation may be different.
    -->
	
    <PropertyGroup>
        <CreateManifestResourceNamesDependsOn>
		</CreateManifestResourceNamesDependsOn>
    </PropertyGroup>
    <Target
        Name="CreateManifestResourceNames"
        Condition="'
			@(ResxWithNoCulture)
			@(ResxWithCulture)
			@(NonResxWithNoCulture)
			@(NonResxWithCulture)'!=''"
			
        DependsOnTargets="$(CreateManifestResourceNamesDependsOn)"
        >

        <!-- Create the target resource names for non-culture resx files.
        <CreateNemerleManifestResourceName
			Condition="'@(ResxWithNoCulture)'!=''"
			ResourceFiles="@(ResxWithNoCulture)"
			RootNamespace="$(RootNamespace)">
			
			<Output
				TaskParameter="ManifestResourceNames"
				ItemName="ManifestResourceWithNoCultureName"/>

        </CreateCSharpManifestResourceName>--> 

        <!-- Create the target resource names for culture resx files. 
        <CreateCSharpManifestResourceName
			Condition="'@(ResxWithCulture)'!=''"
			ResourceFiles="@(ResxWithCulture)"
			RootNamespace="$(RootNamespace)">

            <Output
				TaskParameter="ManifestResourceNames"
				ItemName="ManifestResourceWithCultureName"/>

        </CreateCSharpManifestResourceName>-->

        <!--
		Create the target resource names for non-culture non-resx files.
	    
        <CreateCSharpManifestResourceName
			Condition="'@(NonResxWithNoCulture)'!=''"
			ResourceFiles="@(NonResxWithNoCulture)"
			RootNamespace="$(RootNamespace)">

            <Output
				TaskParameter="ManifestResourceNames"
				ItemName="ManifestNonResxWithNoCulture"/>

        </CreateCSharpManifestResourceName>-->

        <!-- Create the target resource names for culture non-resx files. 
        <CreateCSharpManifestResourceName
			Condition="'@(NonResxWithCulture)'!=''"
			ResourceFiles="@(NonResxWithCulture)"
			RootNamespace="$(RootNamespace)">

            <Output
				TaskParameter="ManifestResourceNames"
				ItemName="ManifestNonResxWithCulture"/>

        </CreateCSharpManifestResourceName>-->
    </Target>

    <PropertyGroup>

        <!-- "None" is not technically a valid DebugType, so we can't pass it in as such
             to the compiler.  So here, we modify the properties so they make sense. -->
        <DebugSymbols Condition=" '$(DebugType)' == 'none' ">false</DebugSymbols>
        <DebugType    Condition=" '$(DebugType)' == 'none' "></DebugType>    

        <_DisabledWarnings>$(NoWarn)</_DisabledWarnings>
        
        <!-- Provide a facility to override UseHostCompilerIfAvailable-->
        <UseHostCompilerIfAvailable Condition=" '$(UseHostCompilerIfAvailable)' == ''">true</UseHostCompilerIfAvailable>

    </PropertyGroup>


    <ItemGroup>
        <DocFileItem Include="$(DocumentationFile)" Condition="'$(DocumentationFile)'!=''"/>
    </ItemGroup>

    <PropertyGroup>
        <CoreCompileDependsOn>_ComputeNonExistentFileProperty</CoreCompileDependsOn>
    </PropertyGroup>
    <Target
        Name="CoreCompile"
        Inputs="$(MSBuildAllProjects);
                @(Compile);
                @(ManifestResourceWithNoCulture);
                $(ApplicationIcon);
                $(AssemblyOriginatorKeyFile);
                @(ManifestNonResxWithNoCultureOnDisk);
                @(ReferencePath);
                @(CompiledLicenseFile);
                @(EmbeddedDocumentation);                
                @(CustomAdditionalCompileInputs)"
        Outputs="@(DocFileItem);
                 @(IntermediateAssembly);
                 $(NonExistentFile);
                 @(CustomAdditionalCompileOutputs)"
        DependsOnTargets="$(CoreCompileDependsOn)"
    >
       
        <Ncc
              AdditionalLibPaths="$(AdditionalLibPaths)"
              DefineConstants="$(DefineConstants)"
              DisabledWarnings="$(_DisabledWarnings)"
              DocumentationFile="@(DocFileItem)"
              EmitDebugInformation="$(DebugSymbols)"              
              KeyFile="$(KeyOriginatorFile)"
              NoLogo="$(NoLogo)"
              NoStandardLib="$(NoStdLib)"              
              Optimize="$(Optimize)"
              OutputAssembly="@(IntermediateAssembly)"
              References="@(ReferencePath)"
              Resources="@(ManifestResourceWithNoCulture);@(ManifestNonResxWithNoCultureOnDisk);@(CompiledLicenseFile)"
              ResponseFiles="$(CompilerResponseFile)"
              Sources="@(Compile)"
              TargetType="$(OutputType)"
              ToolPath="$(CscToolPath)"
              TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
              WarningLevel="$(WarningLevel)"
              WarningsAsErrors="$(WarningsAsErrors)"
              />

    </Target>
    
    <Import Project="$(MSBuildBinPath)\Microsoft.Common.targets" />
</Project>

<!--
              AddModules="@(AddModules)"
              AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
              BaseAddress="$(BaseAddress)"
              CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)"
              CodePage="$(CodePage)"
              DebugType="$(DebugType)"
              DelaySign="$(DelaySign)"
              ErrorReport="$(ErrorReport)"
              FileAlignment="$(FileAlignment)"
              GenerateFullPaths="$(GenerateFullPaths)"
              KeyContainer="$(KeyContainerName)"
              LangVersion="$(LangVersion)"
              MainEntryPoint="$(StartupObject)"
              ModuleAssemblyName="$(ModuleAssemblyName)"
              NoConfig="true"
              PdbFile="$(PdbFile)" 
              Platform="$(PlatformTarget)"
              UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)"
              Utf8Output="$(Utf8Output)"
              WarningsNotAsErrors="$(WarningsNotAsErrors)"
              Win32Icon="$(ApplicationIcon)"
              Win32Resource="$(Win32Resource)"
-->