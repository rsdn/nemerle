//
// NemerleCodeGenerator.n
//
// Author:
//  Atsushi Enomoto <atsushi@ximian.com>
//  Kamil Skalski <nazgul@nemerle.org>
//
//  modified by Andrey Khropov <andrey.khropov@gmail.com>
//
// This derived part of the source code is published as public domain.
//
// Original: CSharpCodeGenerator.cs
//
// Original Author:
//   Daniel Stodden (stodden@in.tum.de)
//
// (C) 2002 Ximian,  Inc.
//

//
// Permission is hereby granted,  free of charge,  to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"),  to deal in the Software without restriction,  including
// without limitation the rights to use,  copy,  modify,  merge,  publish, 
// distribute,  sublicense,  and/or sell copies of the Software,  and to
// permit persons to whom the Software is furnished to do so,  subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS",  WITHOUT WARRANTY OF ANY KIND, 
// EXPRESS OR IMPLIED,  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM,  DAMAGES OR OTHER LIABILITY,  WHETHER IN AN ACTION
// OF CONTRACT,  TORT OR OTHERWISE,  ARISING FROM,  OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Collections;

namespace Nemerle.Compiler
{
  public class NemerleCodeGenerator : CodeGenerator
  {
    protected enum BracingType
    {
      | C | Block | Indent | Implicit
    }

    mutable dont_write_semicolon : bool = false;
    mutable id : int = 0;

    private new_name () : string {
      ++id;
      "_N" + id.ToString() + "_";
    }

    public this () { }
    
    #region Output-related

    /* AKhropov: The following hacks are needed to be able to call all Generate* methods directly
                 with your custom Output
    */

    mutable options : CodeGeneratorOptions = null;

    protected new Options : CodeGeneratorOptions
    {
      get { if (options != null) options else base.Options }
      set { options = value; }
    }

    protected BracingStyle : BracingType
    {
      get { 
        match (Options.BracingStyle) {
          | "Block"    => BracingType.Block
          | "Indent"   => BracingType.Indent
          | "Implicit" => BracingType.Implicit
          | "C" | _    => BracingType.C
        }
      }
    }

    mutable output : IndentedTextWriter = null;

    protected new Output : TextWriter
    {
      get { if (output != null) output else base.Output }
      set { 
        when (Options == null) 
          options = CodeGeneratorOptions();
        output = IndentedTextWriter(value, Options.IndentString);
      }
    }

    protected new Indent : int
    {
      get { if (output != null) output.Indent else base.Indent }
      set
      {
        if (output != null)
          output.Indent = value
        else
          base.Indent = value
      }
    }

    #endregion

    protected override NullToken : string
    {
      get { "null" }
    }

    protected override GenerateArrayCreateExpression (expression : CodeArrayCreateExpression) : void
    {
      def output = Output;

      output.Write("array");

      def initializers = expression.Initializers;
      mutable createType = expression.CreateType;

      if (initializers.Count > 0) {
        output.WriteLine ("[");
        ++Indent;
        OutputExpressionList (initializers,  true);
        --Indent;
        output.Write ("]");
      }
      else {
        mutable arrayType = createType.ArrayElementType;

        while (arrayType != null) {
          createType = arrayType;
          arrayType = arrayType.ArrayElementType;
        }

        output.Write('(');

        def size = expression.SizeExpression;
        if (size != null)
          GenerateExpression(size);
        else
          output.Write(expression.Size);

        output.Write(')');
      }
  
      when (createType.BaseType == "System.Object" || createType.BaseType == "object")
        output.Write(" :> array[object]");
    }
    
    protected override GenerateBaseReferenceExpression (_ : CodeBaseReferenceExpression) : void
    {
      Output.Write ("base");
    }

    protected mutable inNestedBinary : bool = false;

    protected override GenerateBinaryOperatorExpression (e : CodeBinaryOperatorExpression) : void
    {
      def output = Output;

      mutable first = false;
      output.Write("(");
      GenerateExpression(e.Left);
      output.Write(" ");
      when ((e.Left is CodeBinaryOperatorExpression) || (e.Right is CodeBinaryOperatorExpression)) {
        when (!inNestedBinary) {
          first = true;
          inNestedBinary = true;
          Indent += 3;
        }
        ContinueOnNewLine("");
      }
      OutputOperator(e.Operator);
      output.Write(" ");
      GenerateExpression(e.Right);
      output.Write(")");

      when (first)
      {
        Indent -= 3;
        inNestedBinary = false;
      }
    }
    
    protected override GenerateCastExpression (expression : CodeCastExpression) : void
    {
      def output = Output;
      output.Write("(");
      GenerateExpression(expression.Expression);
      output.Write(" :> ");
      OutputType(expression.TargetType);
      output.Write(")");
    }

    protected override GenerateCompileUnitStart (_compileUnit : CodeCompileUnit) : void
    {
      GenerateComment(CodeComment("------------------------------------------------------------------------------"));
      GenerateComment(CodeComment(" <autogenerated>"));
      GenerateComment(CodeComment("     This code was generated by a tool."));
      GenerateComment(CodeComment("     Runtime Version: " +  System.Environment.Version.ToString ()));
      GenerateComment(CodeComment(""));
      GenerateComment(CodeComment("     Changes to this file may cause incorrect behavior and will be lost if "));
      GenerateComment(CodeComment("     the code is regenerated."));
      GenerateComment(CodeComment(" </autogenerated>"));
      GenerateComment(CodeComment("------------------------------------------------------------------------------"));

      when (Options.BracingStyle == "Indent")
        Output.WriteLine("#pragma indent");
        
      when (Options.BracingStyle == "Implicit")
        Output.WriteLine("#pragma implicit");

      Output.WriteLine();
    }

    protected override GenerateDelegateCreateExpression (expression : CodeDelegateCreateExpression) : void
    {
      def output = Output;

      // we need to explicitly create delegate,  because sometimes
      // one generate code and use delegate object,  instead
      // our cool functional values
      OutputType(expression.DelegateType);
      output.Write('(');
                        
      def targetObject = expression.TargetObject;
      when (targetObject != null) {
        GenerateExpression(targetObject);
        Output.Write('.');
      }
      output.Write(GetSafeName (expression.MethodName));
      output.Write(')');
    }

    protected override GenerateDirectives (directives : CodeDirectiveCollection) : void
    {
      when (directives.Count > 0) {
        def output = Output;

        output.WriteLine("");
        foreach (dir in directives)
        {
          | dir is CodeRegionDirective =>
            match(dir.RegionMode)
            {
              | Start => output.WriteLine($"#region $(dir.RegionText)")
              | End   => output.WriteLine("#endregion ")
              | None  => ()
            }

          | _ => () // Ignored
        }
        output.WriteLine("");
      }
    }

    protected override GenerateSingleFloatValue (f : float) : void
    {
       Output.Write(f.ToString("R",  CultureInfo.InvariantCulture));
       Output.Write('f');
    }

    protected override GenerateDoubleValue (d : double) : void
    {
       Output.Write(d.ToString("R",  CultureInfo.InvariantCulture));
    }

    protected override GenerateFieldReferenceExpression (expression : CodeFieldReferenceExpression) : void
    {
      def targetObject = expression.TargetObject;
      when (targetObject != null) {
        GenerateExpression (targetObject);
        Output.Write ('.');
      }
      Output.Write (GetSafeName (expression.FieldName));
    }
    
    protected override GenerateArgumentReferenceExpression (expression : CodeArgumentReferenceExpression) : void
    {
      Output.Write (GetSafeName (expression.ParameterName));
    }

    protected override GenerateVariableReferenceExpression (expression : CodeVariableReferenceExpression) : void
    {
      Output.Write (GetSafeName (expression.VariableName));
    }
      
    protected override GenerateIndexerExpression (expression : CodeIndexerExpression) : void
    {
      def output = Output;

      GenerateExpression (expression.TargetObject);
      output.Write ('[');
      OutputExpressionList(expression.Indices);
      output.Write(']');
    }
    
    protected override GenerateArrayIndexerExpression (expression : CodeArrayIndexerExpression) : void
    {
      def output = Output;

      GenerateExpression (expression.TargetObject);
      output.Write ('[');
      OutputExpressionList (expression.Indices);
      output.Write (']');
    }
    
    protected override GenerateSnippetExpression (expression : CodeSnippetExpression) : void
    {
      // TODO : maybe special handling for some snippets (Nemerle-specific code)
      Output.Write (expression.Value);
    }
    
    protected override GenerateMethodInvokeExpression (expression : CodeMethodInvokeExpression) : void
    {
      def output = Output;

      GenerateMethodReferenceExpression (expression.Method);

      output.Write ('(');
      OutputExpressionList (expression.Parameters);
      output.Write (')');
    }

    protected override GenerateMethodReferenceExpression (expression : CodeMethodReferenceExpression) : void
    {
      when (expression.TargetObject != null)
      {
        GenerateExpression (expression.TargetObject);
        Output.Write ('.');
      }
      Output.Write (GetSafeName (expression.MethodName));
    }

    protected override GenerateEventReferenceExpression (expression : CodeEventReferenceExpression) : void
    {
      GenerateExpression (expression.TargetObject);
      Output.Write ('.');
      Output.Write (GetSafeName (expression.EventName));
    }

    protected override GenerateDelegateInvokeExpression (expression : CodeDelegateInvokeExpression) : void
    {
      GenerateExpression (expression.TargetObject);
      Output.Write ('(');
      OutputExpressionList (expression.Parameters);
      Output.Write (')');
    }
    
    protected override GenerateObjectCreateExpression (expression : CodeObjectCreateExpression) : void
    {
      OutputType (expression.CreateType);
      Output.Write ('(');
      OutputExpressionList (expression.Parameters);
      Output.Write (')');
    }

    protected override GeneratePropertyReferenceExpression (expression : CodePropertyReferenceExpression) : void
    {
      def targetObject = expression.TargetObject;
      when (targetObject != null) {
        GenerateExpression (targetObject);
        Output.Write ('.');
      }
      Output.Write (GetSafeName (expression.PropertyName));
    }

    protected override GeneratePropertySetValueReferenceExpression (_ : CodePropertySetValueReferenceExpression) : void
    {
      Output.Write ("value");
    }

    protected override GenerateThisReferenceExpression (_ : CodeThisReferenceExpression) : void
    {
      Output.Write ("this");
    }

    // FIXME: Is it allowed? It looks likely to be confused with
    // CodeMethodReturnStatement...
    protected override GenerateExpressionStatement (statement : CodeExpressionStatement) : void
    {
      GenerateExpression (statement.Expression);
      unless (dont_write_semicolon)
        Output.WriteLine (';');
    }

    protected override GenerateIterationStatement (statement : CodeIterationStatement) : void
    {
      def output = Output;

      output.Write("for (");
      dont_write_semicolon = true;
      GenerateStatement(statement.InitStatement);
      output.Write("; ");
      GenerateExpression(statement.TestExpression);
      output.Write("; ");
      GenerateStatement(statement.IncrementStatement);
      output.Write(") ");
      dont_write_semicolon = false;

      GenerateBlock(statement.Statements);
    }

    protected new GenerateStatements(c : CodeStatementCollection) : void
    {
      foreach (x is CodeStatement in c) GenerateStatement(x);
      when (c.Count > 0 && (c[c.Count - 1] is CodeVariableDeclarationStatement))
        match (BracingStyle) {
          | C | Block            => Output.WriteLine("();");
          | Indent | Implicit    => Output.WriteLine("()");
        }
    }

    protected override GenerateThrowExceptionStatement (statement : CodeThrowExceptionStatement) : void
    {
      Output.Write ("throw");
      when (statement.ToThrow != null) {
        Output.Write (' ');
        GenerateExpression (statement.ToThrow);
      }
      unless (dont_write_semicolon)
        Output.WriteLine (";");
    }

    protected override GenerateComment (comment : CodeComment) : void
    {
      def output = Output;
      def lines = comment.Text.Split ('\n');
      mutable first = true;
      foreach (line : string in lines) {
        if (comment.DocComment)
          output.Write ("///");
        else
          output.Write ("//");
        when (first) {
          output.Write (' ');
          first = false;
        }
        output.WriteLine (line);
      }
    }

    // FIXME: How should I represent return statement?
    protected override GenerateMethodReturnStatement (statement : CodeMethodReturnStatement) : void
    {
      def output = Output;

      when (statement.Expression != null)
        GenerateExpression (statement.Expression);
        
      unless (dont_write_semicolon)
        output.WriteLine (";");
    }

    protected override GenerateConditionStatement (statement : CodeConditionStatement) : void
    {
      def output = Output;

      def falses = statement.FalseStatements;

      if (falses.Count > 0)
        output.Write("if (");
      else
        output.Write("when (");

      GenerateExpression (statement.Condition);

      output.Write(") ");

      GenerateBlock (statement.TrueStatements,  false);

      if (falses.Count > 0) {
        if (this.Options.ElseOnClosing)
          output.Write(' ');
        else
          output.WriteLine ();
        output.Write ("else ");
        GenerateBlock (falses);
      }
      else
        output.WriteLine(); 
    }

    protected override GenerateTryCatchFinallyStatement (statement : CodeTryCatchFinallyStatement) : void
    {
      def output = Output;
      def options = this.Options;

      output.Write ("try");
      GenerateBlock (statement.TryStatements);

      when (statement.CatchClauses.Count > 0) {
        output.WriteLine ("catch");
        def bs = BracingStyle;
        OutputBlockStart (bs);
        ++Indent;
        foreach (clause is CodeCatchClause in statement.CatchClauses) {
          output.Write ("| ");
          OutputTypeNamePair (clause.CatchExceptionType,  GetSafeName (clause.LocalName));
          output.WriteLine (" =>");
          ++Indent;
          GenerateStatements (clause.Statements);
          --Indent;
        }
        --Indent;
        OutputBlockEnd (bs, false);
      }

      def finallies = statement.FinallyStatements;
      if (finallies.Count > 0) {
        if (options.ElseOnClosing)
          output.Write(' ');
        else
          output.WriteLine();
        output.Write("finally ");
        GenerateBlock (finallies);
      }
      else
        output.WriteLine();
    }

    protected override GenerateAssignStatement (statement : CodeAssignStatement) : void
    {
      def output = Output;
      GenerateExpression (statement.Left);
      output.Write (" = ");
      GenerateExpression (statement.Right);
      unless (dont_write_semicolon)
        output.WriteLine(';');
    }

    protected override GenerateAttachEventStatement (statement : CodeAttachEventStatement) : void
    {
      def output = Output;

      GenerateEventReferenceExpression (statement.Event);
      output.Write (" += ");
      GenerateExpression (statement.Listener);
      unless (dont_write_semicolon)
        output.WriteLine (';');
    }

    protected override GenerateRemoveEventStatement (statement : CodeRemoveEventStatement) : void
    {
      def output = Output;
      GenerateEventReferenceExpression (statement.Event);
      Output.Write (" -= ");
      GenerateExpression (statement.Listener);
      unless (dont_write_semicolon)
        output.WriteLine (';');
    }

    protected override GenerateGotoStatement (_ : CodeGotoStatement) : void
    {
      throw NotSupportedException ("Goto statement is not supported in Nemerle language.");
    }
    
    protected override GenerateLabeledStatement (_ : CodeLabeledStatement) : void
    {
      throw NotSupportedException ("Labeled statement is not supported in Nemerle language.");
    }

    protected override GenerateSnippetCompileUnit(e : CodeSnippetCompileUnit) : void
    {
      GenerateDirectives(e.StartDirectives);

      when (e.LinePragma != null)
        GenerateLinePragmaStart(e.LinePragma);
      
      Output.WriteLine(e.Value); // TODO : maybe special handling for some snippets (Nemerle-specific code)

      when (e.LinePragma != null)
        GenerateLinePragmaEnd(e.LinePragma);

      GenerateDirectives(e.EndDirectives);
    }

    protected override GenerateVariableDeclarationStatement (statement : CodeVariableDeclarationStatement) : void
    {
      def output = Output;

      output.Write ("mutable ");

      output.Write (GetSafeName (statement.Name));

      def initExpression = statement.InitExpression;
      if (initExpression != null) {
        output.Write(" = ");
        GenerateExpression(initExpression);
        match (initExpression) {
          | x is CodePrimitiveExpression =>
            when (x.Value == null)
            {
              Output.Write(" : ");
              OutputType(statement.Type);
            }
          | _ => ()
        }
      }
      else {
        if (statement.Type.ArrayElementType != null) {
          output.Write(" = ");
          output.Write(NullToken);
          output.Write(" : ");
          OutputType (statement.Type);
        }
        else 
          ()
      }
      unless (dont_write_semicolon)
        output.WriteLine(';');
    }

    protected override GenerateLinePragmaStart (linePragma : CodeLinePragma) : void
    {
      Output.WriteLine ();
      Output.Write ("#line ");
      Output.Write (linePragma.LineNumber);
      Output.Write (" \"");
      Output.Write (linePragma.FileName);
      Output.Write ("\"");
      Output.WriteLine ();
    }

    protected override GenerateLinePragmaEnd (_ : CodeLinePragma) : void
    {
      Output.WriteLine ();
      Output.WriteLine ("#line default");
    }

    protected override GenerateEvent (eventRef : CodeMemberEvent,  _declaration : CodeTypeDeclaration) : void
    {
      when (eventRef.CustomAttributes.Count > 0)
        OutputAttributeDeclarations(eventRef.CustomAttributes);

      OutputMemberAccessModifier (eventRef.Attributes);
      OutputMemberScopeModifier (eventRef.Attributes %| MemberAttributes.Final); // Don't output "virtual"
      Output.Write ("event ");
      OutputTypeNamePair (eventRef.Type,  GetSafeName (eventRef.Name));
      Output.WriteLine (';');
    }

    protected override GenerateField (field : CodeMemberField) : void
    {
      def output = Output;
      
      when (field.CustomAttributes.Count > 0)
        OutputAttributeDeclarations(field.CustomAttributes);
      
      if (IsCurrentEnum) {
        output.Write("| ");
        Output.Write(field.Name);
      }
      else
      {
        def attributes = field.Attributes;
        OutputMemberAccessModifier(attributes);
        OutputFieldScopeModifier(attributes);
        OutputTypeNamePair(field.Type,  GetSafeName(field.Name));
      }

      def initExpression = field.InitExpression;
      when (initExpression != null) {
        output.Write (" = ");
        GenerateExpression (initExpression);
      }

      if (!IsCurrentEnum)
        output.WriteLine(';');
      else
        output.WriteLine("");
    }

    protected override OutputFieldScopeModifier (attributes : MemberAttributes) : void
    {
      when (attributes %& MemberAttributes.VTableMask == MemberAttributes.New)
        Output.Write("new ");
      match (attributes & MemberAttributes.ScopeMask) {
        | MemberAttributes.Static =>
          Output.Write("static mutable ");
        | MemberAttributes.Const =>
          Output.Write("static ");
        | _ => 
          Output.Write("mutable ");
      }
    }

    // TODO: different signature from parent
    protected new OutputTypeAttributes (declaration : CodeTypeDeclaration) : void
    {
      def output = Output;
      def attributes = declaration.TypeAttributes;

      match (attributes & TypeAttributes.VisibilityMask) {
        | TypeAttributes.Public
        | TypeAttributes.NestedPublic =>
            output.Write ("public ");
        | TypeAttributes.NestedPrivate =>
            output.Write ("private ");
        | TypeAttributes.NotPublic
        | TypeAttributes.NestedFamANDAssem
        | TypeAttributes.NestedAssembly =>
            output.Write ("internal ");
        | TypeAttributes.NestedFamily =>
            output.Write ("protected ");
        | TypeAttributes.NestedFamORAssem =>
            output.Write ("protected internal ");
        | _ =>
            ();
      }

      match (declaration) {
        | d when d.IsStruct =>
          when (d.IsPartial) {
              output.Write ("partial ");
          }
          output.Write ("struct ");
        | d when d.IsEnum =>
          output.Write ("enum ");
        | _ =>
          if ((attributes & TypeAttributes.Interface) != 0) {
            when (declaration.IsPartial) {
                output.Write ("partial ");
            }
            output.Write ("interface ");
          } else {
            when ((attributes & TypeAttributes.Sealed) != 0)
                output.Write ("sealed ");
            when ((attributes & TypeAttributes.Abstract) != 0)
                output.Write ("abstract ");
            when (declaration.IsPartial) {
                output.Write ("partial ");
            }
            output.Write ("class ");
          }
      }
    }

    protected override GenerateSnippetMember (member : CodeSnippetTypeMember) : void
    {
      // TODO : maybe special handling for some snippets (Nemerle-specific code)
      Output.Write (member.Text);
    }

    protected override GenerateSnippetStatement (e : CodeSnippetStatement) : void
    {
      Output.Write(e.Value);
    }
    
    protected override GenerateEntryPointMethod (method : CodeEntryPointMethod,  declaration : CodeTypeDeclaration) : void
    {
      method.Name = "Main";
      GenerateMethod (method,  declaration);
    }

    protected override GenerateMethod (method : CodeMemberMethod,  declaration : CodeTypeDeclaration) : void
    {
      def output = Output;

      when (method.CustomAttributes.Count > 0)
        OutputAttributeDeclarations (method.CustomAttributes);

      when (method.ReturnTypeCustomAttributes.Count > 0)
        OutputAttributeDeclarations (method.ReturnTypeCustomAttributes);

      def attributes = method.Attributes;

      when (method.PrivateImplementationType == null && !declaration.IsInterface)
        OutputMemberAccessModifier (attributes);

      when (!declaration.IsInterface)
        OutputMemberScopeModifier (attributes);

      // we have to generate fresh name for method explicitly implementing
      // interface,  so there will be no collisions with other such methods
      def privateType = method.PrivateImplementationType;
      if (privateType != null)
      {
        output.Write(new_name());
        output.Write(GetSafeName(method.Name));
      }
      else
        output.Write(GetSafeName(method.Name));

      output.Write (' ');

      output.Write ('(');
      OutputParameters (method.Parameters);
      output.Write (')');

      output.Write (" : ");
      OutputType (method.ReturnType);

      if ((attributes %& MemberAttributes.ScopeMask) == MemberAttributes.Abstract 
           || declaration.IsInterface)
        output.WriteLine (';');
      else {
        when (privateType != null)
        {
          output.Write(" implements ");
          OutputType(privateType);
          output.Write (".");
          output.Write (GetSafeName (method.Name));
        }

        GenerateBlock (method.Statements);
      }
    }

    protected override GenerateProperty (property : CodeMemberProperty,  declaration : CodeTypeDeclaration) : void
    {
      def output = Output;

      when (property.CustomAttributes.Count > 0)
        OutputAttributeDeclarations(property.CustomAttributes);

      def attributes = property.Attributes;
      OutputMemberAccessModifier(attributes);
      OutputMemberScopeModifier(attributes);


      if (property.Name == "Item")
      {
        // indexer
        output.Write (GetSafeName (property.Name));
        output.Write (' ');
        output.Write("[");
        OutputParameters(property.Parameters);
        output.Write("]");
        output.Write (" : ");
        OutputType (property.Type);
      }
      else
      {
        OutputTypeNamePair(property.Type,  GetSafeName (property.Name));
      }

      def bs = BracingStyle;
      OutputBlockStart (bs);
      ++Indent;

      if (declaration.IsInterface)
      {
        when (property.HasGet) output.WriteLine("get;");
        when (property.HasSet) output.WriteLine("set;");
      }
      else
      {
        when (property.HasGet)
        {
          output.Write ("get");
          GenerateBlock (property.GetStatements);
        }

       when (property.HasSet)
        {
          output.Write ("set");
          GenerateBlock (property.SetStatements);
        }
      }

      --Indent;
      OutputBlockEnd (bs);
    }

    protected override GenerateConstructor(constructor : CodeConstructor,  _declaration : CodeTypeDeclaration) : void
    {
      when (constructor.CustomAttributes.Count > 0)
        OutputAttributeDeclarations(constructor.CustomAttributes);

      OutputMemberAccessModifier (constructor.Attributes);
      Output.Write ("this (");
      OutputParameters (constructor.Parameters);
      Output.Write (')');

      def bs = BracingStyle;
      OutputBlockStart (bs);
      ++Indent;
      when (constructor.ChainedConstructorArgs.Count > 0)
      {
        Output.Write("this (");
        mutable first = true;
        foreach (ex is CodeExpression in constructor.ChainedConstructorArgs)
        {
          when (!first)
            Output.Write(",  ");
          first = false;
          GenerateExpression(ex);
        }
        
        Output.Write(");");
      }
      when (constructor.BaseConstructorArgs.Count > 0)
      {
        Output.Write("base (");
        mutable first = true;
        foreach (ex is CodeExpression in constructor.BaseConstructorArgs)
        {
          when (!first)
            Output.Write(",  ");
          first = false;
          GenerateExpression(ex);
        }
        
        Output.WriteLine (");");
      }
      GenerateStatements (constructor.Statements);
      --Indent;
      OutputBlockEnd (bs);
    }
    
    protected override GenerateTypeConstructor (constructor : CodeTypeConstructor) : void
    {
      Output.Write ("static this ()");
      GenerateBlock (constructor.Statements);
    }

    protected new GenerateTypes (e : CodeNamespace) : void
    {
      def output = Output;
      def options = Options;

      foreach (typeDecl is CodeTypeDeclaration in e.Types)
      {
        when (options.BlankLinesBetweenMembers)
          output.WriteLine();
     
        (this:ICodeGenerator).GenerateCodeFromType(typeDecl,  (output :> IndentedTextWriter).InnerWriter,  options);
      }
    }

    protected override GenerateTypeStart (declaration : CodeTypeDeclaration) : void
    {
      def output = Output;

      when (declaration.CustomAttributes.Count > 0)
        OutputAttributeDeclarations (declaration.CustomAttributes);

      OutputTypeAttributes (declaration);

      output.Write (GetSafeName (declaration.Name));

      output.Write(' ');
      
      def enumerator = declaration.BaseTypes.GetEnumerator();
      when (enumerator.MoveNext()) {
        mutable ty = (enumerator.Current :> CodeTypeReference);
      
        output.Write(": ");
        OutputType(ty);
        
        while (enumerator.MoveNext()) {
          ty = enumerator.Current :> CodeTypeReference;
        
          output.Write(",  ");
          OutputType(ty);
        }

        output.Write(' ');
      }
      if (declaration is CodeTypeDelegate)
        output.Write ("(");
      else
        OutputBlockStart (BracingStyle);
      ++Indent;
    }

    protected override GenerateTypeEnd (declaration : CodeTypeDeclaration) : void
    {
      --Indent;
      if (declaration is CodeTypeDelegate) {
        Output.Write (") : ");
        def ty = (declaration :> CodeTypeDelegate).ReturnType;
        if (ty != null)
          OutputType (ty);
        else
          Output.Write ("void");
        Output.WriteLine (";");
      }
      else
        OutputBlockEnd (BracingStyle);
    }

    protected override GenerateNamespace (ns : CodeNamespace) : void
    {
      GenerateCommentStatements(ns.Comments);
      GenerateNamespaceStart(ns);
      GenerateNamespaceImports(ns);
      Output.WriteLine("");
      GenerateTypes(ns);
      GenerateNamespaceEnd(ns);
    }

    protected override GenerateNamespaceStart (ns : CodeNamespace) : void
    {
      def output = Output;
      
      def name = ns.Name;
      when (name != null && name != "") {
        output.Write("namespace ");
        output.Write(GetSafeName (name));
        OutputBlockStart (BracingStyle);
        ++Indent;
      }
    }

    protected override GenerateNamespaceEnd (ns : CodeNamespace) : void
    {
      def name = ns.Name;
      when (name != null && name != "") {
        --Indent;
        OutputBlockEnd (BracingStyle);
      }
    }

    protected override GenerateNamespaceImport (import : CodeNamespaceImport) : void
    {
      def output = Output;

      output.Write("using ");
      output.Write(GetSafeName (import.Namespace));
      output.WriteLine(';');
    }

    protected override GenerateAttributeDeclarationsStart (attributes : CodeAttributeDeclarationCollection) : void
    {
      Output.Write('[');

      match (CurrentMember) {
        | met is CodeMemberMethod when
          met.ReturnTypeCustomAttributes == (attributes : object) =>
          Output.Write ("return: ");

          def enumerator = attributes.GetEnumerator();
          while (enumerator.MoveNext())
          {
            def attribute = (enumerator.Current :> CodeAttributeDeclaration);
            attribute.Name = attribute.Name.Replace('+',  '.');
          }
        | _ => ()
      }
    }

    protected override GenerateAttributeDeclarationsEnd (_ : CodeAttributeDeclarationCollection) : void
    {
      Output.WriteLine(']');
    }

    protected override OutputType (ty : CodeTypeReference) : void
    {
      Output.Write (GetTypeOutput(ty));
    }

    protected override OutputTypeNamePair (ty : CodeTypeReference,  name : string) : void
    {
      Output.Write (GetSafeName (name));
      Output.Write (" : ");
      Output.Write (GetTypeOutput (ty));
    }

    protected override OutputAttributeArgument (arg : CodeAttributeArgument) : void
    {
      def output = Output;
      when ((arg.Name != null) && (arg.Name.Length > 0))
      {
        OutputIdentifier(arg.Name);
        output.Write("=");
      }
      (this:ICodeGenerator).GenerateCodeFromExpression(arg.Value,  (output :> IndentedTextWriter).InnerWriter,  Options);
    }

    protected override OutputAttributeDeclarations (attributes : CodeAttributeDeclarationCollection) : void
    {
      when (attributes.Count != 0)
      {
        def output = Output;
        GenerateAttributeDeclarationsStart (attributes);

        mutable first1 = true;
        foreach (attrDecl is CodeAttributeDeclaration in attributes)
        {
          if (first1)
            first1 = false;
          else
            output.Write (",  ");

          output.Write (attrDecl.Name);
          when (attrDecl.Arguments.Count != 0)
          {
            output.Write ("(");
            mutable first2 = true;
            foreach (attrArg is CodeAttributeArgument in attrDecl.Arguments)
            {
              if (first2)
                first2 = false;
              else
                output.Write(",  ");
              OutputAttributeArgument (attrArg);
            }
            output.Write(")");
          }
        }
        GenerateAttributeDeclarationsEnd (attributes);
      }
    }
  
    protected override OutputMemberAccessModifier (attributes : MemberAttributes) : void
    {
      def output = Output;
      
      match (attributes %& MemberAttributes.AccessMask)
      {
        | MemberAttributes.Public => 
          output.Write("public ");

        | MemberAttributes.Private => 
          output.Write("private ");

        | MemberAttributes.Family => 
          output.Write("protected ");

        | MemberAttributes.Assembly | MemberAttributes.FamilyAndAssembly => 
          output.Write("internal ");

        | MemberAttributes.FamilyOrAssembly => 
          output.Write("protected internal ");

        | other =>
          unless (other :> int == 0)
            throw NotSupportedException("Unsupported access attribute");
      }
    }

    protected override OutputMemberScopeModifier(attributes : MemberAttributes) : void
    {
      def output = Output;

      when (attributes %&& MemberAttributes.New)
        output.Write("new ");
      
      match (attributes %& MemberAttributes.ScopeMask)
      {
        | MemberAttributes.Abstract => 
          output.Write("abstract ");

        | MemberAttributes.Final => 
          () // Suppress `virtual' modifier.

        | MemberAttributes.Static => // TODO: is static mutually exclusive with other flags?
          output.Write("static ");

        | MemberAttributes.Override => 
          output.Write("override ");

        | _ =>
          match (attributes %& MemberAttributes.AccessMask)
          {
            | MemberAttributes.Private =>
              () // `private virtual' modifier is supported by the CLI, but is not supported by the compiler.
            | _ =>
              output.Write("virtual ");
          }
      }
    }

    protected override OutputIdentifier (ident : string) : void
    {
      Output.Write(ident);
    }

    protected override OutputParameters (parameters : CodeParameterDeclarationExpressionCollection) : void
    {
      mutable first = true;
      def isManyParams = parameters.Count > 15; // TODO: maybe this should be regulated by settings

      when (isManyParams)
        Indent += 3;

      foreach (e is CodeParameterDeclarationExpression in parameters)
      {
        if (first)
          first = false;
        else
          Output.Write(",  ");

        when (isManyParams)
          ContinueOnNewLine("");

        GenerateExpression(e);
      }

      when (isManyParams)
        Indent -= 3;
    }

    protected override QuoteSnippetString (value : string) : string
    {
      // FIXME: this is weird,  but works.
      mutable output = value.Replace ("\\",  "\\\\");
      output = output.Replace ("\"",  "\\\"");
      output = output.Replace ("\t",  "\\t");
      output = output.Replace ("\r",  "\\r");
      output = output.Replace ("\n",  "\\n");

      "\"" + output + "\"";
    }

    protected override GenerateParameterDeclarationExpression (e : CodeParameterDeclarationExpression) : void
    {
      when (e.CustomAttributes != null && e.CustomAttributes.Count > 0)
        OutputAttributeDeclarations (e.CustomAttributes);
      Output.Write (GetSafeName (e.Name));
      Output.Write (" : ");
      OutputDirection(e.Direction);
      OutputType (e.Type);
    }

    protected override GeneratePrimitiveExpression (e : CodePrimitiveExpression) : void
    {
      match (e.Value)
      {
        | null => Output.Write(NullToken);
        | v is string =>
          Output.Write(QuoteSnippetString(v));
        | v is char =>
          Output.Write("'" + v.ToString() + "'");
        | v is byte =>
          Output.Write(v.ToString(CultureInfo.InvariantCulture));
        | v is short =>
          Output.Write(v.ToString(CultureInfo.InvariantCulture));
        | v is int =>
          Output.Write(v.ToString(CultureInfo.InvariantCulture));
        | v is long =>
          Output.Write(v.ToString(CultureInfo.InvariantCulture));
        | v is float =>
          GenerateSingleFloatValue(v);
        | v is double =>
          GenerateDoubleValue(v);
        | v is decimal =>
          GenerateDecimalValue(v);
        | v is bool =>
          Output.Write(if(v) "true" else "false"); 
        | v => 
          throw ArgumentException($"InvalidPrimitiveType: $(v.GetType().ToString())");
      }
    }

    protected override GenerateTypeOfExpression (e : CodeTypeOfExpression) : void
    {
      Output.Write ("typeof(");
      OutputType (e.Type);
      Output.Write (")");
    }

    protected GenerateBlock (statements : CodeStatementCollection,  endLastLine : bool = true) : void
    {
      def bs = BracingStyle;
      OutputBlockStart (bs);

      ++Indent;
      GenerateStatements (statements);
      --Indent;

      OutputBlockEnd (bs,  endLastLine);
    }

    protected OutputBlockStart (bs : BracingType) : void
    {
      | C                 => Output.WriteLine(" {");
      | Block | Implicit  => { Output.WriteLine(); Output.WriteLine('{'); }
      | Indent            => ()
    }

    protected OutputBlockEnd (bs : BracingType,  endLastLine : bool = true) : void
    {
      match (bs) {
        | C                 => if (endLastLine) Output.WriteLine('}') else Output.Write('}');
        | Block | Implicit  => Output.WriteLine('}');
        | Indent            => () //Output.WriteLine(); //TODO
      }
    }

    protected override OutputOperator (op : CodeBinaryOperatorType) : void
    {
      | Add                => Output.Write("+");
      | Subtract           => Output.Write("-");
      | Multiply           => Output.Write("*");
      | Divide             => Output.Write("/");
      | Modulus            => Output.Write("%");
      | Assign             => Output.Write("=");
      | IdentityInequality => Output.Write("!=");
      | IdentityEquality   => Output.Write("==");
      | ValueEquality      => Output.Write("==");
      | BitwiseOr          => Output.Write("|");
      | BitwiseAnd         => Output.Write("&");
      | BooleanOr          => Output.Write("||");
      | BooleanAnd         => Output.Write("&&");
      | LessThan           => Output.Write("<");
      | LessThanOrEqual    => Output.Write("<=");
      | GreaterThan        => Output.Write(">");
      | GreaterThanOrEqual => Output.Write(">=");
    }

    protected override OutputExpressionList (expressions : CodeExpressionCollection,  newlineBetweenItems : bool) : void
    {
      def output = Output;
      def options = Options;

      mutable first = true;
      Indent++;
      foreach (e is CodeExpression in expressions)
      {
        if (first)
          first = false;
        else if (newlineBetweenItems)
          ContinueOnNewLine(", ");
        else
          output.Write(",  ");
        (this:ICodeGenerator).GenerateCodeFromExpression(e,  (output :> IndentedTextWriter).InnerWriter,  options);
      }
      Indent--;
    }

    protected override OutputDirection (dir : FieldDirection) : void
    {
      | In  => ()
      | Out => Output.Write("out ");
      | Ref => Output.Write("ref ");
    }

    protected override ContinueOnNewLine(st : string) : void
    {
      Output.WriteLine(st);
    }

    /* 
     * ICodeGenerator
     */
    protected override CreateEscapedIdentifier (value : string) : string
    {
      when (value == null)
        throw NullReferenceException ("Argument identifier is null.");
      GetSafeName (value);
    }

    protected override CreateValidIdentifier (value : string) : string
    {
      when (value == null)
        throw NullReferenceException ();

      when (keywordsTable == null)
        FillKeywordTable ();

      if (keywordsTable.Contains (value) || typesTable.Contains (value))
        "_" + value;
      else
        value;
    }

    protected override GetTypeOutput (ty : CodeTypeReference) : string
    {
      def arrayType = ty.ArrayElementType;
      def output =
        if (arrayType != null)
          "array["
          + (if (ty.ArrayRank > 1) { ty.ArrayRank.ToString () + ",  " } else "")
          + GetTypeOutput (arrayType) + "]"
        else match (ty.BaseType.ToLower(System.Globalization.CultureInfo.InvariantCulture))
        {
          | "system.decimal" => "decimal";
          | "system.double"  => "double";
          | "system.single"  => "float";
          | "system.byte"    => "byte";
          | "system.sbyte"   => "sbyte";
          | "system.int32"   => "int";
          | "system.uint32"  => "uint";
          | "system.int64"   => "long";
          | "system.uint64"  => "ulong";
          | "system.int16"   => "short";
          | "system.uint16"  => "ushort";
          | "system.boolean" => "bool";
          | "system.char"    => "char";
          | "system.string"  => "string";
          | "system.object"  => "object";
          | "system.void"    => "void";
          | _ => {
            def expandGenerics(r : CodeTypeReference) : string
            {
                def trimApostroph(s : string)
                {
                  def index = s.IndexOf("`");
                  if (index != -1)
                    s.Substring(0,index);
                  else
                    s;
                }

                def init =  trimApostroph(r.BaseType.Trim());

                if (r.TypeArguments.Count == 0)
                  init;
                else
                {
                  def typeArgs = array(r.TypeArguments.Count);
                  r.TypeArguments.CopyTo(typeArgs, 0);
                  $<#$init.[..$(typeArgs; ", "; expandGenerics)]#>
                }
            }
            GetSafeTypeName(expandGenerics(ty));
        }
     };

      output.Replace ("+",  ".");
    }

    protected override IsValidIdentifier (identifier : string) : bool
    {
      when (keywordsTable == null)
        FillKeywordTable ();

      !keywordsTable.Contains (identifier) && !typesTable.Contains (identifier);
    }

    protected override Supports (supports : GeneratorSupport) : bool
    {
      | GeneratorSupport.Win32Resources => false;
      | GeneratorSupport.GotoStatements => false;
      | _ => true;
    }

    static GetSafeName (id : string) : string
    {
      when (keywordsTable == null) {
        FillKeywordTable ();
      }
      if (keywordsTable.Contains (id) || typesTable.Contains (id))
        "@" + id;
      else
        id;
    }

    static GetSafeTypeName (id : string) : string
    {
      when (keywordsTable == null)
        FillKeywordTable ();

      if (keywordsTable.Contains (id)) "@" + id else id;
    }

    static FillKeywordTable () : void
    {
      keywordsTable = Hashtable ();
      foreach (keyword : string in keywords) keywordsTable.Add (keyword, keyword);
      typesTable = Hashtable ();
      foreach (ty : string in types) typesTable.Add (ty, ty);
    }

    static mutable typesTable : Hashtable;
    static types : array[string] = array [
      "object", "bool", "byte", "float", "uint", "char", "ulong", "ushort", 
      "decimal", "int", "sbyte", "short", "double", "long", "string", "void"
    ];

    static mutable keywordsTable : Hashtable;
    static keywords : array[string] = array[
      "abstract",  "and",  "array",  "as",  "base",  "catch",  "class",  "def",
      "delegate",  "do",  "else",  "enum",  "event",  "extends",  "extern",
      "false",  "finally",  "for",  "foreach",  "fun",  "if",  "implements",
      "in",  "interface",  "internal",  "lock",  "macro",  "match",  "module",
      "mutable",  "namespace",  "new",  "null",  "out",  "override",  "params",
      "private",  "protected",  "public",  "ref",  "sealed",  "static",  "struct",
      "syntax",  "this",  "throw",  "true",  "try",  "type",  "typeof",  "unless",
      "using",  "variant",  "virtual",  "void",  "when",  "where",  "while",
      "assert",  "abort",  "ignore"
    ];
  }
}
