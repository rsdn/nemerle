(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.CGexpr;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

module CGexpr {
  mutable cg_members : System.Collections.Hashtable;
  
  lookup_field (decl : IField) : CM_field {
    def result = (cg_members [decl.GetId ()] :> CM_field);
    
    if (result == null) {
      def ty = decl.GetMemType ();
      def m = (CM_field (Tyutil.encode_type_to_string (ty), cg_type (ty)) :> CM_field);
      m.name <- decl.GetName ();
      m.extern_name <- decl.GetDeclaringTycon ().GetFullName () + "." + decl.GetName ();
      m.attrs <- cg_attrs (decl.GetModifiers ());
      m.modifiers <- decl.GetModifiers ();
      cg_members.Add (decl.GetId (), m);
      m
    }
    else result
  }

  lookup_property (decl : IProperty) : CM_property {
    def result = (cg_members [decl.GetId ()] :> CM_property);
    
    if (result == null) {
      def ty = decl.GetMemType ();
      def m = (CM_property (cg_type (ty)) :> CM_property);
      m.name <- decl.GetName ();
      m.extern_name <- decl.GetDeclaringTycon ().GetFullName () + "." + decl.GetName ();
      m.attrs <- cg_attrs (decl.GetModifiers ());
      m.modifiers <- decl.GetModifiers ();
      cg_members.Add (decl.GetId (), m);
      m
    }
    else result
  }

  lookup_function (h : Fun_header) : CM_method {
    def result = (cg_members [h.id] :> CM_method);
    
    if (result == null) {
      def m = cg_header (h);
      cg_members.Add (h.id, m);
      m
    }
    else result
  }

  lookup_function (h : Fun_header, ti : Tycon) : CM_method {
    def result = (cg_members [h.id] :> CM_method);

    if (result == null) {
      def m = cg_header (h);
      m.extern_name <- ti.GetFullName () + "." + m.name;
      cg_members.Add (h.id, m);
      m
    }
    else result
  }

  lookup_class (ti : Tycon) : CM_class {
    def result = (cg_members [ti.GetId ()] :> CM_class);

    if (result == null) {
      def inh = List.map (cg_type, ti.GetDirectSuperTypes ());
      def r = (CM_class ("", CK_class (), inh, [], None (), None ()) :> CM_class);
      r.loc <- ti.GetLocation ();
      r.name <- ti.GetName ();
      r.extern_name <- ti.GetFullName ();
      r.attrs <- cg_attrs (ti.GetModifiers ());
      r.modifiers <- ti.GetModifiers ();
      cg_members.Add (ti.GetId (), r);
      r
    }
    else result
  }
    
  cg_type (t : Type) : CG_type {
    match (Tyutil.top_expand (t)) {
      | T_void => CT_void ()
      | T_prod (l) => CT_tuple (List.length (l))
      | T_fun (args, _) => CT_fun (List.length (Tyutil.fun_args (args)))
      | T_var (tv) =>
        match (Tyvar.constraints (tv)) {
          | [] => CT_object ()
          | t :: _ => cg_type (t)
        }
      | T_app (ti, _) => 
        match (ti.GetFullName ()) {
          | "System.Object" | "object" => CT_object ()
          | x => CT_ref (x)
        }
      | T_ref => Util.ice ("FIXME: cg ref")
      | T_out => Util.ice ("FIXME: cg out")
      | T_array (at) => CT_array (cg_type (at))
    }
  }

  mutable closures : list (CG_member);

  class CTX
    {
      public mutable current_fun : Fun_header;
      public mutable current_closure : option (CG_val);
      public mutable closure_fields : Int_map (CM_field);
      public mutable closure_ptrs : Int_map (CM_field);
      public mutable locals : Int_map (CG_val);
      public mutable current_type : Tyinfo;
    }

  copy_ctx (c : CTX) : CTX {
    CTX (current_fun = c.current_fun,
         current_closure = c.current_closure,
         closure_fields = c.closure_fields,
         closure_ptrs = c.closure_ptrs,
         locals = c.locals,
         current_type = c.current_type)
  }

  empty_ctx (ti : Tyinfo) : CTX {
    CTX (current_fun = null,
         current_closure = None (),
         closure_fields = Map.int_map (),
         closure_ptrs = Map.int_map (),
         locals = Map.int_map (),
         current_type = ti)
  }

  store_in_closure (ctx : CTX, d : Decl, val : CG_expr) : CG_expr
    {
      def rf = CE_field_ref (CE_ref (Option.unsome (ctx.current_closure)),
                             ctx.closure_fields.get (d.id));
      CE_assign (rf, val);
    }

  store_local (ctx : CTX, d : Decl, val : CG_expr) : CTX * CG_val {
    if (d.in_closure) {
      def assign = store_in_closure (ctx, d, val);
      def cgv = CG_val (loc = d.loc, 
                        name = Util.tmpname ("dummy"),
                        ty = CT_void (), 
                        val = assign,
                        local_slot = null);
      (copy_ctx (ctx), cgv)
    } else {
      def cgv = CG_val (loc = d.loc, 
                        name = decl_uniq_name(d), 
                        ty = cg_type (d.ty), 
                        val = val,
                        local_slot = null);
      def ctx' = copy_ctx (ctx);
      ctx'.locals <- ctx.locals.add (d.id, cgv);
      (ctx', cgv)
    }
  }

  closure_ref (ctx : CTX, fn : Fun_header) : CG_expr {
    if (ctx.current_fun.id == fn.id)
      CE_ref (Option.unsome (ctx.current_closure))
    else
      CE_field_ref (CE_this (), ctx.closure_ptrs.get (fn.id))
  }

  null_value (t : CG_type) : CG_expr {
    match (t) {
      | CT_bool => CE_literal (L_bool (false))
      | CT_ref (n) =>
        if (n == "int" || n == "System.Int32") CE_literal (L_int (0))
        else if (n == "char" || n == "System.Char") CE_literal (L_char ((0 :> char)))
        else if (n == "bool" || n == "System.Boolean") CE_literal (L_bool (false))
        else if (n == "float" || n == "System.Single" || n == "System.Double") CE_literal (L_int (0)) // FIXME ?
        else CE_literal (L_null ())
      | _ => CE_literal (L_null ())
    }
  }

  cg_pattern (ctx : CTX, val : CG_expr, pats : list (Pattern * Expr)) : CG_expr * bool * CTX * list (CG_val)
    {
      mutable vals <- Map.int_map ();
      mutable rctx <- ctx;
      mutable always_matches <- true;
      
      def cgpat (val : CG_expr, pat : Pattern) : CG_expr {
        match (pat) {
          | P_underscore => CE_literal (L_bool (true))
          
          | P_as (subpat, d) =>
            if (d.in_closure) ()
            else
              match (vals.find (d.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, d, null_value (cg_type (d.ty)));
                  rctx <- ctx;
                  vals <- vals.add (d.id, v);
              };
            def ass = CE_assign (local_ref (rctx, d), maybe_cast (d.ty, val));
            match (subpat) {
              | P_cons =>
                match (cgpat (val, subpat)) {
                  | CE_if (t, c, e_then, e_else) =>
                    CE_if (t, c, CE_sequence ([ass; e_then]), e_else)
                  | _ => Util.ice ()
                }
              | _ =>
                CE_sequence ([ass; cgpat (val, subpat)])
            }
            
          | P_tuple (args) =>
            def len = List.length (args);
            def f (acc, arg)
              {
                def (pos, ex) = acc;
                def cond = cgpat (CE_tuple_ref (CE_cast (val, CT_tuple (len)), pos), arg);
                (pos - 1, CE_if (CT_bool (), cond, ex, CE_literal (L_bool (false))))
              };
            def ini = (len - 1, CE_literal (L_bool (true)));
            def (_, ex) = List.fold_left (f, ini, List.rev (args));
            ex

          | P_literal (lit) =>
            // FIXME: cache it
            def aliases = Env.LookupInternalType ("Nemerle.Core.Aliases");
            def eq = 
              match (aliases.LookupMember ("==", LF_static ())) {
                | [x] =>
                  match (x.GetKind ()) {
                    | MK_method (m) => lookup_function (m.GetHeader ())
                    | _ => Util.ice ()
                  }
                | _ => Util.ice ()
              };
            def litexpr = CE_literal (lit);
            CE_call (CE_global_ref (eq), [CE_cast (val, CGflat.type_of (litexpr)); litexpr])
            
          | P_record (args) =>
            def val = CE_cast (val, cg_type (pat.ty));
            def f (ex, np) {
              def (name, pat) = np;
              def cond = cgpat (CE_field_ref (val, lookup_field (name)), pat);
              CE_if (CT_bool (), cond, ex, CE_literal (L_bool (false)))
            };
            List.fold_left (f, CE_literal (L_bool (true)), List.rev (args))
          
          | P_cons (n, a) =>
            always_matches <- false;
            def tyname = CT_ref (n.GetFullName ());
            def ex = CE_has_type (val, tyname);
            CE_if (CT_bool (), ex, cgpat (CE_cast (val, tyname), a), CE_literal (L_bool (false)))
        }
      };

      mutable global_always_matches <- false;

      def loop (pats) {
        match (pats) {
          | (pat, expr) :: rest =>
            always_matches <- true;
            def cond = cgpat (val, pat);
            def cond =
              match (expr) {
                | E_literal (L_bool (true)) => cond
                | _ =>
                  always_matches <- false;
                  CE_if (CT_bool (), cond, cg_expr (rctx, expr), CE_literal (L_bool (false)))
              };
            global_always_matches <- global_always_matches || always_matches;
            CE_if (CT_bool (), cond, CE_literal (L_bool (true)), loop (rest))
          | [] =>
            CE_literal (L_bool (false))
        }
      };

      def r = loop (pats);
      def collect_vals (acc : list (CG_val), _ : int, v : CG_val) : list (CG_val) { v :: acc };
      (r, global_always_matches, rctx, vals.fold (collect_vals, []))
    }

  cg_match (t : CG_type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr {
    match (mcs) {
      | [] =>
        // FIXME: cache it
        def match_failure = 
          lookup_class (Env.LookupInternalType ("Nemerle.Core.Match_failure"));
        CE_raise (CE_call (CE_default_ctor_ref (match_failure), []))

      | m :: ms =>
        def (cond, always_matches, ctx', vals) = cg_pattern (ctx, val, m.patterns);
        def mklet (acc : CG_expr, v : CG_val) : CG_expr { CE_let (v, acc) };
        def then_part = cg_expr (ctx', m.body);
        def else_part = cg_match (t, ctx, val, ms);
        List.fold_left (mklet, CE_if (t, cond, then_part, else_part), vals)
    }
  }

  mutable lambda_proxies : Int_map (CM_class);

  global_ref (ctx : CTX, m : IMember) : CG_expr {
    match (m.GetKind ()) {
      | MK_type => Util.ice ()

      | MK_field (f) =>
        def f = lookup_field (f);
        CE_global_ref (f)

      | MK_property (f) =>
        def f = lookup_property (f);
        CE_global_ref (f)
        
      | MK_method (f) =>
        when (lambda_proxies == null) { lambda_proxies <- Map.int_map () };
        def lc =
          match (lambda_proxies.find (f.GetId ())) {
            | Some (lc) => lc
            | None =>
              def lc = make_lambda_class (ctx, f.GetHeader ());
              def mkparm (v : CG_val) {
                def t = v.ty;
                v.ty <- CT_object ();
                CE_cast (CE_ref (v), t)
              };
              def header = f.GetHeader ();
              def fn = cg_header (header);
              def fun_ref = CE_global_ref (lookup_function (header));
              fn.body <- CE_call (fun_ref, List.map (mkparm, fn.parms));
              lc.decls <- [(fn : CG_member)];
              
              match (header.parms) {
                | [_] => ()
                | _ =>
                  def parm = 
                    CG_val (loc = Location_stack.top (),
                            name = "_N_tupled",
                            ty = CT_object (),
                            val = CE_none (),
                            local_slot = null);
                  mutable pos <- -1;
                  def parm' = CE_cast (CE_ref (parm), CT_tuple (List.length (header.parms)));
                  def mktparm (p : Fun_parm) {
                    pos <- pos + 1;
                    CE_cast (CE_tuple_ref (parm', pos), cg_type (p.ty));
                  };
                  def body = CE_call (fun_ref, List.map (mktparm, header.parms));
                  
                  // extract the parameter types, build the the new function encoded type
                  def extract_parm_types (parms : list (Fun_parm)) : list (Type) {
                    match (parms) {
                      | [] => []
                      | parm :: rest => parm.ty :: extract_parm_types (rest)
                    }                     
                  };
                  def fun_type = 
                    T_fun (T_prod (extract_parm_types (header.parms)), 
                           Tyutil.make_tapp ("System.Object"));
                    
                  def meth = CM_method (encoded_type = Tyutil.encode_type_to_string (fun_type),
                                        parms = [parm],
                                        ret_type = CT_object (),
                                        body = body,
                                        ctor_builder = None ());
                  meth.name <- "apply";
                  meth.attrs <- ["public"];
                  lc.decls <- meth :: lc.decls
              };
              
              lc.extern_name <- lc.name;
              fn.name <- "apply";
              fn.attrs <- ["public"];
              fn.ret_type <- CT_object ();
              closures <- (lc : CG_member) :: closures;
              lambda_proxies <- lambda_proxies.add (f.GetId (), lc);
              lc
          };
        CE_call (CE_default_ctor_ref (lc), [])
    }
  }

  local_ref (ctx : CTX, d : Decl) : CG_expr {
    if (d.in_closure) {
      def defined_in = Option.unsome (d.parent_fun);
      CE_field_ref (closure_ref (ctx, defined_in), 
                    ctx.closure_fields.get (d.id))
    } else if (ctx.locals.mem (d.id)) {
        CE_ref (ctx.locals.get (d.id))
    } else {
      Message.debug ("undef " + d.name + " = " + string_of_int (d.id));
      Util.ice ("ref to undef val " + d.name)
    }
  }

  maybe_cast (needed_type : Type, ex : CG_expr) : CG_expr {
    match ((CGflat.type_of (ex), cg_type (needed_type))) {
      | (CT_object, CT_object) => ex
      | (CT_object, t) => CE_cast (ex, t)
      | (CT_ref (n1), CT_ref (n2)) =>
        if (n1 == n2) ex else CE_cast (ex, CT_ref (n2))
      | _ => CE_cast (ex, cg_type (needed_type)) // FIXME: Micha³, I've added this instead of just ex
    }
  }

  get_fn_header (fn : Decl) : Fun_header {
    match (fn.kind) {
      | D_local_fun (h, _) => h
      | _ => Util.ice ()
    }
  }

  raw_cg_expr (ctx : CTX, inex : Expr) : CG_expr
    {
      def self (e : Expr) : CG_expr { cg_expr (ctx, e) };
      match (inex) {
        | E_local_ref (d) => 
          local_ref (ctx, d)

        | E_static_ref (d) => 
          global_ref (ctx, d)

        | E_field_ref (o, f) =>
          maybe_cast (inex.expr_ty, CE_field_ref (self (o), lookup_field (f)))

        | E_property_ref (o, p) =>
          maybe_cast (inex.expr_ty, CE_property_ref (self (o), lookup_property (p)))

        | E_method_ref => Util.ice ()

        | E_call (f, ps) =>
          def mkp (p : Parm) : CG_expr { self (p.expr) };
          def plain_call () : CG_expr {
            def len = List.length (ps);
            // FIXME: cache it
            def iface_type = Env.LookupInternalType ("Nemerle.Func" + string_of_int (len));
            def get_header (m : IMember) : option (Fun_header) {
              match (m.GetKind ()) {
                | MK_method (m) =>
                  def h = m.GetHeader ();
                  if (List.length (h.parms) == len) Some (h)
                  else None ()
                | _ => Util.ice ()
              }
            };
            def header =
              match (iface_type.LookupMember ("apply", LF_instance ())) {
                | [x1; x2] =>
                  match ((get_header (x1), get_header (x2))) {
                    | (Some (h), None) => h
                    | (None, Some (h)) => h
                    | _ => Util.ice ()
                  }
                | [x] => Option.unsome (get_header (x))
                | _ => Util.ice ()
              };
            CE_method_ref (self (f), lookup_function (header))
          };
          def callable =
            match (f) {
              | E_static_ref (m) =>
                match (m.GetKind ()) {
                  | MK_method (m) =>
                    match (m.GetFunKind ()) {
                      | FK_ctor =>
                        CE_ctor_ref (lookup_class (m.GetDeclaringTycon ()),
                                     lookup_function (m.GetHeader (), m.GetDeclaringTycon ()))
                      | _ =>
                        CE_global_ref (lookup_function (m.GetHeader (), m.GetDeclaringTycon ()))
                    }
                  | _ => plain_call ()
                }
              | E_method_ref (o, m) => 
                CE_method_ref (self (o), lookup_function (m.GetHeader ()))
              | E_base (ti) =>
                CE_base (lookup_class (ti))
              | E_local_ref (d) =>
                match (d.kind) {
                  | D_local_fun (h, _) when h.id == ctx.current_fun.id =>
                    CE_method_ref (CE_this (), lookup_function (h))
                  | _ => plain_call ()
                }
              | _ => plain_call ()
            };
          maybe_cast (inex.expr_ty, CE_call (callable, List.map (mkp, ps)))

        | E_assign (e1, e2) =>
          CE_assign (self (e1), self (e2))
          
        | E_mkarray (initializers) =>
          CE_mkarray (List.map (self, initializers))

        | E_indexer (ty, obj, args) =>
          CE_indexer (cg_type (ty), self (obj), List.map (self, args));

        | E_let (d, v, b) =>
          def (ctx', cgv) = store_local (ctx, d, self (v));
          CE_let (cgv, cg_expr (ctx', b))

        | E_letfun (fs, body) =>
          mutable l <- [];
          def store (ctx : CTX, f : Function_decl) : CTX {
            def cl = make_lambda_class (ctx, get_fn_header (f.decl));
            def ct = make_lambda_ctor (ctx, f.decl, cl);
            def (ctx, val) = store_local (ctx, f.decl, ct);
            l <- (val, cl) :: l;
            ctx
          };

          def ctx = List.fold_left (store, ctx, fs);
          
          def fill (f : Function_decl, acc : CG_val * CM_class) : void 
            {
              def (val, cl) = acc;
              closures <- (cl : CG_member) :: closures;
              fill_lambda_class (ctx, f.decl, f.body, cl)
            };

          List.iter2 (fill, fs, List.rev (l));

          def mklet (acc : CG_expr, x : CG_val * CM_class) : CG_expr
            {
              def (val, cl) = x;
              CE_let (val, acc)
            };

          List.fold_left (mklet, cg_expr (ctx, body), l)

        | E_match (e, mcs) =>
          def v =
            CG_val (loc = e.loc, 
                    name = Util.tmpname ("matched_value"),
                    ty = cg_type (e.expr_ty), 
                    val = cg_expr (ctx, e),
                    local_slot = null);
          CE_let (v, cg_match (cg_type (inex.expr_ty), ctx, CE_ref (v), mcs))

        | E_raise (e) =>
          CE_raise (cg_expr (ctx, e))

        | E_try_with (body, exn, handler) =>
          def body = cg_expr (ctx, body);
          // FIXME: this is broken for exn values to go into closure
          def (ctx', v) = store_local (ctx, exn, CE_none ());
          def handler = cg_expr (ctx', handler);
          CE_try_with (body, v, handler)

        | E_try_finally (e1, e2) =>
          CE_try_finally (cg_expr (ctx, e1), cg_expr (ctx, e2))

        | E_literal (l) => 
          CE_literal (l)

        | E_this => 
          CE_this ()

        | E_type_conversion (e, t) => 
          CE_cast (cg_expr (ctx, e), cg_type (t))

        | E_type_enforcement (e, _) =>
          cg_expr (ctx, e)

        | E_sequence (e1, e2) =>
          CE_sequence ([cg_expr (ctx, e1); cg_expr (ctx, e2)])

        | E_tuple (l) =>
          CE_tuple_ctor (List.map (self, l))

        | E_base =>
          Util.ice ("stray base")
      }
    }

  (** 
   * Flatten given [Typedtree.Expr] object into [CG_expr].
   *
   * <remarks>
   *   As a side-effect few classes for closures and local functions
   *   can be generated and stored in [closures] stack.
   * </remarks>
   *)
  cg_expr (ctx : CTX, ex : Expr) : CG_expr {
    Util.locate (ex.loc, fun () {
        def e = raw_cg_expr (ctx, ex);
        e.loc <- ex.loc;
        e
      })
  }

  fixup_function (f : IMethod) : CM_method
    {
      def m = lookup_function (f.GetHeader ());
      m.attrs <- cg_attrs (f.GetModifiers ());
      m.modifiers <- f.GetModifiers ();
      m.encoded_type <- Tyutil.encode_type_to_string (f.GetMemType ());
      def ti = f.GetDeclaringTycon ();
      match (f.GetFunKind ()) {
        | FK_bound_method => ()
        | FK_method => Util.ice ()
        | FK_static_ctor => 
          m.name <- ti.GetName ();
          m.ret_type <- CT_unreached ();
          m.attrs <- ["static"]
        | FK_ctor => 
          m.name <- ti.GetName ();
          m.ret_type <- CT_unreached ()
        | FK_function => ()
        | FK_iface_method => Util.ice ()
      };
      m
    }

  mangle (s : string) : string {
    def p = s.ToCharArray ();
    
    for (mutable i <- 0; i < (p : System.Array).Length; i <- i + 1)
      unless ((p[i] >= 'a' && p[i] <= 'z') ||
              (p[i] >= 'A' && p[i] <= 'Z') ||
              (p[i] >= '0' && p[i] <= '9'))
        p[i] <- '_';

    System.String (p)
  }

  fun_uniq_name (h : Fun_header) : string {
    mangle (h.name) + "_" + string_of_int (h.id)
  }

  decl_uniq_name (d : Decl) : string {
    mangle (d.name) + "_" + string_of_int (d.id)
  }

  prepare_ctx_for_fun (ctx : CTX, h : Fun_header) : CTX
    {
      def mk_clo_fld (d : Decl) : CG_member
        {
          def f = CM_field (Tyutil.encode_type_to_string (d.ty), cg_type (d.ty));
          f.name <- decl_uniq_name (d);
          f.attrs <- ["internal"];
          f.modifiers <- [Mod_internal ()];
          f.loc <- d.loc;
          f
        };
  
      def mk_clo_var (clo_vars : Int_map (CM_field), d : Decl, v : CG_member) 
                     : Int_map (CM_field) {
        clo_vars.add (d.id, (v :> CM_field))
      };
    
      def ctx =
        {
          if (h.closure_vars == null) Util.ice () else ();
          match (h.closure_vars) {
            | [] => 
              def ctx = copy_ctx (ctx);
              ctx.current_closure <- None ();
              ctx

            | _ :: _ =>
              def fields = List.map (mk_clo_fld, h.closure_vars);
              def clovars = List.fold_left2 (mk_clo_var, ctx.closure_fields, 
                                             h.closure_vars, fields);
              def cloclass = (CM_class ("", CK_class (), [], fields, None (), None ()) :> CM_class);
              def cloclname = "_N_cl_" + fun_uniq_name (h);
              def clotype = CT_ref (ctx.current_type.GetFullName () + "." + cloclname);
              def cloexpr = CE_call (CE_default_ctor_ref (cloclass), []);
              def cloval = CG_val (h.loc, "_N_closure", clotype, cloexpr, null);
              def ctx = copy_ctx (ctx);

              cloclass.name <- cloclname;
              cloclass.loc <- h.loc;
              closures <- (cloclass : CG_member) :: closures; // push it
              ctx.closure_fields <- clovars;
              ctx.current_closure <- Some (cloval);
              ctx
          }
        };
        
      ctx.closure_ptrs <- Map.int_map ();
      ctx.locals <- Map.int_map ();
      ctx.current_fun <- h;
      ctx
    }

  make_lambda_class (ctx : CTX, h : Fun_header) : CM_class
    {
      def parlen =
        match (h.parms) {
          | [{ty = t}] => 
            match (Tyutil.top_expand (t)) {
              | T_prod (types) => List.length (types)
              | _ => 1
            }
          | parms => List.length (parms)
        };
      def lambdaclass = CM_class ("", CK_class (), [CT_fun (parlen)], [], None (), None ());
      lambdaclass.name <- fun_uniq_name (h);
      (lambdaclass :> CM_class)
    }

  make_lambda_ctor (ctx : CTX, fn : Decl, cl : CM_class) : CG_expr
    {
      def pars =
        match (fn.kind) {
          | D_local_fun (_, pars) => pars
          | _ => []
        };
      def loop (acc : list (CG_expr), fh : Fun_header) : list (CG_expr) {
        match (fh.closure_vars) {
          | _ :: _ => closure_ref (ctx, fh) :: acc
          | [] => acc
        }
      };
      CE_call (CE_default_ctor_ref (cl), List.fold_left (loop, [], pars))
    }

  fill_lambda_class (ctx : CTX, fn : Decl, body : Expr, lambdaclass : CM_class) : void
    {
      def make_ctor (mems : list (CG_member)) : CG_member
        {
          def mkparm (f : CG_member) : CG_val {
            CG_val (loc = f.loc, name = f.name, ty = (f :> CM_field).ty, 
                    val = CE_none (), local_slot = null)
          };
          def mkassign (p : CG_val, f : CG_member) : CG_expr {
            CE_assign (CE_field_ref (CE_this (), (f :> CM_field)), CE_ref (p))
          };
            
          def parms = List.map (mkparm, mems);
          def assigns = List.map2 (mkassign, parms, mems);
          def meth = CM_method (Tyutil.encode_type_to_string (T_void ()), parms, CT_unreached (), CE_sequence (assigns), None ()); // FIXME: the full type
          meth.name <- lambdaclass.name;
          meth.attrs <- ["internal"];
          meth
        };
        
      def (hd, meth, pars) = 
        match (fn.kind) {
          | D_local_fun (h, pars) => (h, lookup_function (h), pars)
          | _ => Util.ice ()
        };

      def ctx = prepare_ctx_for_fun (ctx, hd);
      def mkcloptr (acc : list (CG_member), fh : Fun_header) : list (CG_member) {
        match (fh.closure_vars) {
          | _ :: _ => 
            def clotype = CT_ref (ctx.current_type.GetFullName () + "._N_cl_" + fun_uniq_name (fh));
            // FIXME: is this the correct type here?
            def fld = CM_field (Tyutil.encode_type_to_string (Tyutil.fun_type (fh)), clotype); 
            fld.name <- fun_uniq_name (fh);
            ctx.closure_ptrs <- ctx.closure_ptrs.add (fh.id, (fld :> CM_field));
            fld :: acc
          | [] => acc
        }
      };
      def fields = List.fold_left (mkcloptr, [], pars);
      def set_obj_parm (v : CG_val) : void { v.ty <- CT_object () };
      def members = make_ctor (fields) :: (meth : CG_member) :: fields;
      def members =
        match (meth.parms) {
          | [{ty = CT_tuple (arity)}] =>
            def mkparms (acc, cnt) {
              if (cnt == 0) acc
              else {
                def val = CG_val (loc = Location_stack.top (),
                                  name = Util.tmpname ("untupled"),
                                  ty = CT_object (),
                                  val = CE_none (),
                                  local_slot = null);
                mkparms (val :: acc, cnt - 1)
              }
            };
            def parms = mkparms ([], arity);
            def expr_parms = List.map (fun (v) { CE_ref (v) }, parms);
            def body = CE_call (CE_method_ref (CE_this (), meth), [CE_tuple_ctor (expr_parms)]);
            def meth' = CM_method (encoded_type = Tyutil.encode_type_to_string (T_void ()),
                                   parms = parms,
                                   ret_type = CT_object (),
                                   body = body,
                                   ctor_builder = None ());
            meth'.name <- "apply";
            meth'.attrs <- ["public"];
            meth' :: members

          | [_] => members

          | l =>
            def parm = 
              CG_val (loc = Location_stack.top (),
                      name = "_N_tupled",
                      ty = CT_object (),
                      val = CE_none (),
                      local_slot = null);
            mutable pos <- -1;
            def parm' = CE_cast (CE_ref (parm), CT_tuple (List.length (meth.parms)));
            def mktparm (p : CG_val) : CG_expr {
              pos <- pos + 1;
              CE_cast (CE_tuple_ref (parm', pos), p.ty);
            };
            def fun_ref = CE_method_ref (CE_this (), meth);
            def body = CE_call (fun_ref, List.map (mktparm, meth.parms));
            def meth' = CM_method (encoded_type = Tyutil.encode_type_to_string (T_void ()), // FIXME: build the full type here
                                   parms = [parm],
                                   ret_type = CT_object (),
                                   body = body,
                                   ctor_builder = None ());
            meth'.name <- "apply";
            meth'.attrs <- ["public"];
            meth' :: members
        };
      
      lambdaclass.decls <- members;
      List.iter (set_obj_parm, meth.parms);
      meth.name <- "apply";
      meth.attrs <- ["public"];
      meth.ret_type <- CT_object ();
      meth.body <- cg_fun_body (ctx, hd, meth, body)
    }

  cg_fun_body (ctx : CTX, hd : Fun_header, meth : CM_method, body : Expr) : CG_expr
    {
      def ctx' = copy_ctx (ctx);
      mutable assigns <- [];
      mutable vals <- [];
      
      def loadparm (parm_val : CG_val, fp : Fun_parm) : void
        {
          def parm = fp.decl;
          def needed_type = cg_type (fp.decl.ty);
          def need_downcast =
            match ((needed_type, parm_val.ty)) {
              | (CT_object, CT_object) => false
              | (_, CT_object) => true
              | _ => false
            };

          if (parm.in_closure) {
            def a =
              CE_assign (local_ref (ctx, parm), 
                         if (need_downcast) 
                           CE_cast (CE_ref (parm_val), needed_type)
                         else CE_ref (parm_val));
            assigns <- a :: assigns
          } else {
            def v =
              if (need_downcast) {
                def v = CG_val (loc = fp.decl.loc, 
                                name = Util.tmpname (parm_val.name),
                                ty = needed_type, 
                                val = CE_cast (CE_ref (parm_val), needed_type),
                                local_slot = null);
                vals <- v :: vals;
                v
              } else parm_val;
            ctx'.locals <- ctx'.locals.add (parm.id, v)
          }
        };

      def store_this (d : Decl) : void {
        match (d.kind) {
          | D_closurised_this_ptr =>
            when (d.in_closure) {
              assigns <- CE_assign (local_ref (ctx, d), CE_this ()) :: assigns
            }
          | _ => ()
        }
      };

      List.iter2 (loadparm, meth.parms, hd.parms);
      List.iter (store_this, ctx.current_fun.closure_vars);
      
      def body = cg_expr (ctx', body);
      def buildlet (e : CG_expr, v : CG_val) : CG_expr { CE_let (v, e) };
      def body =
        List.fold_left (buildlet, 
                        CE_sequence (List.rev (body :: assigns)),
                        vals);
                        
      match (ctx.current_closure) {
        | Some (v) => CE_let (v, body)
        | None => body
      };
    }

  cg_global_fun (ctx : CTX, m : IMethod, body : Expr) : CG_member
    {
      def hd = m.GetHeader ();
      def ctx = prepare_ctx_for_fun (ctx, hd);
      def meth = fixup_function (m);
      meth.body <- cg_fun_body (ctx, hd, meth, body);
      meth
    }
    
  cg_header (h : Fun_header) : CM_method
    {
      def mkparm (p : Fun_parm) : CG_val {
        CG_val (loc = Location_stack.top (),
                name = p.name, 
                ty = cg_type (p.ty),
                val = CE_none (),
                local_slot = null)
      };
      def m = CM_method (encoded_type = Tyutil.encode_type_to_string (Tyutil.fun_type (h)),
                         parms = List.map (mkparm, h.parms), 
                         ret_type = cg_type (h.ret_type),
                         body = CE_none (),
                         ctor_builder = None ());
      m.name <- h.name;
      m.modifiers <- [];
      m.attrs <- [];
      (m :> CM_method)
    }

  cg_attrs (mods : list (Modifier)) : list (string)
    {
      def cg_attr (a : Modifier) : string {
        match (a) {
          | Mod_public => "public"
          | Mod_private => "private"
          | Mod_new => "new"
          | Mod_protected => "protected"
          | Mod_internal => "internal"
          | Mod_abstract => "abstract"
          | Mod_virtual => "virtual"
          | Mod_sealed => "sealed"
          | Mod_static => "static"
          | Mod_struct => Util.ice ("FIXME: sorry, no structs yet")
          | Mod_module => ""
        }
      };
        
      List.map (cg_attr, mods);
    }

  cg_decl (ti : Tyinfo, decl : IMember) : list (CG_member) {
    Util.locate (decl.GetLocation (), fun () {
      match (decl.GetKind ()) {
        | MK_field (v) => [(lookup_field (v) : CG_member)]
        | MK_property (v) => [(lookup_property (v) : CG_member)]
        | MK_type (t) => List.map (fun (x : CM_class) { (x : CG_member) }, cg_tydecl ((t :> Tyinfo)))

        | MK_method (f) =>
          match ((f :> NemerleMethod).fun_body) {
            | FB_extern (n) =>
              def m = lookup_function (f.GetHeader ());
              m.extern_name <- n; 
              []
            | FB_parsed_expr => Util.ice ()
            | FB_typed_expr (body) =>
              CGexpr.closures <- [];
              def mem = cg_global_fun (empty_ctx (ti), f, body);
              match (f.GetFunKind ()) {
                | FK_bound_method (impl) =>
                  def mkparm (ifp : CG_val, methp : CG_val) : CG_expr {
                    CE_cast (CE_ref (ifp), methp.ty)
                  };
                  def make_impl_wrapper (meth : IMethod) : CG_member {
                    def mem = (mem :> CM_method);
                    def m = cg_header (meth.GetHeader ());
                    m.body <- CE_call (CE_method_ref (CE_this (), mem),
                                       List.map2 (mkparm, m.parms, mem.parms));
                    m.name <- meth.GetDeclaringTycon ().GetName () + "." + meth.GetName ();
                    m
                  };
                  List.append (List.map (make_impl_wrapper, impl), 
                               mem :: CGexpr.closures)
                | _ => 
                  mem :: CGexpr.closures
              }
            | FB_abstract =>
              [(fixup_function (f) :> CG_member)]
          }
      }})
  }
  
  cg_list_decl (ti : Tyinfo, decls : list (IMember)) : list (CG_member) {
    List.concat (List.map (fun (d) { cg_decl (ti, d) }, decls))
  }
    
  cg_list_tydecl (decls : list (Tyinfo)) : list (CG_member)
    {
      def f (x) {
        List.map (fun (x : CM_class) { (x : CG_member) }, cg_tydecl (x))
      };
      List.concat (List.map (f, decls))
    }

  set_extern_name (pref : string, decls : list (CG_member)) : void
    {
      def set_en (m : CG_member) : void 
        {
          when (m.extern_name == "") { m.extern_name <- pref + m.name };
          match (m) {
            | (CM_class) as c => set_extern_name (pref + c.name + ".", c.decls)
            | _ => ()
          }
        };
      List.iter (set_en, decls)
    }

  (** 
   * Generate code for given [Tyinfo] object and declarations within it.
   *
   * <remark>
   *   Type compilation is pretty straightforward.  Nemerle types
   *   mostly map to CIL types in 1:1 fashion.  We just drop type aliases.
   *
   *   FIXME: describe how variants are compiled.
   * </remark>
   *)        
  cg_tydecl (ti : Tyinfo) : list (CM_class)
    {
      def make_cm (decl : Tyinfo, kind : CM_kind) : CM_class
        {
          def r = lookup_class (decl);
          r.kind <- kind;
          r
        };

      def members_of (ti : Tycon) {
        def defined_here (m : IMember) { m.GetDeclaringTycon ().SameAs (ti) };
        List.filter (defined_here, ti.GetMembers ())
      };
      def members = members_of (ti);
      
      match (ti.GetTydecl ()) {
        | TD_interface =>
          def mkmember (m : IMember) : CG_member {
            match (m.GetKind ()) {
              | MK_method (m) =>
                match (m.GetFunKind ()) {
                  | FK_iface_method (new_flag) =>
                    def h = m.GetHeader ();
                    def m = cg_header (h);
                    (* m.attrs <- ["abstract"; "virtual"]; -- this is unnecessary for C# code generation *)
                    m.modifiers <- [Mod_public (); Mod_abstract (); Mod_virtual ()];
                    when (new_flag) { 
                      m.attrs <- "new" :: m.attrs;
                      m.modifiers <- Mod_new () :: m.modifiers;
                    };
                    m
                  | _ => Util.ice ()
                }
              | _ => Util.ice ()
            }
          };
          def cm = make_cm (ti, CK_interface ());
          cm.decls <- List.map (mkmember, members);
          [cm]

        | TD_variant =>
          def mkopt (m : Tyinfo) : CG_member {
            match (m.GetTydecl ()) {
              | TD_variant_option (encoded_type) =>
                def cm = make_cm (m, CK_variant_option (encoded_type));
                cm.inheritance <- [cg_type (ti.GetMemType ())]; // FIXME: variant options inheriting from themselves?
                cm.decls <- cg_list_decl (ti, members_of (m));
                cm
              | _ => Util.ice ()
            }
          };
          def cm = make_cm (ti, CK_variant ());
          def types_inside (acc, mems) {
            match (mems) {
              | x :: xs =>
                match ((x : IMember).GetKind ()) {
                  | MK_type (t) => types_inside ((t :> Tyinfo) :: acc, xs)
                  | _ => types_inside (acc, xs)
                }
              | [] => acc
            }
          };
          cm.decls <- List.append (List.map (mkopt, types_inside ([], members)), 
                                   cg_list_decl (ti, members));
          [cm]

        | TD_class =>
          def cm = make_cm (ti, CK_class ());
          cm.decls <- cg_list_decl (ti, members);
          [cm]

        | TD_variant_option => []    
        | TD_external => []
        // C# doesn't seem to provide typedef, not sure about CLS though
        | TD_alias => [] 

        | TD_macro => 
//        FIXME: here we must generate class implementing I_Macro interface using
//               stored function
          Util.ice ("we cannot generate code for macros yet")
      }
    }
  
  (** 
   * Generate code for all [Tyinfo] objects.
   *
   * <remarks>
   *   We define types and expressions flattened to CIL level in cgtree.n.
   * </remarks>
   *)
  public run () : list (CM_class)
  {
    mutable gres <- [];
  
    def run_cg_tydecl (decl : Tyinfo) : void {
      def set_ns (cmc : CM_class) : void {
        cmc.ns <- decl.env.current_namespace;
        set_extern_name (cmc.ns, [(cmc : CG_member)])
      };
      def res = Util.locate (decl.GetLocation (), 
        fun () : list (CM_class) { cg_tydecl (decl) });
      List.iter (set_ns, res);
      gres <- res :: gres
    };
    
    cg_members <- System.Collections.Hashtable (2000);
    Tyinfo.top_iter (run_cg_tydecl);
    List.concat (List.rev (gres));
  }

} // end module
} // end ns
