/*
 * Copyright (c) 2003-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Utility;

using System.Diagnostics;

using T = Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler.Parsetree
{
  //[Record (Exclude = [_definedIn, _typeBuilder])]
  public variant TopDeclaration : MemberBase
  {
    | Class
      {
        mutable t_extends : list[PExpr];
                decls     : list[ClassMember];
      }

    | Alias { ty : PExpr; }

    | Interface
      {
        mutable t_extends : list [PExpr];
        methods : list [ClassMember]; // only iface_member
      }

    | Variant
      {
        mutable t_extends : list [PExpr];
        mutable decls : list [ClassMember];
      }

    | VariantOption { decls : list [ClassMember]; }

    | Macro
      {
        header : PFunHeader;
        synt : list [PExpr];
        expr : PExpr;
      }

    | Delegate
      {
        header : PFunHeader;
        [RecordIgnore] ReturnValueModifiers : AttributesAndModifiers  { get; set; }
      }

    | Enum
      {
        t_extends : list [PExpr];
        decls : list[ClassMember];
      }

    [RecordIgnore]
    public DeclaredTypeParameters : Typarms;

    public DeclaredTypeParametersCount : int
    {
      get { if (DeclaredTypeParameters != null) DeclaredTypeParameters.tyvars.Length else 0 }
    }

    public mutable typarms : Typarms;

    public TypeParameters : Typarms { get { typarms } set { typarms = value; } }

    public TypeParametersCount : int
    {
      get { if (typarms != null) typarms.tyvars.Length else 0 }
    }
    /// If this TopDeclaration nested in other TopDeclaration
    /// this property contain referens to it.  This property set to null
    /// if it is top level declaration.
    [Accessor, RecordIgnore] internal mutable _definedIn : TopDeclaration;
    [Accessor, RecordIgnore] internal mutable _typeBuilder : TypeBuilder;
    /// This location used to outlining tegion as start of outpining
    [Accessor, RecordIgnore] internal mutable _headerLocation  : Location;

    public new this(loc : Location, name : Splicable, modifiers : AttributesAndModifiers, typarms : Typarms)
    {
      base(loc, name, modifiers);

      this.typarms                = typarms;
      this.DeclaredTypeParameters = typarms;
    }

    public new this(name : Splicable, modifiers : AttributesAndModifiers, typarms : Typarms)
    {
      base(name, modifiers);

      this.typarms                = typarms;
      this.DeclaredTypeParameters = typarms;
    }

    public new this(name : Name, modifiers : AttributesAndModifiers, typarms : Typarms)
    {
      base(Splicable.Name(name), modifiers);

      this.typarms                = typarms;
      this.DeclaredTypeParameters = typarms;
    }

    public this (tp : Typarms)
    {
      this ();
      typarms = tp;
    }

    public this () { base (Splicable.Name (Name ("")), AttributesAndModifiers()) }

    public FullQualifiedName : string
    {
      get
      {
        def makeName(td)
        {
          if (td.DefinedIn != null)
            makeName(td.DefinedIn) + "." + td.Name
          else
            td.Name
        }

        match (TryGetEnv())
        {
          | Some(env) when env != null =>
            def msName = env.CurrentNamespace.GetDisplayName();
            if (string.IsNullOrEmpty(msName))
              makeName(this)
            else
              msName + "." + makeName(this);

          | _ => makeName(this)
        }
      }
    }

    public FullName : string
    {
      get
      {
        def makeName(td)
        {
          def tyParam = if (td.typarms == null) "" else td.typarms.ToString();

          if (td.DefinedIn != null)
            $"$(makeName(td.DefinedIn)).$(td.Name)$tyParam"
          else
            td.Name + tyParam
        }

        match (TryGetEnv())
        {
          | Some(env) when env != null =>
            def msName = env.CurrentNamespace.GetDisplayName();
            if (string.IsNullOrEmpty(msName))
              makeName(this)
            else
              msName + "." + makeName(this);

          | _ => makeName(this)
        }
      }
    }

    public GetMembers() : list[ClassMember]
    {
      match (this)
      {
        | Class        (decls   = decls)
        | Interface    (methods = decls)
        | Variant      (decls   = decls)
        | VariantOption(decls   = decls)
        | Enum         (decls   = decls) => decls
        | Delegate | Macro | Alias       => []
      }
    }

    public GetAllInnerTypes() : list[TopDeclaration]
    {
      mutable res = [];
      def getInner(x)
      {
        | Class        (decls   = decls)
        | Interface    (methods = decls)
        | Variant      (decls   = decls)
        | VariantOption(decls   = decls)  =>
          foreach (ClassMember.TypeDeclaration(td) in decls)
          {
            res ::= td;
            getInner(td);
          }

        | Enum | Delegate | Macro | Alias => ()
      }

      getInner(this);
      res
    }

    public override ToString() : string
    {
      def name = this.Name;
      match (this)
      {
        | Class                => $"class $name"
        | Alias(ty)            => $"type $name = $ty"
        | Interface            => $"interface $name"
        | Variant              => $"variant $name"
        | VariantOption        => $"| $name"
        | Macro (header, _, _) => $"macro $name($header)"
        | Delegate (header)    => $"delegate $name: $header"
        | Enum                 => $"enum $name"
      }
    }
  }

  [Record (Exclude = [_env, _tokens, _bodyLocation, _definedIn, _builder, _userData])]
  public variant ClassMember : MemberBase
  {
    | TypeDeclaration
      {
        td : TopDeclaration;

        public this(name : Splicable, td : TopDeclaration) { this(td.Location, name, td.modifiers, td) }
        public this(td : TopDeclaration)                   { this(td.Location, td.name, td.modifiers, td) }
      }

    | Field
      {
        mutable ty : PExpr;
        [RecordIgnore] Initializer : PExpr { get; internal set; }
        [RecordIgnore] ParsedType  : PExpr { get; internal set; }

        public new Builder : FieldBuilder    { get { _builder :> FieldBuilder } }

        public new this(
          loc : Location,
          name : Nemerle.Compiler.Parsetree.Splicable,
          modifiers : Nemerle.Compiler.AttributesAndModifiers,
          ty : PExpr)
        {
          base(loc, name, modifiers);
          this.ty = ty;
          this.ParsedType = ty;
        }

        public this(
          loc : Location,
          name : Nemerle.Compiler.Parsetree.Splicable,
          modifiers : Nemerle.Compiler.AttributesAndModifiers,
          ty : PExpr,
          initializer : PExpr)
        {
          this(loc, name, modifiers, ty);
          this.Initializer = initializer;
        }
      }

    | Function
      {
        header : PFunHeader;
        mutable implemented : list[PExpr];
        mutable body        : FunBody;

        [RecordIgnore] ParsedImplemented    : list[PExpr] { get; internal set; }
        [RecordIgnore] ParsedBody           : FunBody     { get; set; }
        [RecordIgnore] IsExtension          : bool        { get; set; }
        [RecordIgnore] ReturnValueModifiers : AttributesAndModifiers  { get; set; }

        public new Builder : MethodBuilder   { get { _builder :> MethodBuilder } }

        public new this(
          loc : Location,
          name : Nemerle.Compiler.Parsetree.Splicable,
          modifiers : Nemerle.Compiler.AttributesAndModifiers,
          header : PFunHeader,
          implemented : list[PExpr],
          body : FunBody)
        {
          base(loc, name, modifiers);
          this.header = header;

          this.implemented = implemented;
          this.ParsedImplemented = implemented;

          this.body = body;
          this.ParsedBody = body;
        }
      }

    | Property
      {
        public new this(
          name : Nemerle.Compiler.Parsetree.Splicable,
          modifiers : Nemerle.Compiler.AttributesAndModifiers,
          returnType : Nemerle.Compiler.Parsetree.PExpr,
          parameters : list[Nemerle.Compiler.Parsetree.PParameter],
          getter : option[Nemerle.Compiler.Parsetree.ClassMember.Function],
          setter : option[Nemerle.Compiler.Parsetree.ClassMember.Function])
        {
          this(Location.Default, name, modifiers, returnType, parameters, getter, setter)
        }

        public new this(
          loc : Location,
          name : Nemerle.Compiler.Parsetree.Splicable,
          modifiers : Nemerle.Compiler.AttributesAndModifiers,
          returnType : Nemerle.Compiler.Parsetree.PExpr,
          parameters : list[Nemerle.Compiler.Parsetree.PParameter],
          getter : option[Nemerle.Compiler.Parsetree.ClassMember.Function],
          setter : option[Nemerle.Compiler.Parsetree.ClassMember.Function])
        {
          this(loc, name, modifiers, returnType, parameters, getter, setter, None());
        }

        public new this(
          loc : Location,
          name : Nemerle.Compiler.Parsetree.Splicable,
          modifiers : Nemerle.Compiler.AttributesAndModifiers,
          returnType : Nemerle.Compiler.Parsetree.PExpr,
          parameters : list[Nemerle.Compiler.Parsetree.PParameter],
          getter : option[Nemerle.Compiler.Parsetree.ClassMember.Function],
          setter : option[Nemerle.Compiler.Parsetree.ClassMember.Function],
          initializer : option[PExpr])
        {
          base(loc, name, modifiers);

          this.parsedReturnType    = returnType;
          this.returnType          = returnType;

          this.parsedParameters    = parameters;
          this.parameters          = parameters;

          this.parsedGetter        = getter;
          this.getter              = getter;

          this.parsedSetter        = setter;
          this.setter              = setter;

          this.initializer         = initializer;
        }

        public this(
          loc : Location,
          name : Nemerle.Compiler.Parsetree.Splicable,
          modifiers : Nemerle.Compiler.AttributesAndModifiers,
          returnType : Nemerle.Compiler.Parsetree.PExpr,
          parameters : list[Nemerle.Compiler.Parsetree.PParameter],
          getter : option[Nemerle.Compiler.Parsetree.ClassMember.Function],
          setter : option[Nemerle.Compiler.Parsetree.ClassMember.Function],
          implemented : list[PExpr])
        {
          this(loc, name, modifiers, returnType, parameters, getter, setter);
          this.ParsedImplemented = implemented;
        }

        public mutable        returnType          : PExpr;
        [RecordIgnore] public parsedReturnType    : PExpr;

        public mutable        parameters          : list[PParameter]; // parameters of indexer property
        [RecordIgnore] public parsedParameters    : list[PParameter];

        public mutable        getter              : option[ClassMember.Function];
        [RecordIgnore] public parsedGetter        : option[ClassMember.Function];

        public mutable        setter              : option[ClassMember.Function];
        [RecordIgnore] public parsedSetter        : option[ClassMember.Function];

        public mutable        initializer         : option[PExpr];

        [Accessor(flags=WantSetter), RecordIgnore] internal mutable _parsedParametersOpenLocation  : Location;
        [Accessor(flags=WantSetter), RecordIgnore] internal mutable _parsedParametersCloseLocation : Location;
        [RecordIgnore] public ParsedImplemented             : list[PExpr] { get; internal set; }

        public SignatureType : PExpr
        {
          get
          {
            match (parameters)
            {
              | [parm]     => Util.locate(parm.Location + returnType.Location,
                                <[ $(parm.Type) -> $returnType ]>)

              | [] | null  => returnType

              | first :: _ => def input_parms = parameters.Map(_.Type);
                              Util.locate(first.Location + returnType.Location,
                                <[ @*(..$input_parms) -> $returnType ]>)
            }
          }
        }

        public ParsedSignatureType : PExpr
        {
          get
          {
            match (parsedParameters)
            {
              | [parm]     => Util.locate(parm.Location + parsedReturnType.Location,
                                <[ $(parm.Type) -> $parsedReturnType ]>)
              | []         => parsedReturnType
              | first :: _ => def input_parms = parsedParameters.Map(_.Type);
                              Util.locate(first.Location + parsedReturnType.Location,
                                <[ @*(..$input_parms) -> $parsedReturnType ]>)
            }
          }
        }

        public new Builder : PropertyBuilder { get { _builder :> PropertyBuilder } }
      }

    | Event
      {
        ty : PExpr;
        field : ClassMember.Field;
        add : ClassMember.Function;
        remove : ClassMember.Function;
        public new Builder : EventBuilder    { get { _builder :> EventBuilder } }
      }

    | EnumOption { value : option [PExpr]; }

    // It's prevent esers from fortuitous modification of Env property.
    public SetEnv(env : GlobalEnv) : void { _env = env; }
    [Accessor] internal mutable _env          : GlobalEnv;
    [Accessor] internal mutable _tokens       : Token.BracesGroup;
    /// This property contain referens to TopDeclaration where defined this member.
    [Accessor] internal mutable _definedIn    : TopDeclaration;
    //  This field set to MemberBuilder where it will be created. (null for EnumOption & TypeDeclaration)
    [Accessor] internal mutable _builder      : MemberBuilder;
    [Accessor(flags = WantSetter)]
    mutable _userData : object;

    /** accessible only for ClassMember.Function, when its FunBody is not typed or compiled */
    public Body : PExpr
    {
      get {
        match (this) {
          | ClassMember.Function (body = bd) =>
            match (bd) {
              | FunBody.Parsed (expr) => expr
              | FunBody.Typed =>
                Message.Error ("Body of typed method is not accessible");
                null
              | FunBody.ILed =>
                Message.Error ("Body of compiled method is not accessible");
                null
              | FunBody.Abstract => <[ () ]>
            }
          | _ =>
            Message.Error ("Body is accessible only for ClassMember.Function variant option");
            null
        }
      }
      set {
        match (this) {
          | ClassMember.Function as fn =>
            fn.body = FunBody.Parsed (value);
          | _ =>
            Message.Error ("Body is accessible only for ClassMember.Function variant option")
        }
      }
    }

    public IsMutable () : bool { modifiers.mods %&& NemerleModifiers.Mutable }

    internal PrintBody (writer : LocatableTextWriter) : void
    {
      match (this) {
        | Function (body = bd) =>
          match (bd) {
              | FunBody.Parsed (expr) =>
                PrettyPrint.SprintExpr (None(), expr, "", writer);
              | _ => ()
          }

        | Property (getter = getter, setter = setter, initializer = initializer) =>
          def print(accessor, acc_type)
          {
            | (Some(Function (body = FunBody.Parsed (expr))), _) =>
              writer.Write($"\n$acc_type");
              PrettyPrint.SprintExpr (None(), expr, "", writer);
              writer.Write("\n");
            | _ => ()
          }
          print(getter, "get");
          print(setter, "set");

          when (initializer is Some(initExpr))
          {
            writer.Write("\ndefault");
            PrettyPrint.SprintExpr(None(), initExpr, "", writer);
            writer.Write("\n");
          }
        | _ => ()
      }
    }
    public HeaderToString() : string
    {
      def squareLst(lst) { if (lst.IsEmpty) "" else lst.ToString() }
      def attrs = if (modifiers == null) "" else Attributes.ToString().ToLower().Replace(",", "");
      def attrs = if (attrs == "") attrs else attrs + " ";
      def ifMutable () { if (IsMutable ()) "mutable " else "" }
      def prefix() { $"$(attrs)$(ifMutable())" }
      def name = this.name;

      match (this)
      {
        | TypeDeclaration(td)             => $"$(prefix())$td"
        | Field(ty)                       => $"$(prefix())$name : $ty"
        | Function(header, _, _)          => $"$(prefix())$header"
        | Property(returnType = ty, parameters = dims)  => $"$(prefix())$name$(squareLst(dims)) : $ty"
        | Event(ty, _, _, _)              => $"$(prefix())$name : $ty"
        | EnumOption(value)               => $"$name" + match (value) { | Some(v) => $" = $v" | None => "" }
      }
    }

    public override ToString() : string
    {
      def attrs = if (modifiers == null) "" else Attributes.ToString().ToLower().Replace(",", "");
      def attrs = if (attrs == "") attrs else attrs + " ";
      def ifMutable () { if (IsMutable ()) "mutable " else "" }
      def prefix() { $"$(attrs)$(ifMutable())" }
      def name = this.name;

      match (this)
      {
        | TypeDeclaration(td)         => $"TopDeclaration: $(prefix())Name=$name ($td)"
        | Field(ty)                   => $"Field: $(prefix())$name : $ty;"
        | Function(header, _, _)      => $"Function: $(prefix())$header;"
        | Property(returnType = ty, parameters = dims, getter = get, setter = set, initializer = init) =>

          // Write "get; set; default;" or ";" if nothing exist.
          mutable getSetInit = "{ ";
          when (get.IsSome) getSetInit += "get; ";
          when (set.IsSome) getSetInit += "set; ";
          when (init.IsSome) getSetInit += "default; ";
          if (getSetInit.Length > 2) getSetInit += "}";
          else                       getSetInit = ";";

          $"Property: $(prefix())$name : $ty" + (if (dims.IsEmpty) "" else dims.ToString()) + getSetInit

        | Event(ty, _, _, _)          => $"Event: $(prefix())$name : $ty"
        | EnumOption(value)           => $"$name" + match (value) { | Some(v) => $" = $v" | None => "" }
      }
    }
  }

  [Record]
  public class MemberBase : DeclarationBase
  {
    [Accessor(flags=WantSetter), RecordIgnore] internal mutable _bodyOpenTokenLocation  : Location;
    [Accessor(flags=WantSetter), RecordIgnore] internal mutable _bodyCloseTokenLocation : Location;
    [Accessor, RecordIgnore] internal mutable _isIndentationSyntax    : bool;
    [Accessor(flags=WantSetter), RecordIgnore] internal mutable _typeParametersLocation : Location;

    public BodyLocation : Location
    {
      get { BodyOpenTokenLocation + BodyCloseTokenLocation }
    }
    public BodyInnerLocation : Location
    {
      get { BodyOpenTokenLocation.FromEnd() + BodyCloseTokenLocation.FromStart() }
    }
  }

  public class DeclarationBase : ParsedBase
  {
    public mutable name : Splicable;
    public mutable modifiers : AttributesAndModifiers;

    [RecordIgnore] public ParsedSplicableName         : Splicable;
    [RecordIgnore] public ParsedAttributsAndModifiers : AttributesAndModifiers;

    public this(name : Splicable, modifiers : AttributesAndModifiers)
    {
      this(LocationStack.Top(), name, modifiers)
    }

    public this(loc : Location, name : Splicable, modifiers : AttributesAndModifiers)
    {
      base(loc);

      this.name                   = name;
      ParsedSplicableName         = name;
      this.modifiers              = modifiers;
      ParsedAttributsAndModifiers = modifiers;
    }

    public TryGetEnv() : option[GlobalEnv]
    {
        match (name)
        {
          | Splicable.Name(x)
          | Splicable.HalfId(x)         => Some(x.context)
          | null
          | Splicable.Expression(_expr) => None() //TODO: Try find GlobalEnv in _expr
        }
    }

    public GetEnv(defaulteGlobalEnv : GlobalEnv) : GlobalEnv
    {
        match (name)
        {
          | Splicable.Name(x)
          | Splicable.HalfId(x)         => x.context
          | null
          | Splicable.Expression(_expr) => defaulteGlobalEnv //TODO: Try find GlobalEnv in _expr
        }
    }

    public PName      : Name    { get { name.GetName() } }
    public Name       : string  { get { if (name == null) "" else name.ToString() } }
    public ParsedName : string  { get { ParsedSplicableName.ToString() } }

    public NameLocation : Location
    {
      get
      {
        if (ParsedSplicableName == null) this.Location
        else ParsedSplicableName.Location
      }
    }

    public Attributes : NemerleModifiers
    {
      get { modifiers.mods }
      set { modifiers.mods = value }
    }

    public GetCustomAttributes () : list [PExpr]
    {
      modifiers.custom_attrs
    }

    public AddCustomAttribute (e : PExpr) : void
    {
      modifiers.custom_attrs = e :: modifiers.custom_attrs
    }
  }

  public class Constraint
  {
    public this(tyvar : Splicable, ty : PExpr, isSpecial : bool = true)
    {
      this.tyvar     = tyvar;
      this.ty        = ty;
      this.IsSpecial = isSpecial;
    }

    public tyvar     : Splicable;
    public ty        : PExpr;
    public IsSpecial : bool { get; }

    public TypeParameterName : Splicable { get { tyvar } }
    public Expression        : PExpr     { get { ty } }
}

  [Record]
  public class Typarms
  {
    public tyvars : list [Splicable];
    public constraints : list [Constraint];

    public static Empty : Typarms = Typarms ([], []);

    public override ToString() : string
    {
      if (tyvars.IsEmpty) "" else ($"[..$tyvars]")
    }

    public virtual IsCopyOfExisting : bool { get { false } }
    public virtual Substitute (ty : FixedType) : TypeVar { ty }
    public virtual ExistingTyvars : list [StaticTypeVar] { get { null } }
  }

  public class SubstitutingTyparms : Typarms {
    subst : Subst;

    public this (subst : Subst) {
      base ([], []);
      this.subst = subst;
    }

    public override Substitute (ty : FixedType) : TypeVar { subst.Apply (ty) }
  }

  /** The specified list of typed type parameters will be used as template for new type parameters.
      Compiler will also perform substitution of references to old parameters in type/method signature into references
      to fresh type parameters */
  public class CopyTypedTyparms : SubstitutingTyparms {
    fresh_vars : list [StaticTypeVar];

    public this (template_tyvars : list [StaticTypeVar]) {
      this (template_tyvars, null)
    }

    public this (template_tyvars : list [StaticTypeVar], subst : Subst) {
      def (fsubst, fresh_vars) = StaticTypeVar.CopyList (template_tyvars);
      when (subst != null)
        fsubst.AddSubst (subst);
      base (fsubst);
      this.fresh_vars = fresh_vars;
    }

    public override IsCopyOfExisting : bool { get { true } }
    public override ExistingTyvars : list [StaticTypeVar] { get { fresh_vars } }
  }

  /** class encapsulating name of variable for purpose of
      quotation and renaming
   */
  public class Name : ParsedBase, System.IComparable[Name], System.IEquatable[Name]
  {
    public idl : string;
    public color : int;
    public context : GlobalEnv;
    public ParsedId : string;

    public this(other : Name)
    {
      base(other.Location);

      idl       = other.idl;
      color     = other.color;
      context   = other.context;
      ParsedId  = other.ParsedId;
    }

    public this(id : string)
    {
      this(id, LocationStack.Top())
    }

    public this(id : string, loc : Location)
    {
      this(id, loc, id)
    }

    public this(id : string, color : int, context : GlobalEnv)
    {
      this(id, LocationStack.Top(), color, context, id)
    }

    public this(id : string, loc : Location, color : int, context : GlobalEnv)
    {
      this(id, loc, color, context, id)
    }

    public this(id : string, loc : Location, parsedId : string)
    {
      this(id, loc, ManagerClass.Instance.MacroColors.Color, null, // no global context
        parsedId);
    }

    public this(id : string, loc : Location, color : int, context : GlobalEnv, parsedId : string)
    {
      base(loc);

      this.color    = color;
      this.context  = context;
      idl           = id;
      this.ParsedId = parsedId;
    }

    static public NameInCurrentColor (id : string, context : GlobalEnv) : Name
    {
      Name (id, context.Manager.MacroColors.Color, context)
    }

    static public NameInCurrentColor (id : string, loc : Location, context : GlobalEnv) : Name
    {
      Name (id, loc, context.Manager.MacroColors.Color, context)
    }

    static public NameInCurrentColor (id : string, parsedId : string, loc : Location, context : GlobalEnv) : Name
    {
      Name (id, loc, context.Manager.MacroColors.Color, context, parsedId)
    }

    static public Global (mgr : ManagerClass, id : string) : Name
    {
      Name (id, 1, mgr.CoreEnv)
    }

    public NewName (id : string) : Name
    {
      Name (id, color, context);
    }

    /** Returns plain identifier string of this name.
     */
    public Id : string
    {
      [DebuggerNonUserCode] get { idl }
    }

    public override ToString () : string
    {
      Id
    }

    public override GetHashCode () : int
    {
      unchecked (idl.GetHashCode () * (color + 1))
    }

    [Nemerle.OverrideObjectEquals]
    public Equals (other : Name) : bool
      implements System.IEquatable[Name].Equals
    {
      this.CompareTo (other) == 0
    }

    public CompareTo (other : Name) : int
    {
      if (color == other.color || color < 0 || other.color < 0)
        if (idl == other.idl) 0
        else string.CompareOrdinal (idl, other.idl)
      else
        color - other.color
    }

    public GetEnv (default : GlobalEnv) : GlobalEnv
    {
//      when (context == null) Message.Debug ("null: " + Id);
      if (context != null)
        context
      else
        default
    }
  }

  [Record]
  public variant PExpr : ParsedBase
  {
    | Wildcard        // `_' used mainly in patterns, but also in `_ = ignored'
    | Void            // `void' used only in types
    | As              { pat : PExpr; name : Splicable; }
    | Is              { pat : PExpr; ty : PExpr; }
    | Where           { name : PExpr; fields : PExpr; }
    | Match           { expr : PExpr; cases : list [MatchCase]; mutable expr_loc : Location;
                        this(loc : Location, expr : PExpr, cases : list [MatchCase]) { this(loc, expr, cases, Location.Default); }
                        this(expr : PExpr, cases : list [MatchCase]) { this(expr, cases, Location.Default); }
                      }

    | Ref             {
                        mutable name : Name;

                        public new this(name : Name)
                        {
                          base(if (name == null || name.Location == Location.Default) LocationStack.Top() else name.Location);
                          this.name = name;
                        }

                        public new this(loc : Location, name : Name)
                        {
                          base(loc);
                          this.name = name;
                        }
                      }
    | Member
      {
        obj : PExpr; member : Splicable;

        public new this(obj : PExpr, member : PExpr.Ref)
        {
          if (obj.Location.IsGenerated && !member.Location.IsGenerated)
            base(member.Location);
          else
            base();

          this.obj  = obj;
          this.member = Splicable.Name(member.Location, member.name);
        }

        public new this(obj : PExpr, member : Splicable)
        {
          def loc1 = obj.Location;
          def loc2 = member.Location;

          if (loc1.IsGeneratedOrEmpty && !loc2.IsGenerated)
            base(member.Location);
          else if (loc2.IsSourceAvailable && loc1.IsSourceAvailable)
            base(loc1 + loc2);
          else
            base();

          this.obj    = obj;
          this.member = member;
        }
      }
    | Call            { func : PExpr; parms : list [PExpr]; }
    | GenericSpecifier { func : PExpr; generic_parms : list [PExpr]; }
    | ListLiteral     { elements : list [PExpr]; }
    | Assign          { target : PExpr; source : PExpr; }
    | DefMutable      { name : PExpr; val : PExpr; }
    | Define          { pattern : PExpr; val : PExpr; }
    | DefFunctions    { funs : list [Function_decl]; }
    | Lambda          { decl : Function_decl; }
    | Throw           { exn : PExpr; }
    | Try             { body : PExpr; cases : list [TryCase]; }
    | TryFinally      { body : PExpr; handler : PExpr; }
    | Literal         { val : Nemerle.Compiler.Literal; }
    | This
    | Base            { ty : option[PExpr];

                        public this()
                        { this(option.None()); }

                        public this(loc : Location)
                        { this(loc, option.None()); }

                        public this(ty : PExpr)
                        { this(option.Some(ty)); }

                        public this(loc : Location, ty : PExpr)
                        { this(loc, option.Some(ty)); }
                      }
    | Typeof          { ty : PExpr; }
    | TypeConversion  { expr : PExpr; ty : PExpr; }  // (expr :> ty)
    | TypeEnforcement { expr : PExpr; ty : PExpr; } // (expr : ty)
    | Sequence        { body : list [PExpr]; }
    | Tuple           { args : list [PExpr];
                        [RecordIgnore] public mutable argsCount : int;

                        public static Create(loc : Location, args : list[PExpr]) : PExpr.Tuple
                        {
                          PExpr.Tuple(loc, args, args.Length);
                        }
                        public static Create(args : list[PExpr]) : PExpr.Tuple
                        {
                          PExpr.Tuple(args.EnclosingLocation(), args, args.Length);
                        }
                        public this(args : list[PExpr], argsCount : int)
                        { this(args); this.argsCount = argsCount; }

                        public this(loc : Location, args : list[PExpr], argsCount : int)
                        { this(loc, args); this.argsCount = argsCount; }
                      }
    | Array           { rank : PExpr; args : PExpr; }
    | EmptyArray      { sizes : list [PExpr]; }
    | Indexer         { obj : PExpr; args : list [PExpr]; }
    | ParmByRef       { parm : PExpr; }
    | ParmOut         { parm : PExpr; }

    | Error // placeholder of missing tree (where some errors occured)
      {
        msg : object;
        public this()
        {
          msg = null;
        }
        public this(location : Location)
        {
          base(location);
          msg = null;
        }
      }

    // macros stuff
    | MacroCall       { name : Name; ns : NamespaceTree.Node;
                        parms : list [SyntaxElement]; }
    | Quoted          { body : SyntaxElement; }
    | Spliced         { body : PExpr; }
    | ToComplete      { body : Name; }
    | Ellipsis        { body : PExpr; }
    | Typed           { body : Typedtree.TExpr; }
    | TypedPattern    { body : Typedtree.Pattern; }
    | TypedType       { body : TypeVar; }

    [RecordIgnore]
    public Token : Token { get; set; }

    public override ToString () : string { PrettyPrint.SprintExpr (None (), this); }

    // transforms dot-separated identifier to the parse-tree expression
    public static FromQualifiedIdentifier (manager : ManagerClass, qid : string) : PExpr
    {
      if (string.IsNullOrEmpty (qid)) null
      else {
        def split = qid.Split ('.');
        mutable expr = <[ $(Name (split [0], manager.MacroColors.UseColor, manager.MacroColors.UseContext) : name) ]>;
        for (mutable i = 1; i < split.Length; i++)
          expr = <[ $expr . $(Name (split [i], manager.MacroColors.UseColor, manager.MacroColors.UseContext) : name) ]>;
        expr
      }
    }
  }

  [Record]
  public variant Splicable : ParsedBase, System.IEquatable[Splicable]
  {
    | Name
      {
        body : Parsetree.Name;

        public this(nameRef : PExpr.Ref)
        {
          base(if (nameRef == null) Location.Default else nameRef.Location);

          this.body = nameRef.name;
        }

        public new this(body : Parsetree.Name)
        {
          base(if (body == null) Location.Default else body.Location);

          this.body = body;
        }
      }
    | Expression
      {
        expr : PExpr;
        [RecordIgnore] public mutable env : GlobalEnv;
        public this(expr : PExpr, env : GlobalEnv)
        {
          base(if (expr == null) Location.Default else expr.Location);
          this.expr = expr;
          this.env = env;
        }
        public this(loc : Location, expr : PExpr, env : GlobalEnv)
        {
          base(loc);
          this.expr = expr; this.env = env;
        }
      }

    | HalfId { prefix : Parsetree.Name; }

    //[RecordIgnore] public TypedObject : IMember { get; internal set; }

    public GetName () : Parsetree.Name
    {
      match (this)
      {
        | Splicable.Name (x) => x
        | _ => throw System.ArgumentException ("GetName () called for option " + this.ToString ())
      }
    }

    [Nemerle.OverrideObjectEquals]
    public Equals (other : Splicable) : bool
      implements System.IEquatable[Splicable].Equals
    {
      match ((this, other))
      {
        | (HalfId (n1), HalfId (n2))
        | (Name (n1), Name (n2)) => n1.Equals (n2)
        | _ => false
      }
    }

    public GetIdentifier () : string
    {
      match (this) {
        | Splicable.Name (x) => x.Id
        | _ => throw System.ArgumentException ("GetIdList () called for option " + this.ToString ())
      }
    }

    override public ToString() : string
    {
      match (this)
      {
        | Splicable.Name(x)          => x.Id
        | Splicable.Expression(expr) => expr.ToString()
        | Splicable.HalfId(prefix)   => prefix.Id
        | null                       => ""
      }
    }
  }

  //public type Fun_parm = PParameter;

  public class PParameter : DeclarationBase
  {
    public mutable Type       : PExpr;
    // when parse_header() sees a pattern as a function parameters,
    // it generates a dummy name and puts the pattern in this field
    public PatternHack : PExpr { get; private set; }
    public ResetPatternHack() : void { PatternHack = null; }

    public ParsedType        : PExpr;
    public ParsedPatternHack : PExpr;

    public DefaultValue      : option[PExpr] {get; set;}
    public ParsedDefaultValue  : option[PExpr];

    public new TypedObject : T.TParameter { get { base.TypedObject :> T.TParameter } }

    public this (name : Name, modifiers : AttributesAndModifiers, Type : PExpr, DefaultValue : option[PExpr])
    {
      this (Splicable.Name(name), modifiers, Type, DefaultValue)
    }

    public this (name : Splicable, modifiers : AttributesAndModifiers, Type : PExpr, DefaultValue : option[PExpr])
    {
      base (LocationStack.Top(), name, modifiers);
      this.Type  = Type;
      ParsedType = Type;
      this.DefaultValue = DefaultValue;
      ParsedDefaultValue = DefaultValue;
    }

    public this (name : Splicable, modifiers : AttributesAndModifiers, Type : PExpr)
    {
      base (LocationStack.Top(), name, modifiers);
      this.Type  = Type;
      ParsedType = Type;
      DefaultValue = None();
      ParsedDefaultValue = None();
    }

    public this (name : Name, modifiers : AttributesAndModifiers, Type : PExpr)
    {
      this(Splicable.Name(name), modifiers, Type)
    }

    public this (name : Splicable, ty : PExpr, modifiers : AttributesAndModifiers, defval : option[PExpr])
    {
      base (LocationStack.Top(), name, modifiers);

      this.Type  = ty;
      ParsedType = ty;
      this.DefaultValue = defval;
      ParsedDefaultValue = defval;
    }

    public this (name : Name, ty : PExpr, modifiers : AttributesAndModifiers, defval : option[PExpr])
    {
      this(Splicable.Name(name), ty, modifiers, defval)
    }

    public this (name : Splicable, ty : PExpr, modifiers : AttributesAndModifiers)
    {
      base (LocationStack.Top(), name, modifiers);

      this.Type  = ty;
      ParsedType = ty;
      DefaultValue = None();
      ParsedDefaultValue = None();
    }

    public this (name : Name, ty : PExpr, modifiers : AttributesAndModifiers)
    {
      this(Splicable.Name(name), ty, modifiers)
    }

    public this (loc : Location, name : Splicable, ty : PExpr, modifiers : AttributesAndModifiers, patternHack : PExpr = null)
    {
      base (loc, name, modifiers);

      this.Type         = ty;
      ParsedType        = ty;
      this.PatternHack  = patternHack;
      ParsedPatternHack = patternHack;
      DefaultValue = None();
      ParsedDefaultValue = None();
    }

    public this (loc : Location, name : Name, ty : PExpr, modifiers : AttributesAndModifiers, patternHack : PExpr = null)
    {
      this (loc, Splicable.Name(name), ty, modifiers, patternHack)
    }

    public this (loc : Location, name : Name, ty : PExpr, modifiers : AttributesAndModifiers, defval : option[PExpr], patternHack : PExpr = null)
    {
      this(loc, Splicable.Name(name), ty, modifiers, defval, patternHack)
    }

    public this (loc : Location, name : Splicable, ty : PExpr, modifiers : AttributesAndModifiers, defval : option[PExpr], patternHack : PExpr = null)
    {
      base (loc, name, modifiers);

      this.Type         = ty;
      ParsedType        = ty;
      this.PatternHack  = patternHack;
      ParsedPatternHack = patternHack;
      DefaultValue = defval;
      ParsedDefaultValue = defval;
    }

    public this (from : PExpr)
    {
      base (from.Location, null, AttributesAndModifiers(NemerleModifiers.None, []));

      def from_expr(e)
      {
        | PExpr.Ref (n)     =>
          def name       = Splicable.Name(n);
          def Type       = PExpr.Wildcard(from.Location);
          (name, Type)
        | PExpr.Spliced (s) =>
          def name       = Splicable.Expression(s);
          def Type       = PExpr.Wildcard(from.Location);
          (name, Type)

        | PExpr.TypeEnforcement (PExpr.Ref (n), t) =>
          def name = Splicable.Name (n);
          def Type = t;
          (name, Type)

        | PExpr.TypeEnforcement (PExpr.Spliced (s), t) =>
          def name = Splicable.Expression (s);
          def Type = t;
          (name, Type)
        | _ => throw System.ArgumentException ($"incorrect expression supplied for parameter creation: $from")
      }

      match (from)
      {
        | <[ $x = $d ]> with defval = Some(d) => def (name, type) = from_expr(x);
                                                  this.name = name;
                                                  this.Type = type;
                                                  this.ParsedType = type;
                                                  this.DefaultValue = defval;
                                                  this.ParsedDefaultValue = defval;

        | x                                    => def (name, type) = from_expr(x);
                                                  this.name = name;
                                                  this.Type = type;
                                                  this.ParsedType = type;
                                                  this.DefaultValue = None();
                                                  this.ParsedDefaultValue = None();

      }

    }

    public ReferencingExpr : PExpr
    {
      get
      {
        match (name)
        {
          | HalfId (n)
          | Name (n) => PExpr.Ref (name.Location.AsGenerated(), n)
          | Expression (e) => e
          | null => PExpr.Error()
        }
      }
    }

    public override ToString() : string
    {
      def str = $"$(this.Name) : $Type";
      match (DefaultValue)
      {
        | Some(d) => $"$str = $d"
        | _       => str
      }
    }
  }

  /// implemented by parse tree and typed tree function headers
  public interface IParametersProvider
  {
    ParametersDeclarations : list [PParameter] { get; }
    ParametersReferences : list [PExpr] { get; }
  }

  //public type Fun_header = PFunHeader;

  public class PFunHeader : ParsedBase, IParametersProvider
  {
    public   mutable TypeParameters : Typarms;
    public   mutable SplicableName  : Splicable; // is changed when typing lambda
    public   mutable ReturnType     : PExpr;
    public   mutable Parameters     : list[PParameter];

    public new TypedObject : T.TFunHeader { get { base.TypedObject :> T.TFunHeader } }

    // Values of following properties don't changing while typing process.

    public ParsedTypeParameters          : Typarms;
    public ParsedSplicableName           : Splicable;
    public ParsedReturnType              : PExpr;
    public ParsedParameters              : list[PParameter];
    [Accessor(flags=WantSetter), RecordIgnore] internal mutable _parsedParametersOpenLocation  : Location;
    [Accessor(flags=WantSetter), RecordIgnore] internal mutable _parsedParametersCloseLocation : Location;

    public this (loc : Location, name : Splicable, returnType : PExpr, parameters : list [PParameter])
    {
      this (loc, Typarms.Empty, name, returnType, parameters);
    }

    public this (typeParameters : Typarms, name : Splicable, returnType : PExpr, parameters : list [PParameter])
    {
      this (LocationStack.Top(), typeParameters, name, returnType, parameters)
    }

    public this (
      loc                     : Location,
      typeParameters          : Typarms,
      name                    : Splicable,
      returnType              : PExpr,
      parameters              : list [PParameter]
    )
    {
      this (loc, typeParameters, name, returnType, parameters, Location.Default, Location.Default)
    }

    public this (
      loc                     : Location,
      typeParameters          : Typarms,
      name                    : Splicable,
      returnType              : PExpr,
      parameters              : list [PParameter],
      parametersOpenLocation  : Location,
      parametersCloseLocation : Location,
    )
    {
      base(loc);
      ParsedTypeParameters           = typeParameters;
      ParsedSplicableName            = name;
      ParsedParameters               = parameters;
      ParsedReturnType               = returnType;
      TypeParameters                 = typeParameters;
      SplicableName                  = name;
      Parameters                     = parameters;
      ReturnType                     = returnType;
      _parsedParametersOpenLocation  = parametersOpenLocation;
      _parsedParametersCloseLocation = parametersCloseLocation;
    }

    public Name : string { get { ParsedSplicableName.ToString() } }

    public PName : Name { get { SplicableName.GetName() } }

    private ParametersDeclarations : list[PParameter] implements IParametersProvider.ParametersDeclarations
    { get { Parameters } }

    public ParametersReferences : list [PExpr]        implements IParametersProvider.ParametersReferences
    { get { Parameters.Map (_.ReferencingExpr) } }

    public override ToString() : string
    {
      $"$Name$TypeParameters(..$Parameters) : $ReturnType"
    }
  }

  public class Function_decl : ParsedBase
  {
    public this(header : PFunHeader, body : PExpr)
    {
      mutable loc;

      when (header != null)
        loc = header.Location;

      when (body != null)
        loc += body.Location;

      this(loc, header, body);
    }

    public this(location : Location, header : PFunHeader, body : PExpr)
    {
      base(location);
      this.header = header;
      this.body   = body;
    }

    public         header : PFunHeader;
    public mutable body   : PExpr;
  }

  [Record]
  public class MatchCase : ParsedBase
  {
    public this (patterns : list [PExpr], body : PExpr)
    {
      this (patterns, body, false)
    }

    public this (patterns : list [PExpr], body : PExpr, patternsLocation : Location, arrowLocation : Location)
    {
      this (patterns, body, false);
      _patternsLocation = patternsLocation;
      _arrowLocation    = arrowLocation;
    }

    public patterns : list [PExpr];
    public body : PExpr;
    public mutable disable_warnings : bool;

    [RecordIgnore, Accessor] mutable _patternsLocation : Location;
    [RecordIgnore, Accessor] mutable _arrowLocation    : Location;
    public BodyLocation     : Location { get { body.Location } }

    public override Location : Location
    {
      get
      {
        mutable loc = body.Location;

        patterns.Iter(p => loc = loc.Combine(p.Location));

        loc;
      }
    }

    public override ToString () : string
    {
      $"| $(patterns.ToString(\" | \")) => $body"
    }
  }

  [Record]
  public variant TryCase : ParsedBase
  {
    | Catch    { exn : Splicable; exn_ty : PExpr; handler : PExpr; }
    | Filter   { exn : Splicable; exn_ty : PExpr; filter : PExpr; handler : PExpr; }
    | Ellipsis { body : PExpr; }

    public new TypedObject : T.Try_case { get { base.TypedObject :> T.Try_case } }
  }

  public variant SyntaxElement {
    | Expression       { body : PExpr; }
    | MatchCase        { body : Parsetree.MatchCase; }
    | Function         { body : Function_decl; }
    | Parameter        { body : PParameter; }
    | TType            { body : PExpr; }

    | RawToken         { body : Token; }

    | ClassMember      { body : Parsetree.ClassMember; }
    | TypeBuilder      { body : Compiler.TypeBuilder; }
    | FieldBuilder     { body : Compiler.FieldBuilder; }
    | MethodBuilder    { body : Compiler.MethodBuilder; }
    | PropertyBuilder  { body : Compiler.PropertyBuilder; }
    | EventBuilder     { body : Compiler.EventBuilder; }
    | ParameterBuilder { body : Typedtree.TParameter; }

    public Location : Location {
      get {
        match (this) {
          | Expression (null)    | Parameter (null)        | TType (null)
          | ClassMember (null)   | ParameterBuilder (null) | FieldBuilder (null)
          | MethodBuilder (null) | PropertyBuilder  (null) | EventBuilder (null)
          | MatchCase (null)     | Function (null)         | RawToken (null)
          | TypeBuilder (null)                      => Location.Default;

          | Expression       (body : Located)
          | Parameter        (body : Located)
          | TType            (body : Located)
          | ClassMember      (body : Located)
          | ParameterBuilder (body : Located)       => body.Location;
          | FieldBuilder     (body : MemberBuilder)
          | MethodBuilder    (body : MemberBuilder)
          | PropertyBuilder  (body : MemberBuilder)
          | EventBuilder     (body : MemberBuilder) => body.Location;
          | MatchCase        (body)                 => body.Location;
          | Function         (body)                 => body.Location;
          | RawToken         (body)                 => body.Location;
          | TypeBuilder      (body)                 => body.Location;
        }
      }
    }

    public override ToString () : string {
      match (this) {
        | SyntaxElement.Expression (null) => ""
        | SyntaxElement.Expression (body) => body.ToString ()
        | SyntaxElement.TType (body)      => "ttype: " + body.ToString ()
        | SyntaxElement.RawToken (t)      => t.ToString ()
        | SyntaxElement.MatchCase         => "match case"
        | SyntaxElement.Function          => "function"
        | SyntaxElement.Parameter         => "parameter"

        | SyntaxElement.ClassMember       => "ClassMember"
        | SyntaxElement.TypeBuilder       => "TypeBuilder"
        | SyntaxElement.FieldBuilder      => "FieldBuilder"
        | SyntaxElement.MethodBuilder     => "MethodBuilder"
        | SyntaxElement.PropertyBuilder   => "PropertyBuilder"
        | SyntaxElement.EventBuilder      => "EventBuilder"
        | SyntaxElement.ParameterBuilder  => "ParameterBuilder"
      }
    }
  }
} // Nemerle.Compiler

