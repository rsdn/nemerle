/*
 * Copyright (c) 2003-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler.SolverMacros;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Surround;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Specialized;

using PT = Nemerle.Compiler.Parsetree;
using SCG = System.Collections.Generic;
using SC = System.Collections;

namespace Nemerle.Compiler
{
type NameToMethodsMap = Hashtable[string, list[FixedType.Class * IMethod]];
type IfaceMethod      = FixedType.Class * IMethod;
type IfaceMethods     = list[FixedType.Class * IMethod];

[Nemerle.Compiler.SupportRelocation]
public partial class TypeBuilder : TypeInfo
{
  type Subinfo = Map [TypeInfo, TypeInfo * list[FixedType]];

  mutable tydecl : TypeDeclaration;

  before_finalization   : Queue [void -> void] = Queue ();
  before_finalization2  : Queue [void -> void] = Queue ();

  _declaringType : TypeBuilder;
  internal mutable parent_type : FixedType.Class;
  internal mutable forced_typarms : list[StaticTypeVar];
  internal mutable reflection_inheritance_emitted : bool;
  internal mutable is_lambda : bool;
  mutable t_implements : list[FixedType.Class];
  [Accessor(DeclaredNestedTypes)]
  mutable contained_types       : list[TypeBuilder] = [];
  mutable variant_options       : list[TypeBuilder] = [];
  mutable member_list           : list[IMember] = [];
  mutable constant_object       : IField;
  mutable underlying_enum_type  : FixedType.Class;
  public UnimplementedMembers   : list[FixedType.Class * IMember] { get; private set; }

  //list of instance field initializers
  public mutable init_list : list[PT.PExpr] = [];

  [Accessor]
  mutable tenv : TypeVarEnv;

  internal mutable type_builder : System.Reflection.Emit.TypeBuilder;

  pt_name : PT.Name;
  name : string;
  mutable loc : Location;
  [Accessor] mutable parts_location : list[Location];
  modifiers : AttributesAndModifiers;
  accessibility : Accessibility;

  typarms_count : int;

  [Accessor (Ast)]
  mutable _ast : PT.TopDeclaration;
  mutable additional_decls : SCG.List [PT.ClassMember] = null;
  mutable partial_parts : list[PT.TopDeclaration] = [];

  mutable _nameLocation : Location;

  public override NameLocation : Location { get { _nameLocation } }

  public AstParts : list[PT.TopDeclaration]
  {
    get { _ast :: partial_parts }
  }

  [Accessor (flags = Override)]
  is_enum : bool;
  [Accessor (flags = WantSetter)]
  mutable is_finalized : bool;
  mutable cannot_finalize : bool;
  mutable m_has_been_used : bool;
  /// if it doesn't, we must add implicit empty constructor
  mutable instance_ctor_occured : bool;
  /// Marker for [TypeBuilder.Iter].
  internal mutable phase : int;
  mutable is_delegate : bool;

  public TyManager : TypesManager;

  /**
   * Defining type if any and transitive closure of base types of this type.
   *
   * Used by [TypeBuilder.Iter] function.
   */
  internal mutable iterate_first : list[TypeBuilder];

  mutable _userData : SC.IDictionary;

  public UserData : SC.IDictionary
  {
    get
    {
      when (_userData == null)
        _userData = ListDictionary();

      _userData
    }
  }

  public this (manager : TypesManager, par : TypeBuilder, td : PT.TopDeclaration,
                 ns_node : NamespaceTree.Node)
  {
    base (ns_node, manager.Manager, ns_node.GetDisplayName ());

    this.TyManager = manager;
    td._typeBuilder = this;

    Manager.Stats.AllTypeBuilders++;

    _ast          = td;
    pt_name       = td.PName;
    _nameLocation = td.NameLocation;

    when (this.GlobalEnv == null)
      Util.ice ($ "env is null for $(ns_node.GetDisplayName ())");

    _declaringType = par;

    when (par != null)
      par.contained_types = this :: par.contained_types;

    this.name = pt_name.Id;
    this.loc = td.Location;
    this.parts_location = [td.Location];
    modifiers = td.modifiers;
    attributes = modifiers.mods;

    instance_ctor_occured = td is PT.TopDeclaration.Alias;
    match (td)
    {
      | PT.TopDeclaration.VariantOption =>
        instance_ctor_occured = true;
        when (_declaringType != null)
          {
            def var_opts = _declaringType.variant_options;
            VariantOptionCode = var_opts.Length;
            _declaringType.variant_options = this :: var_opts;
          }
        attributes |= NemerleModifiers.Sealed;
        modifiers.custom_attrs = <[ Record ]> :: modifiers.custom_attrs;
        if (_declaringType != null && _declaringType.IsPublic)
          attributes |= NemerleModifiers.Public
        else
          attributes |= NemerleModifiers.Internal;

      | PT.TopDeclaration.Enum => is_enum = true;
      | _ => ()
    }

    ++Manager.tyinfo_counter;

    when (_ast.typarms != null)
      typarms_count = _ast.typarms.tyvars.Length;
    when (par != null)
      typarms_count += par.TyparmsCount;

    this.tydecl =
      match (_ast)
      {
        | Interface     => TypeDeclaration.Interface()
        | Alias         => TypeDeclaration.Alias(null)
        | VariantOption => _declaringType.tydecl = _declaringType.CreateVariant();
                           TypeDeclaration.VariantOption()
        | Variant       => CreateVariant()
        | _             => TypeDeclaration.Class() // may change later (in bind_types)
      };

    instance_ctor_occured = (attributes %&& (NemerleModifiers.Struct %| NemerleModifiers.Static))
                            || IsModule || instance_ctor_occured || IsInterface || is_enum;

    unless (attributes %&& NemerleModifiers.AccessModifiers)
      if (_declaringType != null)
        attributes |= NemerleModifiers.Private;
      else
        attributes |= NemerleModifiers.Internal;

    accessibility =
      match (attributes %& NemerleModifiers.AccessModifiers) {
        | NemerleModifiers.Private => Accessibility.Private
        | NemerleModifiers.Protected => Accessibility.Protected
        | NemerleModifiers.Internal => Accessibility.Internal
        | _ =>
          if (attributes %&& (NemerleModifiers.Protected %| NemerleModifiers.Internal))
            Accessibility.ProtectedOrInternal
          else
            Accessibility.Public
      }

    when (_declaringType != null)
      accessibility = FixedType.AccessibilityIntersect(accessibility, _declaringType.Accessibility);

    CheckTypeAttributes ();

    m_has_been_used = IsExternallyAccessible;
  }

  CreateVariant() : TypeDeclaration.Variant
  {
    TypeDeclaration.Variant(variant_options.Map(_  : TypeInfo))
  }
  
  public override IsInterface : bool
  {
    get { if (TyManager.run_phase <= 2)
            _ast is PT.TopDeclaration.Interface
          else
            tydecl is TypeDeclaration.Interface
        }
  }

  public override IsDelegate : bool
  {
    get {
     if (TyManager.run_phase <= 2)
       is_delegate
     else
       InternalType.MulticastDelegate_tc.Equals (BaseType)
    }
  }

  public IsAlias : bool
  {
    get { if (TyManager.run_phase <= 2)
            _ast is PT.TopDeclaration.Alias
          else
            tydecl is TypeDeclaration.Alias
        }
  }

  public IsStruct : bool
  {
    get { attributes %&& NemerleModifiers.Struct }
  }

  public override IsValueType : bool
  {
    get { IsStruct || is_enum }
  }

  //TODO: Move it member to parent class
  public /*override*/ IsVariantOption : bool
  {
    get
    {
      if (TyManager.run_phase <= 2)
        _ast is PT.TopDeclaration.VariantOption
      else
        tydecl is TypeDeclaration.VariantOption
    }
  }

  public override GetModifiers () : AttributesAndModifiers
  {
    modifiers
  }

  public override IsCustomAttributeDefined(attributeFullName : string) : bool
  {
    modifiers.IsCustomAttributeDefined(attributeFullName, this.GlobalEnv)
  }

  public override GlobalEnv : GlobalEnv
  {
    get { pt_name.context }
  }

  public ParsedName : PT.Name
  {
    get { pt_name }
  }

  public ParsedDeclaration : PT.TopDeclaration
  {
    get { _ast }
  }

  public ParsedTypeName : PT.PExpr
  {
    get {
      match (typarms) {
        | [] => <[ $(pt_name : name) ]>
        | _ =>
          def tparms = typarms.Map (fun (x) { <[ $(pt_name.NewName (x.Name) : name) ]> });
          <[ $(pt_name : name).[.. $tparms ] ]>
      }
    }
  }

  /// Return type we were defined in (null for toplevel types).
  public override DeclaringType : TypeInfo { get { _declaringType } }

  /// Return name without any dots.
  public override Name : string { get { name } }

  public override Accessibility : Accessibility
  {
    get { accessibility }
  }

  public override IsExternallyAccessible : bool
  {
    get
    {
      match (accessibility)
      {
        | Accessibility.Public
        | Accessibility.Protected
        | Accessibility.ProtectedOrInternal => true
        | _ => false
      }
    }
  }

  public override UnderlyingType : TypeInfo
  {
    get
    {
      assert (underlying_enum_type != null);
      underlying_enum_type.tycon
    }
  }

  public override Location : Location
  {
    get { loc }
  }

  public SetLocation (loc : Location) : void
  {
    this.loc = loc;
  }

  public override HasBeenUsed : bool
  {
    get { m_has_been_used }
    set
    {
      base.HasBeenUsed = value;
      m_has_been_used = true;

      when (_declaringType != null)
        Manager.MarkAsUsed(_declaringType, value)
    }
  }

  /// Count of type parameters declared in this type (without type parameters of outer types)
  public override DeclaredTypeParametersCount : int
  {
    get { Ast.DeclaredTypeParametersCount }
  }

  /// Count of type parameters in this type and all outer types
  public override TyparmsCount : int
  {
    get
    {
      if (typarms is [])
        typarms_count
      else
        base.TyparmsCount
    }
  }

  public AddImplementedInterface(t : PT.PExpr) : void
  {
    when (t_implements != null)
      Message.Error(t.Location, "The AddImplementedInterface method can be called only before MacroPhase.BeforeTypedMembers phase.");

    match (_ast)
    {
      | PT.TopDeclaration.Class     as td => td.t_extends += [t]
      | PT.TopDeclaration.Interface as td => td.t_extends += [t]
      | PT.TopDeclaration.Variant   as td => td.t_extends += [t]
      | _ =>
        Message.Error(t.Location, $"cannot add interface to $(_ast.GetType().Name.ToLower()) ($(_ast.Name)).");
    }
  }

  public DefineNestedType(td : PT.ClassMember.TypeDeclaration, do_fixup : bool) : TypeBuilder
  {
    def tyinfo = Manager.NameTree.AddType(this, namespace_nd, td.td);

    when (TyManager.run_phase > 2)
      tyinfo.add_special_variant_methods();

    when (do_fixup)
      tyinfo.FixupDefinedClass();

    tyinfo
  }

  public DefineNestedType (td : PT.ClassMember.TypeDeclaration) : TypeBuilder
  {
    DefineNestedType (td, true)
  }


  /**
   * Adds a definition and returns the new MemberBuilder, if available
   */
  public DefineAndReturn(f : PT.ClassMember) : MemberBuilder
  {
    // properties added with quotations have broken names for accessors, fix it
    match (f)
    {
      | Property(getter = Some(d)) when d.Name == "get_" =>
        d.name = PT.Splicable.Name(PT.Name("get_" + f.Name))

      | Property(setter = Some(d)) when d.Name == "set_" =>
        d.name = PT.Splicable.Name(PT.Name("set_" + f.Name))

      | _ => ()
    }

    when (member_map == null)
      AddToAdditionalDecls(f);

    add_macros_from_parsedmems (f, MacroPhase.BeforeInheritance);
    add_macros_from_parsedmems (f, MacroPhase.BeforeTypedMembers);

    if (member_map == null)
      null
    else {
      try {
        def mem = bind_and_add_member (f);
        TyManager.ExpandMacros ();
        when (TyManager.IsEmitting) {
          TyManager.EnsureEmitProgress (this);
          when (IsFinalized)
            TyManager.MaybeCompile (this, mem);
        }
        mem
      } catch {
        | _ is Recovery => null
      }
    }
  }

  public DefineAndReturn(f : PT.ClassMember, do_fixup : bool) : MemberBuilder
  {
    match (f)
    {
      | PT.ClassMember.TypeDeclaration (Delegate (header) as td) =>
        _ = Delegates.GenerateDelegateClass (this.GlobalEnv, this, td.modifiers, td.ReturnValueModifiers, header);
        null

      | PT.ClassMember.TypeDeclaration as td =>
        _ = DefineNestedType (td, do_fixup);
        null

      | _ => DefineAndReturn(f)
    }
  }

  public DefineWithSource (f : PT.ClassMember, do_fixup = true) : MemberBuilder
  {
    TyManager.GenerateFakeSourceCode (f);
    DefineAndReturn (f, do_fixup)
  }

  public Define(f : PT.ClassMember) : void
  { Define(f, true) }

  /**
   * Adds a definition to this type
   */
  public Define(f : PT.ClassMember, do_fixup : bool) : void
  {
    _ = DefineAndReturn(f, do_fixup)
  }


  /**
   * Builds this type
   */
  public Compile () : void
  {
    unless (cannot_finalize) Nemerle.Imperative.Return (); // avoid repeated calls

    cannot_finalize = false;

    when (TyManager.run_phase >= 7)
    {
      // Message.Debug ($"comp: $this");
      add_constant_variant_ctors();
      when (Attributes %&& NemerleModifiers.SpecialName)
        mark_members_with_special_name();
      unless (IsInterface)
        resolve_method_implements();
      check_ctor_constraints();
    }

    when (TyManager.IsEmitting)
    {
      // Message.Debug ($"emitimpl: $this -- $(GetDirectMembers ())");
      this.CreateEmitDeclarations();
    }

    Manager.Solver.Enqueue(
      fun()
      {
        when (TyManager.run_phase >= 5)
        {
          when (TyManager.IsEmitting)
          {
            // Message.Debug($"emitimpl: $this -- $(GetDirectMembers ())");
            this.EmitImplementation();
          }
        }

        Manager.MarkTypeBuilderCompiled();
      })
  }

  public FindAttributeWithArgs(lookingFor : TypeInfo) : option[PT.PExpr * list[PT.PExpr]]
  {
    GetModifiers().FindAttributeWithArgs(lookingFor, this.GlobalEnv)
  }

  public FindAttributesWithArgs (lookingFor : TypeInfo) : list[PT.PExpr * list[PT.PExpr]]
  {
    GetModifiers().FindAttributesWithArgs(lookingFor, this.GlobalEnv)
  }

  public FindAttribute(lookingFor : TypeInfo) : option [PT.PExpr]
  {
    GetModifiers().FindAttribute(lookingFor, this.GlobalEnv)
  }

  public override AttributeTargets : System.AttributeTargets
  {
    get {
      // FIXME:
      System.AttributeTargets.All
    }
  }

  public override HasAttribute (attribute : TypeInfo) : bool
  {
     Option.IsSome (FindAttribute (attribute))
  }

  public DisableImplicitConstructor () : void
  {
    instance_ctor_occured = true;
  }

  public DoBeforeFinalization (action : void -> void) : void
  {
    before_finalization.Push (action);
  }

  public DoBeforeFinalization2 (action : void -> void) : void
  {
    before_finalization2.Push (action);
  }

  /**
   * Marks this with the SpecialName attribute, the attribute will
   * be propagated to members and contained types at a later stage.
   */
  public MarkWithSpecialName () : void
  {
    attributes |= NemerleModifiers.SpecialName
  }

  internal MarkAsDelegate () : void
  {
    is_delegate = true;
    MarkWithSpecialName ();
  }

  /**
   * Return list of types that we directly subtype.
   *
   * <remarks>
   *   This includes [extends] and [implements], as well as parent variant
   *   type for variant options.
   * </remarks>
   */
  public override GetDirectSuperTypes() : list[FixedType.Class]
  {
    match (parent_type)
    {
      | null  => t_implements
      | t     => t :: t_implements
    }
  }

  public override GetConstantObject () : IField
  {
    constant_object
  }

  /** Returns null if there isn't any */
  public override BaseType : TypeInfo
  {
    get {
      if (parent_type != null) parent_type.tycon else null
    }
  }

  /** Return type we extend if any. */
  public override SuperClass () : option [TypeInfo]
  {
    match (parent_type) {
      | null => None ()
      | _ => Some (parent_type.tycon)
    }
  }

  public override GetTydecl () : TypeDeclaration
  {
    tydecl
  }

  public override LookupMemberAvailable : bool
  {
    get { member_map != null }
  }

  public override LookupMemberImpl (name : string) : list[IMember]
  {
    match (member_map.Get (name)) {
      | None => []
      | Some (mems) =>
        // FIXME!!!!
        mems.Filter (fun (mem) { mem.DeclaringType.Equals (this) })
    }
  }

  /** Searches for the members defined for the current TypeInfo, using the specified
      binding constraints.

      <remarks>
        Members include properties, methods, fields, events, and so on.

        The following BindingFlags filter flags can be used to define which members to
        include in the search:
        <ul>
          <li>
            You must specify either BindingFlags.Instance or BindingFlags.Static in order to
            get a return.
          </li>
          <li>
            Specify BindingFlags.Public to include public members in the search.
          </li>
          <li>
            Specify BindingFlags.NonPublic to include non-public members (that is, private
            and protected members) in the search.
          </li>
        </ul>

        The following BindingFlags modifier flags can be used to change how the search
        works:

        BindingFlags.DeclaredOnly to search only the members declared on the TType,
        not members that were simply inherited.

        Calling this method with only the Public flag or only the NonPublic flag will
        return the specified members and does not require any other flags.

        See Nemerle.Compiler.BindingFlags for more information.
      </remarks>
   */
  public override GetMembers (bindingAttr : BindingFlags) : list[IMember]
  {
    get_members (bindingAttr, fun (m : IMember) {
      constrain_member (m, bindingAttr)
    })
  }

  public override GetMembers () : list[IMember]
  {
    get_members (0 :> BindingFlags, fun (_ : IMember) { true })
  }

  public GetParsedMembers(includeManuallyDefined : bool = false) : list[PT.ClassMember]
  {
    def result = SCG.List();

    unless (IsEnum)
      foreach (p in AstParts)
        result.AddRange(p.GetMembers());

    when (includeManuallyDefined && additional_decls != null)
      result.AddRange(additional_decls);

    result.NToList()
  }

  public override GetFields (bindingAttr : BindingFlags) : list[IField]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      x.MemberKind == MemberKinds.Field && constrain_member (x, bindingAttr)
    });
    NList.Map (mems, fun (x) { x :> IField })
  }

  public GetFields () : list[IField]
  {
    def mems = get_members ((0 :> BindingFlags), x => x.MemberKind == MemberKinds.Field);
    NList.Map (mems, fun (x) { x :> IField })
  }


  /** Searches for the methods defined for the current TypeInfo, using the
      specified binding constraints.
  */
  public GetMethods (bindingAttr : BindingFlags) : list[IMethod]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      if (x.MemberKind == MemberKinds.Method)
        constrain_member (x, bindingAttr)
      else
        false
    });
    NList.Map (mems, fun (x) { x :> IMethod })
  }

  public GetMethods () : list[IMethod]
  {
    GetMethods (BindingFlags.Static %| BindingFlags.Instance %|
                BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the constructors defined for the current TypeBuilder, using the
      specified BindingFlags.
  */
  public override GetConstructors (bindingAttr : BindingFlags) : list[IMethod]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      if (x.MemberKind == MemberKinds.Constructor)
        constrain_member (x, bindingAttr)
      else
        false
    });
    NList.Map (mems, fun (x) { x :> IMethod })
  }

  public GetConstructors () : list[IMethod]
  {
    GetConstructors (BindingFlags.Static %| BindingFlags.Instance %|
                     BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the types defined for the current TypeInfo, using the
      specified BindingFlags.
  */
  public GetNestedTypes (bindingAttr : BindingFlags) : list[TypeInfo]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      x.MemberKind == MemberKinds.NestedType &&
      constrain_member (x, bindingAttr | BindingFlags.Static | BindingFlags.Instance)
    });
    NList.Map (mems, fun (x) { x :> TypeInfo })
  }

  public GetNestedTypes () : list[TypeInfo]
  {
    GetNestedTypes (BindingFlags.Static %| BindingFlags.Instance %|
                    BindingFlags.Public %| BindingFlags.NonPublic)
  }

  public GetProperties (bindingAttr : BindingFlags) : list[IProperty]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      x.MemberKind == MemberKinds.Property && constrain_member (x, bindingAttr)
    });
    NList.Map (mems, fun (x) { x :> IProperty })
  }

  public GetProperties () : list[IProperty]
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      x.MemberKind == MemberKinds.Property
    });
    NList.Map (mems, fun (x) { x :> IProperty })
  }

  public GetEvents (bindingAttr : BindingFlags) : list[IEvent]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      x.MemberKind == MemberKinds.Event && constrain_member (x, bindingAttr)
    });
    NList.Map (mems, fun (x) { x :> IEvent })
  }

  public GetEvents () : list[IEvent]
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      x.MemberKind == MemberKinds.Event
    });
    NList.Map (mems, fun (x) { x :> IEvent })
  }

  /** Return list of all members defined in this very type. */
  public GetDirectMembers () : list[IMember]
  {
    member_list
  }

  public GetTypeBuilder () : System.Reflection.Emit.TypeBuilder
  {
    assert (type_builder != null);
    type_builder
  }

  public GetVariantOptionParent () : TypeBuilder
  {
    assert (_declaringType != null);
    _declaringType
  }

  public GetVariantOptions () : list[TypeBuilder]
  {
    variant_options
  }

  //------------ METHODS FOR TYPING --------------------------------------

  internal ReverseChildren() : void
  {
    contained_types = NList.Rev(contained_types);
    variant_options = NList.Rev(variant_options);
  }

  /**
   * Construct typing environments for each declaration.
   *
   * <remarks>
   *   The first thing to do is to create typing environment [Tyvar.TEnv]
   *   for each type declaration.  Then typing environment is populated
   *   with type variables (transformed into [Tyvar.T] objects).  Finally
   *   constraints (type expressions, which are first bound) of each
   *   type variable are stored in [Tyvar.T].
   *
   *   Typing environment maps names of type variables to [Tyvar.T] objects.
   * </remarks>
   */
  protected internal make_tyenvs () : void
  {
    assert (this.tenv == null);
    def tenv = TypeVarEnv (Manager);
    mutable incorrectTyParamsParts = [];

    match (this._ast.typarms)
    {
      | null =>
        this.tenv = tenv;
        this.typarms = [];

      | ps =>
        // we must merge type parameter constrains from partial parts of this class
        def processPart(part : PT.TopDeclaration, acc : PT.Typarms)
        {
          mutable new_constr = acc.constraints;

          def tparms =
            match (part)
            {
              | PT.TopDeclaration.Class    (typarms = t) => t
              | PT.TopDeclaration.Variant  (typarms = t) => t
              | PT.TopDeclaration.Interface(typarms = t) => t
              | _ => Util.ice ("non class / variant")
            };

          when (!tparms.tyvars.Equals(_ast.typarms.tyvars))
            incorrectTyParamsParts ::= (tparms, part);

          foreach (constr in tparms.constraints)
          {
            mutable should_add = true;

            foreach (con in ps.constraints)
              when (con.tyvar.GetName().Equals (constr.tyvar.GetName()))
                should_add = false;

            when (should_add)
              new_constr = constr :: new_constr;
          }

          if (new_constr : object != acc.constraints) PT.Typarms (acc.tyvars, new_constr)
          else                                        acc
        }

        def ps = partial_parts.FoldLeft(ps, processPart);

        unless (incorrectTyParamsParts.IsEmpty)
        {
          def getLoc(part)
          {
            if (part.TypeParametersLocation == Location.Default) part.NameLocation
            else part.TypeParametersLocation
          }
          surroundwith (related_messages)
          {
            Message.Error(getLoc(_ast),
              $"partial declarations of `$this' must have the same type parameter names in the same order");
            foreach ((tparms, part) in incorrectTyParamsParts)
              Message.Hint(getLoc(part).FromStart(), $"other part ($tparms)");
          }
        }


        (this.tenv, this.typarms) = tenv.AddTyparms (this.GlobalEnv, ps, this, check_parms = false);
    }

    when (forced_typarms != null) {
      Util.cassert (typarms.IsEmpty);
      typarms = forced_typarms;
      forced_typarms = null;
    }

    // after we updated parsed tenvs of types with partial parts
    // we should copy them to nested types
    // we do this using parsetrees, so the fresh StaticVars are used
    unless (this._ast.typarms == null)
    {
      def ht = Hashtable ();

      foreach (tv in this._ast.typarms.tyvars)
      {
        def nm = tv.GetName ();
        if (ht.Contains (nm))
          Message.Error ($"duplicate type parameter `$nm'")
        else ht [nm] = null;
      }

      foreach (x in contained_types)
      {
        def x = x.ParsedDeclaration;
        if (x.typarms == null)
          x.typarms = this._ast.typarms;
        else
        {
          def tp1 = this._ast.typarms;
          def tp2 = x.typarms;
          foreach (tv in tp2.tyvars)
            when (ht.Contains (tv.GetName ()))
            {
              Message.Error(x.Location,
                $"type parameter `$(tv.GetName())' has the same name as type parameter from the outer type `$(this)'");
              Message.Hint("type parameters are inherited in nested types and can be used without declaring them explicitly");
            }

          x.typarms = PT.Typarms (tp1.tyvars + tp2.tyvars, tp1.constraints + tp2.constraints);
        }
      }
    }

    match (_ast)
    {
      | PT.TopDeclaration.VariantOption (members) =>
        unless (Util.is_capitalized (name))
          Message.Error(NameLocation, "variant options' names must start with capital letter");

        foreach (mem in members)
          unless (mem.Attributes %&& NemerleModifiers.AccessModifiers)
            mem.Attributes |= NemerleModifiers.Public;

      | PT.TopDeclaration.Variant =>  attributes |= NemerleModifiers.Abstract
      | PT.TopDeclaration.Enum when !this.typarms.IsEmpty =>
        Message.Error ("enums cannot have generic type parameters");
      | _ => ()
    }

    self_type = FixedType.Class (this, this.typarms.Map (FixedType.StaticTypeVarRef (_)));

    foreach (tb in this.contained_types)
      Util.locate (tb.loc, tb.make_tyenvs ());
  }

  mutable _nestingLevel : int;

  [Record] class RecursiveTypeDefinition : Exception { public Name : string;  }

  private TryAddSuperType(ty : FixedType.Class) : void
  {
    unless (_superTypesLookup.Contains(ty))
    {
      def tc = ty.tycon;
      _superTypeInfosLookup[tc] = ty :: _superTypeInfosLookup[tc];
      _superTypesLookup.Add(ty, 0);
      _superTypes ::= ty;
    }
  }

  private AddSuperType(ty : FixedType.Class) : void
  {
    def tc = ty.tycon;
    _superTypeInfosLookup[tc] = [ty];
    _superTypesLookup.Add(ty, 0);
    _superTypes ::= ty;
  }

  /// Bind type expressions occurring in type declarations. This
  /// includes [extends] type, [implements] list, and aliased type
  /// in case of type alias declaration.
  ///
  /// <remarks>
  ///   Binding type expression refers to rewriting [Parsetree.Type]
  ///   into [Typedtree.TType], which involves resolving names of type
  ///   constructors (to [TypeInfo] objects) and type variables (to [Tyvar.T]
  ///   objects).
  /// </remarks>
  protected internal bind_types() : void
  {
    when (this.tydecl is TypeDeclaration.Alias(ty) when ty != null)
      return; // already was binded

    when (_nestingLevel > 0)
    {
      Message.Error(NameLocation, $"The type '$this' has recursive definition.");
      throw RecursiveTypeDefinition(FullName);
    }

    _nestingLevel++;

    try
    {
      def td = this._ast;
      is_obsolete = HasAttribute (InternalType.Obsolete_tc);
      this.tenv = this.tenv.CopyWithObsolete (!is_obsolete);

      _conditions =
        if(HasAttribute(InternalType.Conditional_tc))
          FindAttributesWithArgs(InternalType.Conditional_tc)
          .FoldLeft([], fun(_)
          {
            | ((_, [<[ $(condition : string) ]>]), acc)
            | ((_, [<[ ConditionString = $(condition : string) ]>]), acc) =>
              condition :: acc

            | (_, acc) => acc
          })
        else
          [];

      this.tydecl =
        match (td)
        {
          | PT.TopDeclaration.Class         => TypeDeclaration.Class ()
          | PT.TopDeclaration.Alias(t)      =>
            match (this.tydecl)
            {
              | TypeDeclaration.Alias(null) =>
                def ttype = this.tenv.BindFixedType(this.GlobalEnv, this, t, check_parms = false);
                TypeDeclaration.Alias(ttype)

              | _ => Util.ice("The 'tydecl' field of alias must have TypeDeclaration.Alias(null) type.")
            }

          | PT.TopDeclaration.Interface     => TypeDeclaration.Interface ()
          | PT.TopDeclaration.Enum          => TypeDeclaration.Enum ()
          | PT.TopDeclaration.Variant       =>
            TypeDeclaration.Variant(variant_options.Map(fun (x : TypeBuilder) : TypeInfo { x }))

          | PT.TopDeclaration.VariantOption => TypeDeclaration.VariantOption ()
          | PT.TopDeclaration.Delegate
          | PT.TopDeclaration.Macro         => Util.ice ("this top declaration shouldn't survive to typing")
        };

      def nested_tyvars_subst =
        if (_declaringType == null || _declaringType.typarms is [] || typarms is [])
          null
        else
        {
          def sub         = Subst();
          def par_typarms = _declaringType.typarms;

          //Message.Debug ($"my typarms=$typarms vs eclosing=$par_typarms");
          NList.Iter2(typarms.FirstN (par_typarms.Length), par_typarms, fun (t, pt)
          {
            sub.Add(pt, FixedType.StaticTypeVarRef(t))
          });

          sub
        };

      def bind_to_class(t : PT.PExpr)
      {
        match (this.tenv.BindFixedType(this.GlobalEnv, _declaringType, t, check_parms = false))
        {
          | FixedType.Class as tcl =>
            if (nested_tyvars_subst == null) tcl
            else nested_tyvars_subst.Apply(tcl) :> FixedType.Class

          | _ =>
            Message.FatalError2(t.Location, "derived or implemented type must be a class, struct or interface");
            null
        };
      }

      this.t_implements = [];
      //_directImplementedInterfaces = [];

      match (td)
      {
        | PT.TopDeclaration.VariantOption =>
          this.parent_type =  FixedType.Class(_declaringType, typarms.Map(FixedType.StaticTypeVarRef(_)));

        | PT.TopDeclaration.Class (t_extends = hd :: tl)
        | PT.TopDeclaration.Interface (t_extends = hd :: tl)
        | PT.TopDeclaration.Variant (t_extends = hd :: tl)
        | PT.TopDeclaration.Enum (t_extends = hd :: tl) =>
          def hd1 = bind_to_class (hd);
          def itfs = SCG.List();

          if (hd1 == null)
            this.parent_type = null
          else if (hd1.tycon.IsInterface)
          {
            itfs.Add(hd1);
            this.parent_type = null
          }
          else
            this.parent_type = hd1;

          foreach (itf in tl)
          {
            def bindItf = bind_to_class (itf);

            when (bindItf != null)
              itfs.Add(bindItf);
          }

          this.t_implements = itfs.NToList();

          //foreach (itf in this.t_implements)
          //  itfs.tycon.GetDirectSuperTypes();

          //_directImplementedInterfaces = itfs.ToList();

        | _ => this.parent_type = null
      }

      // merge types implemented by partial parts of this class into this TypeBuilder
      foreach (part in partial_parts)
      {
        match (part)
        {
          | PT.TopDeclaration.Interface (t_extends = hd :: tail)
          | PT.TopDeclaration.Class     (t_extends = hd :: tail)
          | PT.TopDeclaration.Variant   (t_extends = hd :: tail) =>
            def hd2 = bind_to_class (hd);
            def added_ifaces =
              if (hd2.tycon.IsInterface)
                [hd2]
              else
              {
                // if base class exists in both parts, it must be the same
                match (parent_type)
                {
                  | null => parent_type = hd2
                  | t =>
                    unless (t.tycon.Equals (hd2.tycon))
                      Message.Error(part.Location, $"Partial declarations of `$(FullName)' must not specify different base classes")
                }

                []
              };

            // here we merge new interface, removing already declared ones (no errors here)
            foreach (iface when iface != null in added_ifaces + NList.RevMap (tail, bind_to_class))
            {
              mutable should_add = true;

              foreach (existing in t_implements)
                when (existing.tycon.Equals(iface.tycon))
                  should_add = false;

              when (should_add)
                t_implements = iface :: t_implements;
            }

          | _ => ()
        }
      }

      // detect non-interfaces
      foreach (t in t_implements)
        unless (t.tycon.IsInterface)
          Message.Error ($"base class `$t' must be specified as first");

      when (is_enum)
        handle_underlying_enum_type ();

      when (IsStruct)
      {
        // make sure no bogus attributes have been specified
        def access_mask = NemerleModifiers.AccessModifiers %| NemerleModifiers.Struct | NemerleModifiers.Partial;
        when ((attributes %& ~access_mask) != NemerleModifiers.None)
          Message.Error (loc, "structures are only allowed to have access specifiers as attributes");

        // mark the structure as sealed
        attributes |= NemerleModifiers.Sealed;
      }

      match (parent_type)
      {
        | null =>
          unless (IsInterface || IsAlias)
          {
            parent_type =
              // make the structure inherit from System.ValueType
              if (IsStruct)
                InternalType.ValueType;
              else
                InternalType.Object;
          }

        | tclass =>
          if (IsInterface)
          {
            Message.Error (loc, "interfaces are not allowed to inherit from other types");
            parent_type = null;
          }
          else when (parent_type.tycon.GetTydecl () is TypeDeclaration.Variant
            && !(tydecl is TypeDeclaration.VariantOption))
          {
              // change current type, so we don't get junk warnings about GetVariantCode
              tydecl = TypeDeclaration.Class ();
              Message.Error (loc, "cannot use variant as base type");
          }

          when (IsStruct)
          {
            Message.Error (loc, "structures are not allowed to inherit from other types");
            parent_type = InternalType.ValueType
          }

          when (tclass.tycon.IsSealed)
          {
            Message.Error (loc, "cannot extend sealed class");
            parent_type = InternalType.Object
          }
          when (tclass.tycon.Attributes %&& NemerleModifiers.Static)
            Message.Error (loc, "cannot derive from module");
      }

      // construct this.iterate_first - enclosing type plus transitive closure of all base types
      def iterate_first = Hashtable ();

      foreach (ty : FixedType.Class in GetDirectSuperTypes ())
        match (ty.tycon)
        {
          | tb is TypeBuilder =>
            iterate_first.Set (tb, tb)
          | _ => ()
        }

      def first = if (_declaringType != null) [_declaringType] else [];
      this.iterate_first = iterate_first.Fold (first, fun (_, ti, acc) { ti :: acc });

      foreach (x in contained_types)
        Util.locate (x.loc, x.bind_types ());

      // check variance limitation to interface/delegate type
      if (IsInterface || IsDelegate)
        unless (typarms.IsEmpty)
          foreach (ty in GetDirectSuperTypes ())
            unless (MethodBuilder.IsVarianceValid(ty, 1))
              Message.Error ($"incorrect usage of generic parameters in `$ty' - supertypes must behave covariantly or contravariantly accordingly");
      else
        foreach (t when t.IsCovariant || t.IsContravariant in typarms)
        {
          Message.Error (".NET runtime allows specifying co/contravariant generic parameters only on interfaces and delegates");
          Message.Hint ("vote here to change this miserable state: http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=94145");
        }
    }
    finally { _nestingLevel--; }
  }

  internal construct_subtyping_map() : void
  {
    def add_srs(t : FixedType.Class, s : Subinfo)
    {
      add_subtyping_of(s, t.tycon, t.args)
    }

    def subst = FreshSubst();
    def subtypesGroupedByTypeInfo = GetDirectSuperTypes().Grouping(ty => (ty.tycon, (ty, subst.Apply(ty).Fix())));

    foreach (types when types.Count > 1 in subtypesGroupedByTypeInfo.Values)
    {
      def reported = Hashtable();
      foreach ((ty1Source, ty1) in types with i1)
        foreach ((ty2Source, ty2) when i1 != i2 && !reported.Contains(ty1, ty2) && ty1.TryUnify(ty2) in types with i2)
        {
          reported[ty1, ty2] = 0;
          reported[ty2, ty1] = 0;
          Message.Error(NameLocation, $"'$this' cannot implement both '$ty1Source' and '$ty2Source' because they may unify for some type parameter substitutions");
        }
    }

    _                                             = GetDirectSuperTypes().FoldLeft(Map(), add_srs);
    _superTypeInfosLookup[InternalType.Object_tc] = [InternalType.Object];
    _superTypeInfosLookup[this]                   = [GetMemType()];
    _superTypes                                   = _superTypes.Reverse();
    _superTypesCalculated                         = true;

    // we should do the additional accessibility checks, which could have
    // been loosened during bind_types, when supertypes were null
    foreach (t in GetDirectSuperTypes())
      unless (t.IsAccessibleFrom(this))
        Message.Error($"$t is inaccessible from $this");

    foreach (t in typarms)
      foreach (ct in t.Constraints)
        unless (ct.IsAccessibleFrom(this))
          Message.Error($"$ct is inaccessible from $this");

    when (!this.typarms.IsEmpty && HasSuperType(InternalType.Attribute_tc))
      Message.Error($"A generic type cannot derive from `$parent_type' because it is an attribute class");
  }

  add_subtyping_of(subinfo : Subinfo, tc : TypeInfo, args : list[TypeVar]) : Subinfo
  {
    def add_sr(subinfo : Subinfo, subtyped : TypeInfo, args : list[FixedType])
    {
      def ty = FixedType.Class(subtyped, args.Map(x => x));

      match (subinfo.Find(subtyped))
      {
        | Some =>
          TryAddSuperType(ty);
          subinfo

        | None =>
          AddSuperType(ty);
          subinfo.Add(subtyped, (subtyped, args))
      }
    }

    def sub = tc.MakeUncheckedSubst(args);

    def add_srt(t : FixedType.Class, subinfo : Subinfo)
    {
      def sub2 = sub;
      _ = sub2;
      def tyArgs = t.args.Map((t : TypeVar) => sub.Apply(t.Fix()).Fix());
      add_sr(subinfo, t.tycon, tyArgs)
    }

    def subinfo = tc.GetSuperTypes().FoldLeft(subinfo, add_srt);
    def subinfo = add_sr(subinfo, tc, Solver.FixedValues(args));

    subinfo
  }

  add_derived_members() : void
  {
    def get_members (t : FixedType.Class)
    {
      t.tycon.GetMembers ()
    }
    def members =
      if (IsInterface)
        NList.Concat (NList.RevMap (GetDirectSuperTypes (), get_members))
      else match (parent_type)
      {
        | null  => []
        | t     => get_members (t)
      }

    def inherit_it (mem : IMember)
    {
      !(mem.MemberKind %&& MemberKinds.Constructor || mem.Attributes %&& NemerleModifiers.Private)
    };

    member_map = Hashtable();

    foreach (mem in members)
      when (inherit_it(mem))
        add_member_by_name(mem);

    member_list = []
  }

  internal ExtendPartialClass(additional : PT.TopDeclaration) : void
  {
    if ((Attributes %& additional.Attributes) %&& NemerleModifiers.Partial)
    {
      unless (additional.Attributes %&& NemerleModifiers.AccessModifiers)
        match (_declaringType)
        {
          | null => additional.Attributes |= NemerleModifiers.Internal;
          | _    => additional.Attributes |= NemerleModifiers.Private;
        }
      // we allow abstract and sealed to be specified just on one arbitratry part
      attributes            |= additional.Attributes & (NemerleModifiers.Abstract | NemerleModifiers.Sealed);
      additional.Attributes |= attributes            & (NemerleModifiers.Abstract | NemerleModifiers.Sealed);

      when (additional.Attributes != attributes)
        Message.Error (additional.Location, $"joined partial classes `$(FullName)' must have compatible modifiers");
    }
    else
    {
      Message.Error (additional.Location, $"you must specify `partial' modifier on all declarations of type `$(FullName)'");
      Message.Error (this.Location, "first defined here");
    }

    match (additional)
    {
      | PT.TopDeclaration.Interface
      | PT.TopDeclaration.Class
      | PT.TopDeclaration.Variant    =>
        partial_parts ::= additional;
        additional._typeBuilder = this;

        this.parts_location ::= additional.Location;

      | _ => Message.Error (additional.Location, "`partial' modifier can be used only before `class', `struct', `interface' or `variant'")
    }

    modifiers.custom_attrs += additional.GetCustomAttributes ();
  }


  internal static constrain_member(m : IMember, flags : BindingFlags) : bool
  {
    def is_public = m.Attributes %&& NemerleModifiers.Public;
    // if flag is Public then always return all public members
    flags == BindingFlags.Public && is_public
    // if flag is NonPublic then always return all nonpublic members
      || flags == BindingFlags.NonPublic && !is_public
    // masks
      || (!m.IsStatic || flags %&& BindingFlags.Static)
        && (m.IsStatic || flags %&& BindingFlags.Instance)
        && (!is_public || flags %&& BindingFlags.Public)
        && (is_public || flags %&& BindingFlags.NonPublic)
  }

  /** Note that [bindingAttr] is used only to check the case for DeclaredOnly
      members, so you have to provide filter function to check other flags */
  private get_members (bindingAttr : BindingFlags, filter : IMember -> bool) : list[IMember]
  {
    def maybe_add (m : IMember, acc)
    {
      if (filter(m)) m :: acc else acc
    }
    def add_few (_, mems, acc)
    {
      NList.FoldLeft (mems, acc, maybe_add)
    }

    if (bindingAttr %&& BindingFlags.DeclaredOnly)
      NList.RevMap(NList.RevFilter(member_list, filter), fun (x) { x })
    else if (member_map == null)
      []
    else
      member_map.Fold([], add_few)
  }

  internal BindType(t : PT.PExpr) : TypeVar
  {
    BindType(tenv, t)
  }

  public BindFixedType(t : PT.PExpr) : FixedType
  {
    BindFixedType(tenv, t)
  }


  [Nemerle.Assertions.Requires (t != null)]
  [Nemerle.Assertions.Ensures (value != null)]
  internal BindType(other_tenv : TypeVarEnv, t : PT.PExpr) : TypeVar
  {
    other_tenv.Bind(this.GlobalEnv, this, t, allow_tyvars = true, check_parms = true)
  }

  public BindFixedType(other_tenv : TypeVarEnv, t : PT.PExpr) : FixedType
  {
    other_tenv.BindFixedType(this.GlobalEnv, this, t, check_parms = true)
  }

  internal BindTyparms(tp : PT.Typarms) : TypeVarEnv * list[StaticTypeVar]
  {
    BindTyparms(tenv, tp)
  }

  internal BindTyparms(other_tenv : TypeVarEnv, tp : PT.Typarms) : TypeVarEnv * list[StaticTypeVar]
  {
    other_tenv.AddTyparms(this.GlobalEnv, tp, this, check_parms = true)
  }

  BindAndAddMember(class_member : PT.ClassMember) : void
  {
    try { ignore (bind_and_add_member (class_member)) }
    catch { | _ is Recovery => () }
  }

  internal AddMember(mem : IMember) : void
  {
    match (mem)
    {
      | mem is MemberBuilder =>
        mem.ProcessMacroAttributes();
        mem.CheckAttributes ();

      | _ => ()
    }

    mutable ignoreMember = false;

    // traverse existing members [mems] searching one which match signature
    // with the newly added method [meth] returns new list of members having this name
    def replace_method(acc, meth : MethodBuilder, mems : list[IMember])
    {
      def par_amount = meth.GetParameters().Length;

      match (mems)
      {
        | [] => // no methods with matching signature found
          when (meth.Attributes %&& NemerleModifiers.Override)
            Message.Error ($"`override' specified on $meth, but there is no method with this signature in parent to override");

          meth :: acc // we simply add this method to the existing list

        | x :: xs when (x :> IMethod).GetHeader().TypeParameters.Length != meth.GetHeader().TypeParameters.Length =>
          replace_method(x :: acc, meth, xs)

        | x :: xs => // process next member
          def m = x :> IMethod;
          def instantiatedSuperClass = LookupParentClassInstantiation(m.DeclaringType);
          def sub_current = get_method_type_after_subst(instantiatedSuperClass, m, meth);

          def sig_matches =
            (if (meth.Attributes %&& NemerleModifiers.Override)
              sub_current.Equals(meth.GetMemType())
            else
              (sub_current :> FixedType.Fun).from.Equals(meth.GetMemType().from))
            && m.GetParameters().Length == par_amount;


          def is_cast_op(m : IMethod)
          {
            par_amount == 1 && (m.Name == "op_Implicit" || m.Name == "op_Explicit")
            && (m is BuiltinMethod || (m.IsStatic && (m.Attributes %&& NemerleModifiers.Public)))
          }
          def return_type_overload = sig_matches && m.DeclaringType.Equals(this)
            &&  match ((sub_current, meth.GetMemType()))
                {
                  | (FixedType.Fun(t1, r1), FixedType.Fun(t2, r2))
                    when t1.Fix().Equals(t2.Fix()) && ! r1.Fix().Equals(r2.Fix()) =>
                      // allow return type overloading for implicit and explicit operators
                      unless (is_cast_op(m) && is_cast_op(meth))
                        Message.Error(meth.Location, $"attempted return type overload on $meth and $m");
                      true
                  | _ => false
                };

          // if signature of existing method is the new one
          if (sig_matches && !return_type_overload)
          {
            // check if new method does not hide or conflict with
            // existing methods in this and base type
            if (m.DeclaringType.Equals(this))
            {
              def methNew = meth.Attributes %&& NemerleModifiers.New;
              def someMethodIsGenerated = meth.Location.IsGenerated || m.Location.IsGenerated;
              def someMethodPreferred   = methNew != m.Attributes %&& NemerleModifiers.New;

              if (someMethodIsGenerated && someMethodPreferred)
              {
                if (methNew)
                  member_list = member_list.Filter(x => x.Equals(m));
                else
                  ignoreMember = true;

                xs.RevAppend((if (methNew) meth else m) :: acc)
              }
              else
              {
                Message.Error(meth.Location, $"redefinition of $meth");
                xs.RevAppend(meth :: acc)
              }
            }
            else
            {
              // we just override virtual method
              if (meth.Attributes %&& NemerleModifiers.Override)
              {
                meth.overridden_method = m;
                meth.HasBeenUsed = false;

                if (m.Attributes %&& NemerleModifiers.Virtual)
                  if (m.IsFinal)
                    Message.Error($"`override' specified on $meth, but $x is `sealed'")
                  else
                    m.HasBeenUsed = !is_obsolete && !meth.IsObsolete;
                else
                  Message.Error($"`override' specified on $meth, but there is no `virtual' modifier on $x");

                when ((x.Attributes %& NemerleModifiers.AccessModifiers) != (meth.Attributes %& NemerleModifiers.AccessModifiers))
                  Message.Error($"attempt to change the access modifiers of $meth during override of $x");

                when (meth.Header.TypeParameters.Exists(_.HasConstraints))
                  Message.Error("Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly.");
              }
              // don't allow to hide abstract methods in classes
              else if (m.Attributes %&& NemerleModifiers.Abstract && !IsInterface)
                Message.Error($"$meth hides abstract $x inherited from base class. To make the current member override that implementation, add the `override' keyword.");

              // new method has 'new' modifier, so it's ok to hide old one
              else if (meth.Attributes %&& NemerleModifiers.New)
                ()
              else
                Message.Warning(114, meth.Location, $"$meth hides $x inherited from base class. To make the current member override that implementation, add the `override' keyword. Otherwise add the `new' keyword.");

              // return list with the new method inside (and without [x], which is hidden now)
              xs.RevAppend(meth :: acc)
            }
          }
          else // signature do not match, just process remaining members
            replace_method(x :: acc, meth, xs)
      }
    }  // end of replace_method local function

    when (IsValueType && !mem.IsStatic)
      match (mem)
      {
        | fld is IField =>
          match (fld.GetMemType())
          { // enum structs have this special __value field, which is cyclic
            | FixedType.Class(tc is TypeBuilder, _) when tc.IsValueType => iterate_first = tc :: iterate_first;
            | _ => ()
          }
        | _ => ()
      }

    def new_mems =
      match (member_map.Get(mem.Name))
      {
        | Some([]) => Util.ice()
        | Some((x :: _) as old) =>
          if (x.DeclaringType.Equals(this))
            match (mem, x)
            {
              | (m is MethodBuilder, _ is IMethod) =>
                replace_method([], m, old)

              | (p1 is IProperty, p2 is IProperty) when p1.IsIndexer && p2.IsIndexer =>
                // overloading is (hopefully) checked at the get/set method level
                (mem : IMember) :: old

              | _ =>
                surroundwith(related_messages)
                {
                  Message.Error(mem.NameLocation, $"$mem redefined in `$(FullName)'");
                  Message.Hint(x.Location.FromStart(), $"first definition here as `$x'");
                }
                [mem : IMember]
            }
          else
            // take a look at current member [mem] and the one found in ancestors [x]
            match (mem, x)
            {
              | (m is MethodBuilder, _ is IMethod) => replace_method([], m, old)
              | (new_prop is PropertyBuilder, old is IProperty) when new_prop.Attributes %&& NemerleModifiers.Override =>
                new_prop.UpdateParentProperty(old);
                [mem : IMember]

              | _ when mem.Attributes %&& NemerleModifiers.New => [mem : IMember]
              | _ =>
                surroundwith(related_messages)
                {
                  Message.Warning(mem.NameLocation, $"$mem hides `$x' but neither `override' nor `new' is specified");
                  Message.Hint(x.Location.FromStart(), "hiden definition");
                }
                [mem : IMember]
            }

        | None =>
          when (mem.Attributes %&& NemerleModifiers.Override)
            Message.Error($"`override' specified on $mem, but there is no such member in parent to override");
          [mem : IMember]
      };

    member_map.Set(mem.Name, new_mems);

    unless (ignoreMember)
      member_list = mem :: member_list;
  }

  public CannotFinalize : bool
  {
    get { cannot_finalize }
    internal set { cannot_finalize = value; }
  }

  internal CreateSystemType() : void
  {
    when (!cannot_finalize && type_builder != null)
    {
      //  Message.Debug ($"finalize $this");
      try
      {
        // ok, seemed like this way MS.NET was a little bit more stable
        // _ = type_builder.CreateType ();
        // but this also seems to work:
        //system_type = type_builder.CreateType(); // VladD2: This is not work for some cases!
        _ = type_builder.CreateType ();
      }
      catch
      {
        | _ is System.TypeLoadException =>
          // there is a bug in MS.NET
          // http://lab.msdn.microsoft.com/productfeedback/viewfeedback.aspx?feedbackid=5984e7ff-4a8f-4096-bff9-b459fcd14e89
          // it throws this exc for nested value types, but actually assembly is
          // still being builded properly so we can ignore it
          ()
      }
      // // workarond ms.net bug
      // system_type = type_builder;
      type_builder = null;
    }
  }

  internal BeforeFinalizeType() : void
  {
    while (!before_finalization.IsEmpty)
    {
      def action = before_finalization.Pop();
      action()
    }

    while (!before_finalization2.IsEmpty)
    {
      def action = before_finalization2.Pop ();
      action()
    }
  }

  internal FinalizeType() : void
  {
    BeforeFinalizeType();
    CreateSystemType()
  }

  internal bind_and_add_member(class_member : PT.ClassMember) : MemberBuilder
  {
    when (class_member.Env == null)
      class_member._env = GlobalEnv;

    Util.locate (class_member.Location,
    {
      // if current class is static (it's a module) then sign its members to static
      when (IsModule)
        class_member.Attributes |= NemerleModifiers.Static;

      when (IsInterface)
      {
        when (class_member.Attributes %| NemerleModifiers.New != NemerleModifiers.New)
          Message.Error ("interface members are not allowed to have any attributes specified, except 'new'");

        class_member.Attributes = class_member.Attributes %| NemerleModifiers.Virtual
          %| NemerleModifiers.Abstract %| NemerleModifiers.Public;
      }

      match (class_member)
      {
        | PT.ClassMember.EnumOption
        | PT.ClassMember.TypeDeclaration => null
        | (PT.ClassMember.Field) as f =>
          def r = FieldBuilder (this, f);
          AddMember (r);
          r : MemberBuilder

        | (PT.ClassMember.Function) as f =>
          def r = Manager.ComponentsFactory.CreateMethodBuilder (this, f);
          unless (instance_ctor_occured)
            instance_ctor_occured = r.MemberKind == MemberKinds.Constructor
              && !(r.Attributes %&& NemerleModifiers.Static);
          AddMember(r);
          r

        | (PT.ClassMember.Property) as p =>
          def r = PropertyBuilder (this, p);
          when (r.IsIndexer && r.Name == "Item" && default_indexer == null)
          {
            default_indexer = "Item";
            modifiers.AddCustomAttribute (<[ System.Reflection.DefaultMemberAttribute ("Item") ]>);
          }

          AddMember (r);
          r

        | (PT.ClassMember.Event) as e =>
          def r = EventBuilder (this, e);
          AddMember (r);
          r
      }
    })
  }

  handle_underlying_enum_type() : void
  {
    match (parent_type)
    {
      | null => underlying_enum_type = InternalType.Int32;
      | t =>
        when (System.Array.IndexOf.[FixedType.Class] (InternalType.IntegralTypes, t) == -1)
        {
          Message.Error (t.ToString () + " is not valid as an underlying type of enum");
          Message.Hint ("Type byte, sbyte, short, ushort, int, uint, long, or ulong expected");
        }

        underlying_enum_type = t;
    }

    parent_type = InternalType.Enum;

    unless (t_implements.IsEmpty)
      Message.Error ("enum cannot implement anything");
  }


  /*
   * This methods calculates an enum's field values. We allow constants,
   * references to enum fields of this enum that already have been calculated,
   * arithmetic addition and basic bit-wise operations.
   */
  calculate_enum_value (expr : PT.PExpr, default_value : Literal.Integer,
                        resolved_values : Hashtable [string, Literal.Integer]) : Literal.Integer
  {
    def resolve_ref (_, is_post, e)
    {
      if (is_post)
        match (e)
        {
          | <[ $(n : name) ]> when resolved_values.Contains (n.Id) =>
            def val = resolved_values [n.Id];
            PT.PExpr.Literal (val)

          | <[ $(n : name) ]> when ConstantFolder.is_known_operator (n.Id) => e
          | _ => e
        }
      else e
    }

    def no_refs = Util.locate(expr.Location, { Macros.TraverseExpr(None(), expr, false, resolve_ref) });

    match (ConstantFolder.FoldConstants (this, no_refs))
    {
      | PT.PExpr.Literal (lit) =>
        match (lit.WithType (underlying_enum_type))
        {
          | Some (l) => l :> Literal.Integer
          | None =>
            Message.Error (expr.Location, $"supplied value $(lit) cannot be converted to $(underlying_enum_type) and isn't valid as enum field initializer");
            default_value
        }

      | _ =>
        Message.Error (expr.Location, "enum definition expression is too complex");
        Message.Hint  (expr.Location, "  enum definitions are allowed to be expressions taking constants, references to this enum's fields preceding this field, checked operations +, <<, >> and -, bit-wise operations |, %, ^ and ~ negation");
        default_value
    }
  }

  add_enum_members (decls : list[PT.ClassMember]) : void
  {
    def field_type = PT.PExpr.TypedType (GetMemType ());
    def resolved_values = Hashtable (32);

    def add_field (ef : PT.ClassMember, prev_value)
    {
      match (ef)
      {
        | PT.ClassMember.EnumOption(value) =>
          def current_value =
            match (value)
            {
              | Some(expr) => calculate_enum_value(expr, prev_value, resolved_values)
              | None =>
                def lit = ConstantFolder.FoldLiterals(true, "+", prev_value, Literal.Integer(1, false, underlying_enum_type));
                Literal.Integer(lit.val, lit.is_negative, underlying_enum_type)
            };

          assert(current_value.treat_as.Equals(underlying_enum_type));

          ef.Attributes |= (NemerleModifiers.Public | NemerleModifiers.Static);
          def field = <[ decl: ..$(ef.modifiers) $(ef.name) : $field_type; ]>;
          field.Location = ef.Location;
          def field = bind_and_add_member (field);
          (field :> FieldBuilder).ConstValue = current_value;
          // Message.Debug ($ "add: $(ef.ParsedName.Id) $current_value ");
          resolved_values.Add (ef.PName.Id, current_value);
          current_value

        | _ =>
          Message.Error (ef.Location, "only enum options are allowed in enum");
          Message.Hint (ef.Location, "this is the CLR limitation, please vote on http://lab.msdn.microsoft.com/productfeedback/viewfeedback.aspx?feedbackid=FDBK21375");
          prev_value
      }
    };

    assert (underlying_enum_type != null);
    def atrs = AttributesAndModifiers(NemerleModifiers.Public | NemerleModifiers.SpecialName, []);
    def f = bind_and_add_member (<[ decl: ..$atrs value__ : $(underlying_enum_type : typed); ]>) :> IField;
    Manager.MarkAsAssigned (f);
    _ = NList.FoldLeft (decls, Literal.Integer (1, true, underlying_enum_type), add_field);
  }


  /**
   * Collect type members (fields and methods, but not types, which
   * are already collected in [TypeBuilder.contained_types]) and store
   * them in [TypeInfo.member_map] and [TypeBuilder.member_list].
   *
   * <remarks>
   *   Members are first transferred from the [Parsetree] into the
   *   [Typedtree] namespace by binding appropriate types.
   * </remarks>
   */
  internal add_members() : void
  {
    assert (member_list == []);

    add_derived_members();

    // handle enum members separately
    match (_ast)
    {
      | PT.TopDeclaration.Enum(decls = ds) => add_enum_members(ds);
      | _ => ()
    }

    def decls = GetParsedMembers();

    foreach (m in decls)
      BindAndAddMember(m);

    when (additional_decls != null)
      foreach (m in additional_decls)
        BindAndAddMember(m);

      foreach (t in contained_types)
        AddMember(t);

    contained_types = contained_types.Rev();

    member_list = member_list.Rev();

    /// define implicit instance constructor if none exists
    unless (instance_ctor_occured)
    {
      // quasi-quotation use location from top of the LocationStack.
      // Probably it's location of the class. It will lead to that location will
      // overlap the locations of other methods.

      def loc = LocationStack.Top().FromStartAsGenerated();

      def ctor =
        // in abstract classes we have protected implicit ctor, otherwise public
        // http://www.jaggersoft.com/csharp_standard/17.10.4.htm
        if (IsAbstract)
          Util.locate(loc, <[ decl: protected this () { } ]>)
        else
          Util.locate(loc, <[ decl: public this () { } ]>);

      def meth = bind_and_add_member(ctor);

      meth.SetInstanceUsed();
    }

    // we no longer need it, let GC kill it
    additional_decls = null;
  }

  // in case of variant options, which have only parameterless constructor
  // and no fields (which could store some data and mane several instances
  // unique) we will create optimization - all instances of this option will be
  // replaced by one constant object stored in special static field of this opption's class
  internal add_constant_object_ctor() : void
  {
    def is_pure (tc : TypeInfo) {
      tc.Equals (InternalType.Object_tc)
        || (tc is TypeBuilder
          &&
            match (tc.LookupMember (".ctor"))
            {
              | [ctor is MethodBuilder] when ctor.GetParameters ().IsEmpty
                  && tc.GetFields (BindingFlags.Instance %| BindingFlags.Public %|  BindingFlags.NonPublic).IsEmpty =>
           //Message.Debug ($ "$tc: ctor.body = $(ctor.Body.GetType()) $(ctor.Body)");
           (ctor.Body is <[ { base () } ]>
            || ctor.Body is <[ {} ]>)
              && match (tc.SuperClass())
                 {
                   | Some (tc) => is_pure (tc)
                   | None => true
                 }

         | _ => false
       })
    }

    when (is_pure (this))
    {
      def ttf = GetMemType ();
      def ctor =
        match (LookupMember (".ctor"))
        {
          | [ctor is MethodBuilder] => ctor
          | _ => Util.ice ();
        };

      ctor.Attributes = NemerleModifiers.Private;

      Util.locate(loc,
      {
        def field = <[ decl: public static _N_constant_object : $(ttf : typed); ]>;
        constant_object = DefineAndReturn(field) :> IField;

        // reference to called constructor must be directly in typed version
        Define(<[ decl:
          static this()
          {
            $(TExpr.Assign(loc, InternalType.Void, TExpr.StaticRef(loc, ttf, ttf, constant_object, []),
                TExpr.Call(ttf, TExpr.StaticRef(loc, ctor.GetMemType(), ttf, ctor, []), [], false)) : typed);
          }
        ]>);

        // if this constant variant option is serializable we give the explicit deserialization behaviour
        // to keep the singleton semantics fo _N_constant_object always
        def iObjectReference = InternalType.IObjectReference;

        when (HasAttribute(InternalType.Serializable_tc) && !HasSuperType(iObjectReference.tycon))
        {
          AddSuperType(iObjectReference);

          def decl = <[ decl:
#if NET_4_0
            [System.Security.SecurityCritical]
#endif
            public GetRealObject(_ : System.Runtime.Serialization.StreamingContext) : object
              implements System.Runtime.Serialization.IObjectReference.GetRealObject
            {
              // When deserialiing this object, return a reference to
              // the Singleton object instead.
              $(TExpr.StaticRef(loc, ttf, ttf, constant_object, []) : typed);
            }
          ]>;
          decl.Attributes |= NemerleModifiers.SpecialName;
          Define(decl);
        }

        // add the constant object generator function
        def decl = <[ decl:
          public static _N_constant_object_generator () : $(ttf : typed)
          {
            $(TExpr.StaticRef (loc, ttf, ttf, constant_object, []) : typed)
          }
        ]>;

        decl.Attributes |= NemerleModifiers.SpecialName;

        Define(decl);
      });
    }
  }

  /**
   * Add special methods to variants and variant options. These methods
   * are used to accelerate matching over variants, allowing us to use
   * a single TExpr.Switch statement to identify a variant options instead of
   * a series of TExpr.If/HasType instructions.
   *
   */
  internal add_special_variant_methods() : void
  {
    match (tydecl)
    {
      | TypeDeclaration.Variant =>
        def gvc = <[ decl: public abstract _N_GetVariantCode () : int; ]>;
        gvc.Attributes |= NemerleModifiers.SpecialName;
        Define(gvc);

        def gvcs = <[ decl:
          public static _N_GetVariantCodeSafe (x : $ParsedTypeName) : int
          {
            | null => -1
            | _ => x._N_GetVariantCode()
          }
        ]>;
        gvcs.Attributes |= NemerleModifiers.SpecialName;
        Define(gvcs);

        def gvco = <[ decl:
          public static _N_GetVariantCodeObject (x : object) : int
          {
            | x is $ParsedTypeName => x._N_GetVariantCode()
            | _ => -1
          }
        ]>;
        gvco.Attributes |= NemerleModifiers.SpecialName;
        Define (gvco);

      | TypeDeclaration.VariantOption =>
        def gvc = <[ decl: public override _N_GetVariantCode () : int { $(VariantOptionCode : int) } ]>;
        gvc.Attributes |= NemerleModifiers.SpecialName;

        Define(gvc)

      | _ => ()
    }
  }

  /**
   * Add constant fields with single instance of parameter-less
   * variant options.
   */
  internal add_constant_variant_ctors() : void
  {
    match (tydecl)
    {
      | TypeDeclaration.VariantOption => add_constant_object_ctor()
      | _ => ()
    }
  }

  internal GetTyparms () : list[StaticTypeVar]
  {
    typarms
  }

  internal FixupDefinedClass () : void
  {
    // finalization is blocked until call to Compile
    this.cannot_finalize = true;

    Util.locate (loc, process_macro_attributes (MacroPhase.BeforeInheritance));

    def run_phase = TyManager.run_phase;

    when (run_phase >= 1)
      make_tyenvs ();
    when (run_phase >= 2)
      Util.locate (loc, bind_types ());
    when (run_phase >= 3)
      construct_subtyping_map ();
    when (run_phase >= 4)
      check_bound_types ();
    when (run_phase >= 5)
      process_macro_attributes (MacroPhase.BeforeTypedMembers);
    when (run_phase >= 6)
      add_members ();
    when (run_phase >= 7)
    {
      process_macro_attributes (MacroPhase.WithTypedMembers);
      when (TyManager.IsEmitting)
        TyManager.EnsureEmitProgress (this);
    }
  }

  /**
   * Propagates the SpecialName mark throughout the member hierarchy
   */
  internal mark_members_with_special_name () : void
  {
    foreach (member in member_list)
    {
      | member is MemberBuilder => member.MarkWithSpecialName ()
      | tb is TypeBuilder       => tb.MarkWithSpecialName ()
      | _                       => Util.ice ()
    }
  }

  /// Resolves overrides for the required interface methods
  internal resolve_method_implements() : void
  {
    check_abstract();
    def methods = GetMethods(BindingFlags.DeclaredOnly %| BindingFlags.Public %| BindingFlags.Instance %| BindingFlags.NonPublic);
    def methods = methods.Map(_ :> MethodBuilder);

    // FIXME: in fact we should only mark some methods as implemented and scream
    // when signature match is ambiguous

    // unresolved interface methods, which we must implement
    def ifaceMethods : NameToMethodsMap  = Hashtable(30);
    def can_explicitly_impl_methods : NameToMethodsMap = Hashtable();

    def partition_correct_meth(ifmethods : IfaceMethods, proposed_meth, scream)
    {
      def is_correct(ifaceType, ifaceMethod : IMethod) : bool
      {
        // Message.Debug($"try req: $proposed_meth req $ifaceMethod --- $(proposed_meth.GetMemType ()) req $(GetMemType ().TypeOfMethod (ifaceMethod))");
        if (methods_matches_by_signature(ifaceType, ifaceMethod, proposed_meth))
          if (proposed_meth.Attributes %&& NemerleModifiers.Public && !(proposed_meth.Attributes %&& NemerleModifiers.Static))
            true
          else
          {
            when (scream)
              Message.Warning (proposed_meth.Location, "method implementing interface member must be public and nonstatic");

            false
          }
        else false
      }

      ifmethods.Partition(is_correct)
    }

    def collect_methods(ifaceType : FixedType.Class, ifaceMethods : NameToMethodsMap) : void
    {
      def methods = ifaceType.tycon.GetMembers(BindingFlags.DeclaredOnly %| BindingFlags.Public %| BindingFlags.Instance);

      foreach (m is IMethod in methods)
        match (ifaceMethods.GetValueOrDefault(m.Name))
        {
          | [] | null => ifaceMethods.Add(m.Name, [(ifaceType, m)]);
          // здесь ошибка! Реализации интерфейсов с разными аргументами типов не должны попадать в один списко!
          // По всей видимости нужно заменить FixedType.Class * list[IMethod] на list[FixedType.Class * IMethod]
          // Хотя черт его знает. Нужно думать на свежую голову!
          // !!! По всей видимости вместо того чтобы таскать за собой тип (ifaceType) лучше сразу здесь сделать сабст и
          // поместить в хэш-таблицы
          | lst => ifaceMethods.Set(m.Name, (ifaceType, m) :: lst);
        }
    }

    foreach (ty in InterfacesToImplement())
       collect_methods(ty, ifaceMethods);

    foreach (mtype in t_implements)
       collect_methods(mtype, can_explicitly_impl_methods);

    def bind_explicit_implements(meth : MethodBuilder) : void
    {
      def bindOneExplicitMethodRef(impl : PT.PExpr) : IfaceMethod
      {
        match (impl)
        {
          | <[ $ns . $(member : dyn) ]> =>

            def (explicitIfaceTypeInfo, explicitIfaceType) =
              match (BindFixedType(ns))
              {
                | Class(tc, _) as ty => (tc, ty)
                | m_ty => Message.Error(impl.Location, $"cannot implement method from non-interface type '$m_ty'");
                          (null, null)
              };

            def is_correct(ifaceType : FixedType.Class, ifaceMethod : IMethod) : bool
            {
              def explicitIfaceTypeInfo = explicitIfaceTypeInfo;
              def explicitIfaceType     = explicitIfaceType;

              explicitIfaceTypeInfo != null
              && ifaceMethod.DeclaringType.Equals(explicitIfaceTypeInfo)
              && explicitIfaceType.TryUnify(ifaceType)
              && methods_matches_by_signature(explicitIfaceType, ifaceMethod, meth)
            }

            Manager.MarkAsUsed(meth, !IsObsolete);

            def partition_and_set(meths : IfaceMethods, methods_map : NameToMethodsMap) : IfaceMethod
            {
              def (correct, notcorrect) = meths.Partition(is_correct);

              match (correct)
              {
                | [] | null =>
                  def ty = explicitIfaceType;

                  def isImplementInterface(itf) : bool
                  {
                    t_implements.Exists(x => object.Equals(x, itf))
                  }
                  when (ty != null)
                  {
                    if (isImplementInterface(ty))
                      Message.Error(impl.Location, $"'$impl' in explicit interface declaration is not a member of interface ($ty)");
                      //Message.Error(impl.Location, $"interface `$ty' does not contain method named `$member' with proper signature");
                    else
                      Message.Error(impl.Location, $"the $meth try to implement interface `$ty' which don't implement by containing type ($this)");
                  }
                  (null, null)

                | [m] =>
                  methods_map.Set(member, notcorrect);
                  m

                | headMethod :: _ =>
                  Message.Error (impl.Location, $"interface `$explicitIfaceTypeInfo' contains more then one method named `$member' with proper signature");
                  //TODO: Добавить список эти методов в виде зависмого хинта
                  headMethod
              }
            }

            match (ifaceMethods.GetValueOrDefault(member))
            {
              | [] | null =>
                match (can_explicitly_impl_methods.GetValueOrDefault(member))
                {
                  | null =>
                    Message.Error(impl.Location, $"no interface implemented by `$FullName' contains method named `$member' (looking for `$impl')");
                    (null, null)

                  | meths => partition_and_set(meths, can_explicitly_impl_methods);
                }
              | meths => partition_and_set(meths, ifaceMethods)
            }

          | _ => Message.Error(impl.Location, "a qualified name expected in explicit implementation specifier");
                 (null, null)
        }
      }

      match (meth.Ast.implemented)
      {
        | (_ :: _) as impl =>
          def impl2 =
            try
            {
              def res = impl.RevMap(bindOneExplicitMethodRef);
              if (res.Contains((null, null)))
                res.Remove((null, null))
              else
                res
            }
            catch { _ is Recovery => [] };

           // make method virtual, because it implements something
           // we do it exactly here (not earlier in validity checks), because this
           // operation is invalid at source code level
           unless (meth.Attributes %&& NemerleModifiers.Virtual)
             meth.Attributes |= NemerleModifiers.Sealed %| NemerleModifiers.Virtual %| NemerleModifiers.New;

          foreach ((_, mem) in impl2)
            Manager.MarkAsUsed(mem, !is_obsolete && !meth.IsObsolete);

          meth.ImplementedMethods = impl2;

        | _ => meth.ImplementedMethods = [];
      }
    }

    foreach (m in methods)
      bind_explicit_implements(m);

    def already_bound = Hashtable();

    // now we can see which methods defined in current class directly match
    // to some of the yet unimlemented interfaces methods
    def bind_implicit_implements(meth : MethodBuilder) : void
    {
      def lookup_iface_members() : IfaceMethods
      {
        match (ifaceMethods.GetValueOrDefault(meth.Name))
        {
          | null => []
          | [] as ifmethods | ifmethods =>
            match (partition_correct_meth(ifmethods, meth, false))
            {
              | (correct, notcorrect) =>
                ifaceMethods.Set(meth.Name, notcorrect);
                def already =
                  if (already_bound.Contains(meth.Name))
                  {
                    def lst = already_bound[meth.Name];
                    def (additional, _) = partition_correct_meth(lst, meth, false);
                    unless (additional.IsEmpty)
                      Message.Error(meth.NameLocation, $"ambiguous implements-match for interface method(s): $additional, please use explicit implementation");
                    lst
                  }
                  else [];
                already_bound[meth.Name] = correct + already;
                unless (correct.IsEmpty)
                  Manager.MarkAsUsed(meth, false);

                correct
            }
        }
      }

      match (lookup_iface_members())
      {
        | [] => ()
        | impl2 =>
          def new_impls : IfaceMethods = impl2 + meth.ImplementedMethods;

          foreach ((_, impl) in new_impls)
            Manager.MarkAsUsed(impl, !is_obsolete && !meth.IsObsolete);

          meth.ImplementedMethods = new_impls;

          // Message.Debug ($"setting virtual for $meth $(meth.GetHeader().body) $(meth.Attributes)");

          unless (meth.Attributes %&& NemerleModifiers.Virtual)
            meth.Attributes |= NemerleModifiers.Sealed %| NemerleModifiers.Virtual %| NemerleModifiers.New;
          // Message.Debug ($"--> $(meth.Attributes)");
      }
    }

    foreach (m in methods)
      bind_implicit_implements(m);

    // create the additional overrides for unresolved interface methods
    // we check if methods derived from base class are actually proper
    // implementators of some unresolved interface methods
    mutable resolved_additionals = [];

    def create_additional_overrides(name : string, mutable meths : IfaceMethods) : void
    {
      unless (meths is [])
      {
        def possible_impls = LookupMember(name); // possible implementators from existing methods

        // choose only methods from within possible implementors
        foreach (meth is IMethod in possible_impls)
        {
          match (partition_correct_meth(meths, meth, false))
          {
            | ([], _) => ()
            | (correct, notcorrect) =>
              meths = notcorrect;

              // create a wrapper in the current type
              def meth_header = meth.GetHeader();
              def obj = if (meth.IsAbstract) <[ null : this ]> else <[ base ]>;
              //Message.Debug ("additional " + meth_header.name);

              def mods =
                if ((meth.Attributes %&& NemerleModifiers.Virtual) && !(meth.Attributes %&& NemerleModifiers.Sealed))
                  NemerleModifiers.Override
                else
                  NemerleModifiers.New;
              def subst = GetMemType().ConstructSubstForTypeInfo(meth.DeclaringType); // VladD2: возможно это ошибка!
              def parse_tr = meth_header.CreateAliasMethod(mods | NemerleModifiers.Public, obj, subst);
              def wrapper = DefineAndReturn(parse_tr) :> MethodBuilder;

              wrapper.MarkWithSpecialName ();
              wrapper.HasBeenUsed = false; // do not trigger obsoletion warning
              // note in method definition what we are implementing
              // (this cannot be automatic because we are currently resolving implements
              wrapper.ImplementedMethods = correct;
          }
        }

        resolved_additionals ::= (name, meths);
      }
    }

    foreach ((name, ifaceMeths) in ifaceMethods.KeyValuePairs)
      create_additional_overrides(name, ifaceMeths);

    foreach ((name, meths) in resolved_additionals)
      ifaceMethods.Set(name, meths);

    // emit error messages for any unbound interface method
    def scream_about_unimplemented(meths : IfaceMethods)
    {
      def methods = methods;
      foreach ((ifaceType, ifaceMethod) as meth in meths)
      {
        // the word ``method'' comes from meth.ToString
        Message.Error(this.NameLocation, $"'$this' does not implement interface member '$ifaceType.$(ifaceMethod.Name) : $(ifaceType.TypeOfMethod(ifaceMethod))'");
        //Message.Error (this.NameLocation, $"unimplemented interface '$ifaceMethod' of '$ifaceType' interface (in $(this.FullName) type)");
        UnimplementedMembers ::= (ifaceType, ifaceMethod);

        def ifaceMethodName = ifaceMethod.Name;
        // following code can let wrong messge, but it can get hint to solv problem
        def precedents = methods.Filter(m => m.Name == ifaceMethodName);
        def ifmethods = [meth];
        foreach (precedent in precedents)
          // "scream = true" force error report (about private or static methods).
          _ = partition_correct_meth(ifmethods, precedent, scream = true);
      }
    }

    foreach (ifaceMeths in ifaceMethods.Values)
      scream_about_unimplemented(ifaceMeths);

    //foreach (meth is MethodBuilder when meth.overridden_method != null in GetMembers())
    //{
    //  meth.ImplementedMethods = meth.overridden_method :: meth.ImplementedMethods;
    //  meth.overridden_method = null;
    //}
  }

  /// determine equality of methods signatures taking into account types substitutions.
  /// For axample you can compare method of implemented interface and it implementation
  /// on current type.
  methods_matches_by_signature(ifaceType : FixedType.Class, ifaceMethod : IMethod, meth : IMethod) : bool
  {
    if (ifaceMethod.GetHeader().TypeParameters.Length == meth.GetHeader().TypeParameters.Length)
    {
      def iftype = get_method_type_after_subst(ifaceType, ifaceMethod, meth);
      def methd_type =
        if (meth.DeclaringType.Equals(this))
          meth.GetMemType()
      else
        GetMemType().TypeOfMember(meth).Fix();
      methd_type.TrySigRequire(iftype)
    }
    else
      false
  }

  get_method_type_after_subst(ifaceType : FixedType.Class, ifaceMethod : IMethod, meth : IMethod) : FixedType
  {
    def h1 = ifaceMethod.GetHeader();
    def h2 = meth.GetHeader();
    def sub = ifaceType.tycon.MakeSubst(ifaceType.args);

    unless (h1.TypeParameters.IsEmpty)
      NList.Iter2(h1.TypeParameters, h2.TypeParameters, (sourceStaticTypeVar, staticTypeVarForSubst) =>
          sub.Add(sourceStaticTypeVar, FixedType.StaticTypeVarRef(staticTypeVarForSubst)));

    def sub = sub;
    def res = sub.MonoApply(ifaceMethod.GetMemType());
    _ = this;
    res
  }

  /// Return interfaces [this] needs to implement (that is it says it will
  /// implement them, but they are not implemented in base class).
  InterfacesToImplement() : Seq[FixedType.Class]
  {
    //def print[T](seq : Seq[T], name : string)
    //{
    //  def lst = seq.NToList();
    //  Debug.WriteLine($"$name = ..$lst");
    //}

    def interfacesOnly = _.IsInterface;

    def implementedByThis = GetSuperTypes().FilterLazy(interfacesOnly)
                                           .MapLazy(ty => ty.DeepFix() :> FixedType.Class).NToArray();
    //print(implementedByThis, "implementedByThis");

    def implementedByParent =
      match (parent_type)
      {
        | null | _ when parent_type.Equals(InternalType.Object) => array(0)
        | _ =>
          def subst = parent_type.tycon.MakeSubst(parent_type.args);
          parent_type.tycon.GetSuperTypes()
                     .FilterLazy(interfacesOnly)
                     .MapLazy(ty => subst.MonoApply(ty).DeepFix() :> FixedType.Class).NToArray();
      };
    //print(implementedByParent, "implementedByParent");

    def unimplementedInterfaces = implementedByThis.ExcludeLazy(implementedByParent).NToArray();
    //print(unimplementedInterfaces, "unimplementedInterfaces");

    unimplementedInterfaces
  }

  //  InterfacesToImplement() : Seq[FixedType.Class]
  //{
  //  def print[T](seq : Seq[T], name : string)
  //  {
  //    def lst = seq.NToList();
  //    Debug.WriteLine($"$name = ..$lst");
  //  }
  //  def interfacesOnly = _.IsInterface;
  //  def implementedInterfaces   = GetSuperTypes().FilterLazy(interfacesOnly);
  //  print(implementedInterfaces, "implementedInterfaces");
  //  def interfacesToImplement   = GetDirectSuperTypes().FilterLazy(interfacesOnly);
  //  print(interfacesToImplement, "interfacesToImplement");
  //  def unimplementedInterfaces = interfacesToImplement.ExcludeLazy(implementedInterfaces);
  //  print(unimplementedInterfaces, "unimplementedInterfaces");
  //  unimplementedInterfaces
  //}

  public BaseClass : FixedType.Class
  {
    get { if (parent_type != null) parent_type else InternalType.Object }
  }

  internal process_attributes (self_parm : list[Parsetree.SyntaxElement], target : MacroTargets,
                               stage : MacroPhase, mods : AttributesAndModifiers, meth : MethodBuilder) : void
  {
    mutable macro_attrs = mods.macro_attrs;
    // we have to do the assignment here, in case macro has added a new
    // custom attribute
    def suff = TypesManager.AttributeMacroExpansion.Suffix (target, stage);
    mods.custom_attrs =
      mods.custom_attrs.Filter(
        fun (expr)
        {
          match (MacroRegistry.lookup_macro(this.GlobalEnv, expr, suff))
          {
            | None => true
            | Some =>
              macro_attrs ::= (suff, expr);
              false
          }
        });

    mods.macro_attrs = macro_attrs;

    foreach ((_, expr) in macro_attrs)
    {
      def expansion = TypesManager.AttributeMacroExpansion (target, stage, expr, self_parm, this, meth);
      TyManager.AddMacroExpansion (expansion);
    };
  }

  add_macros_from_parsedmems(mem : PT.ClassMember, stage : MacroPhase) : void
  {
    def syntax_tb = PT.SyntaxElement.TypeBuilder (this);
    def syntax_mem = PT.SyntaxElement.ClassMember (mem);
    def parms = [syntax_tb, syntax_mem];

    match (mem)
    {
      | PT.ClassMember.Field =>
        process_attributes (parms, MacroTargets.Field, stage, mem.modifiers, null)

      | (PT.ClassMember.Function) as f =>
        process_attributes (parms, MacroTargets.Method, stage, mem.modifiers, null);

        foreach (p : PT.PParameter in f.header.Parameters)
          process_attributes ([syntax_tb, syntax_mem, PT.SyntaxElement.Parameter (p)],
                              MacroTargets.Parameter, stage, p.modifiers, null);

      | PT.ClassMember.EnumOption
      | PT.ClassMember.TypeDeclaration => ()

      | PT.ClassMember.Property(getter = getr, setter = setr) =>
        process_attributes(parms, MacroTargets.Property, stage, mem.modifiers, null);

        when (getr is Some(m))
          add_macros_from_parsedmems(m, stage);

        when (setr is Some(m))
          add_macros_from_parsedmems(m, stage);

      | PT.ClassMember.Event =>
        process_attributes (parms, MacroTargets.Event, stage, mem.modifiers, null)
    }
  }

  internal process_macro_attributes (stage : MacroPhase) : void
  {
    process_attributes ([PT.SyntaxElement.TypeBuilder (this)], MacroTargets.Class, stage, modifiers, null);

    match (stage) {
      | MacroPhase.BeforeInheritance | MacroPhase.BeforeTypedMembers =>
        foreach (x in GetParsedMembers())
          add_macros_from_parsedmems (x, stage);

      | MacroPhase.WithTypedMembers => ()
      | _ => Util.ice ("cannot run macros processing with none phase")
    }

    TyManager.ExpandMacros();
  }



  /* ---------------------------------------------------------------------- */
  /* -- VALIDITY CHECKS --------------------------------------------------- */
  /* ---------------------------------------------------------------------- */

  internal static check_bound_type (t : TypeVar) : void
  {
    def check_type (t)
    {
      | FixedType.Out (t)
      | FixedType.Ref (t)
      | FixedType.Array (t, _)      => check_tv (t)
      | FixedType.Fun (ts, t)       => check_tv (ts); check_tv (t)
      | FixedType.Void              => ()
      | FixedType.Tuple (ts)        => NList.Iter (ts, check_tv)
      | FixedType.StaticTypeVarRef  => {}
      | FixedType.Class (ti, args)  =>
        NList.Iter (args, check_tv);
        _ = ti.MakeSubst (args);

      | FixedType.Intersection (lst) => NList.Iter (lst, check_type)
    }
    and check_tv (t : TypeVar) { check_type (t.Fix ()) }

    check_tv (t)
  }

  /**
      Check if types that are already bound are correctly applied.
      Check accessibility.
   */
  internal check_bound_types () : void
  {
    // check accessibility of type we are aliasing
    match (tydecl)
    {
      | TypeDeclaration.Alias (t) =>
        t.CheckAccessibility (this, accessibility);
        check_bound_type (t);

      | _ => ()
    }

    // types we are deriving from should be at least as accessible as we
    foreach (deriv_t : FixedType.Class in GetDirectSuperTypes ())
    {
      def is_iface = deriv_t.tycon.IsInterface;

      // access check with exception of interfaces derived / implemented by class
      // which case is not mentioned by http://www.jaggersoft.com/csharp_standard/10.5.4.htm
      when (this.IsInterface || !is_iface)
        deriv_t.CheckAccessibility (this, accessibility);

      check_bound_type (deriv_t);
    }

    foreach (tv in typarms)
      foreach (t in tv.Constraints)
      {
        t.CheckAccessibility (this, accessibility);
        check_bound_type (t);
      }
  }

  internal check_ctor_constraints() : void
  {
    def check_ctors(ty : TypeInfo)
    {
      def check_ctor(member : IMember, acc)
      {
        if (member.DeclaringType.Equals (ty) && member.MemberKind == MemberKinds.Constructor)
        {
          def is_default = (member :> IMethod).GetParameters ().IsEmpty;
          (acc [0] || is_default, true)
        }
        else acc
      }

      NList.FoldLeft(ty.GetMembers(), (false, false), check_ctor)
    }

    when (parent_type != null)
    {
      def (_, has_ctor) = check_ctors (this);
      def (par_has_default, par_has_ctor) = check_ctors (parent_type.tycon);
      when (!has_ctor && !par_has_default && par_has_ctor)
        Message.Error ("the type `" + FullName + "' has no constructors and the parent type `" + parent_type.tycon.FullName + "' has no default constructor")
    }
  }


  /*
   * This method emits the warnings about unused global symbols.
   */
  internal check_for_unused_global_symbols () : void
  {
    unless (IsDelegate)
    {
      def is_variant = !variant_options.IsEmpty;

      // first, check if this type has ever been referenced
      when (!(HasBeenUsed || is_variant || IsAlias))
        Message.Warning (10003, loc,
                         $"`$this' is not externally visible and has never been referenced");

      // then, proceed with the members of this type
      foreach (member in member_list)
      {
        | f is FieldBuilder =>
          when (!f.HasBeenAssigned)
            if (f.HasBeenUsed)
              when (!f.IsLiteral && (f.IsPrivate || IsSealed || IsInternal))
                Message.Warning (649, member.Location, $"field `$(f.Name)' is never assigned to, and will always have its default value")
            else
              Message.Warning (10003, member.Location, $"$member is not externally visible and has never been referenced")

        | _ is TypeBuilder => ()
        | _ =>
          when (!member.HasBeenUsed)
            Message.Warning (10003, member.Location, $"$member is not externally visible and has never been referenced")
      }
    }
  }

  /**
   * Checks for abstract method in non-abstract class errors.
   */
  check_abstract () : void
  {
    // Message.Debug ($"mems $(type_members.ToString(\"\\n\"))");
    // check for the abstract method/non-abstract class errors
    unless (Attributes %&& NemerleModifiers.Abstract)
      foreach (m is IMethod in GetMembers ())
        when (m.Attributes %&& NemerleModifiers.Abstract)
        {
          attributes |= NemerleModifiers.Abstract;

          if (m.DeclaringType.Equals (this))
            Message.Error(m.NameLocation, $"$m is abstract, but its declaring class `$(FullName)' is not");
          else
            Message.Error(this.NameLocation, $"$m must be overriden, because it is abstract and the current class `$(FullName)' is not");
        }
  }

  /**
   * Performs access attributes related checks. Returns an optional
   * description of the problem.
   */
  internal static CheckAccessAttributes (attrs : NemerleModifiers) : option [string]
  {
    def access_attrs_count =
      (if (attrs %&& NemerleModifiers.Public)    1 else 0) +
      (if (attrs %&& NemerleModifiers.Internal)  1 else 0) +
      (if (attrs %&& NemerleModifiers.Protected) 1 else 0) +
      (if (attrs %&& NemerleModifiers.Private)   1 else 0);

    def is_protected_internal =
      attrs %&& NemerleModifiers.Internal &&
      attrs %&& NemerleModifiers.Protected &&
      access_attrs_count == 2;

    if (access_attrs_count <= 1 || is_protected_internal)
      None ()
    else
      Some ("inconsistent access attributes specified")
  }

  /**
   * Performs attributes checks for type definitions.
   */
  internal CheckTypeAttributes () : void
  {
    def title ()
    {
      if (IsInterface) "interface" else if (IsStruct) "struct" else "type";
    }

    // make sure only a valid subset of NemerleModifiers has been used
    def check_for_invalid_attr (attr : NemerleModifiers, attr_name : string)
    {
      when (attributes %&& attr)
        Message.FatalError (loc, "invalid attribute `" + attr_name + "' specified for " + title () + ": " + FullName)
    }

    check_for_invalid_attr (NemerleModifiers.Virtual, "virtual");
    check_for_invalid_attr (NemerleModifiers.Override, "override");
    check_for_invalid_attr (NemerleModifiers.Mutable, "mutable");
    check_for_invalid_attr (NemerleModifiers.Volatile, "volatile");

    // some extra checks for structs and interfaces
    when (this.IsInterface || this.IsStruct)
    {
      check_for_invalid_attr (NemerleModifiers.Abstract, "abstract");
      check_for_invalid_attr (NemerleModifiers.Sealed, "sealed");
      check_for_invalid_attr (NemerleModifiers.Macro, "macro")
    }

    // some extra checks for interfaces
    when (this.IsInterface)
    {
      check_for_invalid_attr (NemerleModifiers.Struct, "struct")
    }

    // check the access attributes for consistency
    match (CheckAccessAttributes (attributes))
    {
      | Some (msg) =>
        Message.FatalError (loc, msg + " for type: " + FullName)
      | _ => ()
    }

    def type_is_top_level = _declaringType == null;

    // top-level classes can only be public or internal
    when (type_is_top_level && accessibility != Accessibility.Public && accessibility != Accessibility.Internal)
      Message.FatalError (loc, "top level " + title () + "s are only allowed to be public or internal: " + FullName);

    // top-level classes are not allowed to be `new'
    def type_is_new = attributes %&& NemerleModifiers.New;

    when (type_is_top_level && type_is_new)
      Message.FatalError(loc, "only nested " + title() +"s are allowed to `new': " + FullName);

    // types cannot be abstract and sealed at the same time
    when (IsAbstract && IsSealed)
      Message.FatalError(loc, title() + "s are not allowed to be abstract and sealed at the same time: " + FullName)
  }

  /// Get direct (derived directly) subtypes of given type.
  public GetDirectSubTypes() : list[TypeBuilder]
  {
    def nameTree          = this.GlobalEnv.NameTree;
    def nsRoot            = nameTree.NamespaceTree;
    def typeBuilders      = nsRoot.GetTypeBuilders();

    $[ t | t in typeBuilders, object.Equals(t.BaseType, this) ]
  }

  /// Get all subtypes of given type.
  public GetAllSubTypes() : list[TypeBuilder]
  {
    def nameTree          = this.GlobalEnv.NameTree;
    def nsRoot            = nameTree.NamespaceTree;
    def typeBuilders      = nsRoot.GetTypeBuilders();

    def subTypes = Hashtable();

    def getDirectSubTypes(ty)
    {
      def subTypes1 = SCG.List();
      foreach (t when t.BaseType : object == ty in typeBuilders)
        unless (subTypes.ContainsKey (t))
        {
          subTypes[t] = 0 : byte;
          subTypes1.Add(t);
        }

      foreach (subType in subTypes1)
        getDirectSubTypes(subType)
    }

    def isImplementInterface(t)
    {
      //System.Diagnostics.Trace.Assert(t.Name != "MemberBuilder");
      t.t_implements.Exists(x => object.Equals(x.tycon, this))
    }

    when (IsInterface)
      foreach (t when t.t_implements != null && isImplementInterface (t) in typeBuilders)
        unless (subTypes.ContainsKey (t))
        {
          subTypes[t] = 0 : byte;
          getDirectSubTypes(t);
        }

    getDirectSubTypes(this);

    subTypes.Keys.NToList()
  }

  private AddToAdditionalDecls(mem : PT.ClassMember) : void
  {
    when (additional_decls == null)
      additional_decls = SCG.List();

    additional_decls.Add(mem);
  }

  public override CanAccess(source : TypeInfo) : bool
  {
    IsPublic
      || (IsInternal && source is TypeBuilder)
      || (IsProtected
        && (if (_declaringType != null)
             // during bind_types all supertypes are null
             !_superTypesCalculated || source.IsDerivedFrom(_declaringType)
            else
              false
           ))
      || (if (_declaringType != null)
          {
            mutable result = false;
            for (mutable tc = source; tc != null && !result; tc = tc.DeclaringType)
              result = tc.Equals(_declaringType);
            result
          }
          else
            false
    )
  }

  mutable _conditions : list[string] = [];

  public override IsConditional : bool { get { !_conditions.IsEmpty } }

  public override GetConditions() : list[string] { _conditions }
}
} // ns
