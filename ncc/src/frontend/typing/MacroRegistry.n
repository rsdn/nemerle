using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  [ManagerAccess]
  public class MacroRegistry
  {
    extensions : Hashtable [NamespaceTree.Node, list [SyntaxDefinition]];
    internal implicit_ctx_name : Name;
    
    public GetImplicitCTXName () : Name { implicit_ctx_name }

    internal this (man : ManagerClass) {
      extensions = Hashtable (50);
      Manager = man;
      implicit_ctx_name = Macros.NewSymbol ();
    }

    internal GetSyntaxExtensions (name_space : NamespaceTree.Node) : list [SyntaxDefinition]
    {
      extensions.Get (name_space).WithDefault ([])
    }

    public AddOperatorDefinition (info : OperatorDefinition) : void
    {
      def nsnode = info.MacroNamespace;
      match (extensions.Get (nsnode))
      {
        | Some (l) => extensions.Set(nsnode, info :: l)
        | None     => extensions.Set(nsnode, [info])
      }
    }
    
    public RegisterMacro (m : IMacro) : void
    {
      def ns = m.GetNamespace();
      def nsnode =
        if (ns == "")
          Manager.NameTree.ExactPath(["Nemerle", "Core"]);
        else
          Manager.NameTree.ExactPath(NString.Split(ns, '.'));

      def child = [m.GetName()];
      
      match (nsnode.LookupMacro(child))
      {
        | Some => Message.Error("macro `" + ns + m.GetName () + "' already defined")
        | None =>
          def macro_ns = nsnode.Path(child);
          
          // store syntax extension in MacroRegistry
          match (m.SyntaxExtension())
          {
            | (null, _) => ()
            | (tree, permute) =>
              def key        = tree.ToString(); // this is the first token of extension
              def syntax_def = SyntaxDefinition(key, m.Keywords, macro_ns, tree.Next, permute);

              // store extensions for this namespace
              match (extensions.Get (nsnode))
              {
                | Some(l) => extensions.Set(nsnode, syntax_def :: l)
                | None    => extensions.Set(nsnode, [syntax_def])
              }
          };
          NamespaceTree.AddMacro (macro_ns, m);
      }
    }

    internal static expand_one_macro(ctx : Typer, expr : PExpr) : PExpr * option [IMacro * PExpr] {
      try
      {
        match (expr)
        {
          | PExpr.Call(name, args) =>
            match (Util.QidOfExpr(name))
            {
              | Some ((namepath, name)) =>
                unless (expr.IsGeneratedOrEmpty)
                  _ = ctx.SequenceElems.Add(expr);
                match (name.GetEnv(ctx.Env).LookupMacro (namepath))
                {
                  | Some (x) =>
                    def expanded =
                      try
                      {
                        ctx.Manager.MacroColors.PushNewColor(name.color, name.GetEnv(ctx.Env));
                        foreach (arg  when !arg.IsGeneratedOrEmpty in args)
                          _ = ctx.SequenceElems.Add(arg); // Не ясно нужно ли это???
                        Util.locate(expr.Location, x.Run(ctx, x.CallTransform(args)));
                      }
                      finally ctx.Manager.MacroColors.PopColor();
                    (expanded, Some((x, expr)))
                  | None => (expr, None())
                }
              | None => (expr, None())
            }

          | PExpr.MacroCall(name, namespc, parms) =>
            match (namespc.Value)
            {
              | NamespaceTree.TypeInfoCache.MacroCall(m) =>
                def expanded = 
                  try
                  {
                    ctx.Manager.MacroColors.PushNewColor(name.color, name.GetEnv(ctx.Env));
                    foreach (SyntaxElement.Expression(body) when body != null && !body.IsGeneratedOrEmpty in parms)
                      _ = ctx.SequenceElems.Add(body);
                    Util.locate(expr.Location, m.Run(ctx, parms));
                  }
                  finally { ctx.Manager.MacroColors.PopColor(); };

                (expanded, Some((m, expr)))

              | _ => Util.ice ("failed to resolve macro name `" + namespc.GetDisplayName () + "'")
            }

          | _ => (expr, None())
        }
      }
      catch
      {
        | _ is Typer.SwitchToYielding            => throw;
        | _ is RestartInErrorMode                => throw;
        | _ is Nemerle.Compiler.CompletionResult => throw;
        | _ is Nemerle.Compiler.Recovery         => throw;
        | e => 
          def name = match (expr) 
          {
            | PExpr.Call(name, _) 
            | PExpr.MacroCall(name, _, _) => $"$name"
            | _ => "<<unknown>>"
          }
          Message.Error(expr.Location, $"$(e.GetType().Name) has occurred when expanding macro '$name'");
          (expr, None())
      }
    }
    
    internal static expand_macro (ctx : Typer, expr : PExpr) : PExpr * list [IMacro * PExpr]
    {
      match (expand_one_macro(ctx, expr))
      {
        | (e, Some(h)) =>
          def (e, lst) = expand_macro(ctx, e);
          (e, h :: lst)
        | (e, None) => (e, [])
      }
    }

    internal static lookup_macro(env : GlobalEnv, expr : PExpr, suff : string) : option[Name * IMacro * list[SyntaxElement]]
    {
      match (expr)
      {
        | <[ $(_ : name) ]>
        | <[ $_ . $_ ]> => lookup_macro (env, <[ $expr () ]>, suff)
          
        | <[ $name ( .. $parms ) ]> =>
            match (Util.QidOfExpr(name))
            {
              | Some ((id, name)) =>
                def ctx = name.GetEnv (env);
                def id =
                  match (NList.Rev (id))
                  {
                    | x :: xs => NList.Rev(x + suff :: xs)
                    | [] => assert(false)
                  };
                match (ctx.LookupMacro(id))
                {
                  | Some(m) => Some((name, m, m.CallTransform(parms)))
                  | None => None()
                };
              | None => None()
            }

        | PExpr.MacroCall (name, ns, parms) =>
          match (ns.Value)
          {
            | NamespaceTree.TypeInfoCache.MacroCall(m) =>
              if (m.GetName ().EndsWith(suff))
                Some((name, m, parms))
              else
                None ()
              
            | _ => Util.ice ("failed to resolve macro name `" + ns.GetDisplayName () + "'")
          }
            
        | _ => None()
      }
    }
  }
} // end ns
