using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler
{
  public partial class MethodBuilder
  {
    internal CreateImplementsWrapper() : void
    {
      //Message.Debug($"check for impl wrap $this");
      // now we will create special wrappers implementing interface methods
      // when our methods are co/contra-variant (and .NET doesn't allow it automatically)
      def is_correct_impl(ifaceType : FixedType.Class, impl_meth : IMethod)
      {
        //Message.Debug($"compare: $(declaring_type.GetMemType().TypeOfMember(impl_meth))     ======     $(this.GetFreshType())");
        def sameTyParLen = impl_meth.GetHeader().TypeParameters.Length == Header.TypeParameters.Length;

        if (sameTyParLen && ifaceType.TypeOfMember(impl_meth).TryUnify(this.GetFreshType()[0]))
            true
        else
        {
          //Message.Debug("fail");
          Util.locate(Location, MakeImplWrapper(ifaceType, impl_meth));
          false
        }
      }
      // we filter out interface methods, which we have implemented by means of
      // wrappers, the rest are ok to implement them directly
      this.ImplementedMethods = ImplementedMethods.Filter(is_correct_impl);
      // Message.Debug($"impl: $impl_list --> $thesame");
    }

    MakeImplWrapper(ifaceType : FixedType.Class, impl_meth : IMethod) : void
    {
      assert(declaring_type.IsDerivedFrom(ifaceType));
      // Message.Debug($"make impl wrap $this IMPL $impl_meth");
      def hd = impl_meth.GetHeader();
      def parms = hd.Parameters;
      mutable new_typarms = [];

      Util.cassert(Name.IndexOf('.') == -1, $"impl loop, $this IMPL $impl_meth, $(this.GetMemType()) != $(declaring_type.GetMemType().TypeOfMember(impl_meth))");

      def subst = impl_meth.DeclaringType.MakeSubst(ifaceType.args);
      //def subst = declaring_type.SubtypingSubst(impl_meth.DeclaringType);
      def orig_typarms = hd.TypeParameters;
      //this.GetHeader().typarms;
      unless (orig_typarms.IsEmpty)
      {
        def (s2, newtp) = StaticTypeVar.CopyList(orig_typarms);
        //Message.Debug($"newtp: $orig_typarms -> $newtp");
        new_typarms = newtp;
        //Message.Debug($"subst before: $subst");
        subst.AddSubst(s2);
        NList.Iter2(Header.TypeParameters, newtp, (tv, repl) => subst.Add(tv, FixedType.StaticTypeVarRef(repl)));
        //Message.Debug($"subst after: $subst");
      }

      def parm_types_names = parms.Map(parm => (subst.Apply(parm.ty.Fix()), Macros.NewSymbol("sp_parm")));
      def formal_parms     = parm_types_names.Map((ty, name) => <[ parameter: $(name : name) : $(ty : typed) ]>);
      def name             = impl_meth.DeclaringType.FullName + "." + impl_meth.Name;

      declaring_type.forced_typarms = new_typarms;
      def meth =
        declaring_type.bind_and_add_member(<[ decl:
          private $(name : dyn)(.. $formal_parms) : $(subst.Apply(hd.ReturnType.Fix()) : typed)
          {
          }
        ]>) :> MethodBuilder;
      //Message.Debug($"added $meth");
      meth.ImplementedMethods = [(ifaceType, impl_meth)];
      meth.Attributes |= NemerleModifiers.SpecialName | NemerleModifiers.Sealed;

      unless (impl_meth.DeclaringType.IsInterface)
        meth.Attributes = NemerleModifiers.Public | NemerleModifiers.Override;

      Manager.MarkAsUsed(meth);

      def current_fun = meth.GetHeader();
      def refs = current_fun.Parameters.Map(
        fun (parm : TParameter)
        {
          def val =
            LocalValue(current_fun, parm.name, parm.ty,
                        LocalValue.Kind.FunParm(ParamKind.Normal),
                        is_mutable = false);
          val.Register();
          val.UseFrom(current_fun);
          parm.decl = val;
          TExpr.LocalRef(val.Type, val)
        });

      def casted_refs = refs.Map(Param);
      // def ty = subst.Apply(impl_meth.GetMemType());
      // def vars = new_typarms.Map(fun(x) { FixedType.StaticTypeVarRef(x) });
      def (the_method_type, vars) = ifaceType.TypeOfMethodWithTyparms(this); //!!!!
      NList.Iter2(new_typarms, vars, (x, tv) => tv.ForceUnify(FixedType.StaticTypeVarRef(x)));
      def (_, ret_type) = the_method_type.Fix().FunReturnTypeAndParms(this);
      //Message.Debug($"ty=$ty");

      def methref = TExpr.MethodRef(the_method_type, TExpr.This(declaring_type.GetMemType()),
                                    this, vars, !impl_meth.DeclaringType.IsInterface);

      // call the wrapped method,
      def body = TExpr.Call(ret_type, methref, casted_refs, false);
      //Message.Debug($"ty=$((this.ReturnType.Fix()))  $(subst.Apply(this.ReturnType.Fix()))");

      def header = meth.GetHeader();
      header.body = FunBody.Typed(body);
      header.TypeParameters = new_typarms;

      def t4 = Typer4(meth);
      t4.Run();

      DeclaringType.TyManager.MaybeCompile(declaring_type, meth);
    }
  }
}
