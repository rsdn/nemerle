using Nemerle.Assertions;
using Nemerle.Compiler.Backend;
using Nemerle.Compiler.Util;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Surround;
using Nemerle.Utility;

using System;
using System.IO;

using Nemerle.Compiler.Typedtree;
using Nemerle.Logging;

using dnlib.DotNet.Emit;
using dnlib.DotNet.Pdb;

using DN    = dnlib.DotNet;
using SCG   = System.Collections.Generic;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace Nemerle.Compiler
{
  [assembly: LogFlag (EMIT, 0)]
  [assembly: DefineSurround("inScope", false, _ilg.BeginScope(), _ilg.EndScope())]


  /* ----------------------------------------------------------------------- */
  /* -- CODE GENERATOR CLASS ----------------------------------------------- */
  /* ----------------------------------------------------------------------- */

  /**
   * Generates the IL code for a method or a constructor
   */
  [ManagerAccess]
  class ILEmitter
  {
    private _module_builder             : DN.ModuleDef;
    private _ilg                        : NemerleGenerator;
    private _type_builder               : TypeBuilder;
    private _this_is_value_type         : bool;
    private _type_of_this               : DN.TypeSig;
    private _method_name                : string;
    private _method_builder             : MethodBuilder;
    private _methodDef                  : DN.MethodDef;
    private mutable _method_start_label : Label;
    private mutable _debug_doc          : PdbDocument;
    private mutable _is_ctor            : bool;
    private mutable _is_lambda          : bool;
    private _labels                     : Hashtable [int, Label] = Hashtable ();
    private _label_usage                : Hashtable [int, TExpr] = Hashtable ();
    private mutable _sequencePointCount : int;

    private static _primitiveTypeArrayOpcodes : Hashtable[DN.UTF8String, OpCode * OpCode * OpCode] = Hashtable();

    static this()
    {
      _primitiveTypeArrayOpcodes["SByte"]   = (OpCodes.Stelem_I1, OpCodes.Ldelem_I1, OpCodes.Ldind_I1);
      _primitiveTypeArrayOpcodes["Byte"]    = (OpCodes.Stelem_I1, OpCodes.Ldelem_U1, OpCodes.Ldind_U1);
      _primitiveTypeArrayOpcodes["Boolean"] = (OpCodes.Stelem_I1, OpCodes.Ldelem_I1, OpCodes.Ldind_I1);
      _primitiveTypeArrayOpcodes["Char"]    = (OpCodes.Stelem_I2, OpCodes.Ldelem_I2, OpCodes.Ldind_I2);
      _primitiveTypeArrayOpcodes["Int16"]   = (OpCodes.Stelem_I2, OpCodes.Ldelem_I2, OpCodes.Ldind_I2);
      _primitiveTypeArrayOpcodes["UInt16"]  = (OpCodes.Stelem_I2, OpCodes.Ldelem_U2, OpCodes.Ldind_U2);
      _primitiveTypeArrayOpcodes["Int32"]   = (OpCodes.Stelem_I4, OpCodes.Ldelem_I4, OpCodes.Ldind_I4);
      _primitiveTypeArrayOpcodes["UInt32"]  = (OpCodes.Stelem_I4, OpCodes.Ldelem_U4, OpCodes.Ldind_U4);
      _primitiveTypeArrayOpcodes["Int64"]   = (OpCodes.Stelem_I8, OpCodes.Ldelem_I8, OpCodes.Ldind_I8);
      _primitiveTypeArrayOpcodes["UInt64"]  = (OpCodes.Stelem_I8, OpCodes.Ldelem_I8, OpCodes.Ldind_I8);
      _primitiveTypeArrayOpcodes["Single"]  = (OpCodes.Stelem_R4, OpCodes.Ldelem_R4, OpCodes.Ldind_R4);
      _primitiveTypeArrayOpcodes["Double"]  = (OpCodes.Stelem_R8, OpCodes.Ldelem_R8, OpCodes.Ldind_R8);
      _primitiveTypeArrayOpcodes["IntPtr"]  = (OpCodes.Stelem_I,  OpCodes.Ldelem_I,  OpCodes.Ldind_I);
      _primitiveTypeArrayOpcodes["UIntPtr"] = (OpCodes.Stelem_I,  OpCodes.Ldelem_I,  OpCodes.Ldind_I);
    }

    /// Creates and executes a code generator for a method
    internal this(method_builder : MethodBuilder)
    {
      Manager              = method_builder.Manager;
      _module_builder      = Manager.Hierarchy.GetModuleBuilder();
      _method_builder      = method_builder;
      _methodDef           = _method_builder.GetMethodBuilder();
      _ilg                 = NemerleGenerator();
      _type_builder        = _method_builder.DeclaringType;
      _method_name         = _methodDef.DeclaringType.ReflectionFullName + "::" + _methodDef.Name;
      _this_is_value_type  = _type_builder.IsValueType;
      _type_of_this        = _type_builder.GetMemType().ToTypeSig();
    }

    public Run () : void
    {
      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      mutable debugBody;
      def funHeader = _method_builder.Header;

      match (funHeader.body)
      {
        | FunBody.Typed(body) =>
          debugBody = body;

          _is_ctor   = is_ctor(_method_builder);
          _is_lambda = _method_builder.DeclaringType.is_lambda;

          surroundwith (inScope)
          {
            funHeader.CheckDebugInfo(body);
            emit(body);

            if (body.Throws)
            {
              //method end is unreachable, but fall through end of method can be
              //detected by the runtime, fix it (bug #1091)
              def l = _ilg.DefineLabel ();
              _ilg.MarkLabel (l);
              _ilg.Emit (OpCodes.Br, l);
            }
            else _ilg.Emit (OpCodes.Ret);
          }

          // let GC take it
          _method_builder.GetHeader ().body = FunBody.ILed ();
        | _ => Util.ice ($"method $_method_name is already ILed")
      }

      foreach ((id, v) in _label_usage.KeyValuePairs)
      {
        when (v != null) // shouldn't happen now
          Message.Error (v.Location, $"non local goto (block return?) detected (l$id)");
      }

      _methodDef.Body = _ilg.CreateBody();
    }

    private static is_always_true (expr : TExpr) : bool
    {
      | Literal (Literal.Bool (true)) => true

      | If (cond_expr, then_expr, else_expr, _, _) =>
        def cond_always_true  = is_always_true  (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_true  = is_always_true  (then_expr);
        def else_always_true  = is_always_true  (else_expr);

        cond_always_true && then_always_true ||
        cond_always_false && else_always_true
        // unsafe, cond can have side effects
        // then_always_true && else_always_true

      | _ => false
    }

    [Nemerle.Memoize(Scope=Instance)]
    private DefineDebugDocument(filePath : string) : PdbDocument
    {
      assert(!string.IsNullOrWhiteSpace(filePath));
      Manager.Hierarchy.CreatePdbDocument(filePath)
    }

    [Nemerle.Memoize(Scope=Instance)]
    private DefineDebugDocument(loc : Location) : PdbDocument
    {
      if (!loc.IsDefault) // not Location.Default
        Manager.Hierarchy.CreatePdbDocument(loc.Source.File.FullName)
      else
      {
        Message.Warning ("missing debug location, this is probably some internal compiler error");
        def loc = LocationStack.Top();
        if (loc != Location.Default)
          DefineDebugDocument(loc);
        else
          _debug_doc;
      }
    }

    public SetDocument (loc : Location) : void
    {
      _debug_doc = DefineDebugDocument(loc);
    }

    private static is_always_false (expr : TExpr) : bool
    {
      | Literal (Bool (false)) => true

      | If (cond_expr, then_expr, else_expr, _, _) =>
        def cond_always_true  = is_always_true  (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_false = is_always_false (then_expr);
        def else_always_false = is_always_false (else_expr);

        cond_always_true && then_always_false ||
        cond_always_false && else_always_false
        // unsafe, cond can have side effects
        // then_always_false && else_always_false

      | _ => false
    }

    IsDebugEnabled : bool { get { _debug_doc != null } }


    /** Emit volatile prefix if needed. */
    private maybe_volatile (expr : TExpr) : void
    {
      | StaticRef (_, f is IField, _)
      | FieldMember (_, f) =>
        when (f.IsVolatile)
          _ilg.Emit (OpCodes.Volatile)
      | _ => ()
    }


    /** Box the value of type [t] if needed.  */
    need_reference (t : DN.TypeSig) : void
    {
      when (t.IsValueType || t.IsGenericParameter)
        _ilg.Emit (OpCodes.Box, t);
    }


    is_void (ty : TypeVar) : bool
    {
      ty.Fix () : object == InternalType.Void
    }


    static is_ctor (meth : IMethod) : bool
    {
      meth.MemberKind == MemberKinds.Constructor
    }

    store_local (decl : LocalValue) : void
    {
      if (decl.IsParm) {
        Util.cassert (! decl.IsByRefParm);
        store_argument (decl.Parameter)
      } else
        // simply skip assignment here
        unless (is_void (decl.Type))
          emit_stloc(decl.LocalSlot);
    }


    emit_parms (parms : list [Param]) : void
    {
      emit_exprs (parms.Map (_.expr));
    }

    static skipped (expr : TExpr) : void
    {
      | TExpr.Goto
      | TExpr.Literal(Literal.Void)
      | TExpr.Label(_, Literal(Void)) => ()
      | _ => Message.Warning(expr.Location, "this expression has been skipped in code generation because of unreachable code");
    }

    static no_cast_needed (src_type : DN.TypeSig, target_type : DN.TypeSig) : bool
    {
      DN.TypeEqualityComparer.Instance.Equals(src_type, target_type)
    }


    make_ref_type (t : DN.TypeSig) : DN.TypeSig
    {
      SystemTypeCache.GetByRefTypeSpec(t).TypeSig
    }

    private emit_tuple_function_conversion (after : FixedType, member_from : FixedType, member : IMember) : void
    {
      def interesting_part (t) {
        if (member is IMethod)
          match (t.Fix ()) {
            | FixedType.Fun (_, t) => t
            | _ => Util.ice ()
          }
        else t
      }

      def is_single_arg_function (t) {
        match (interesting_part (t).Fix ()) {
          | Fun (from, _) => ! (from.Fix () is FixedType.Tuple)
          | _ => false
        }
      }

      match (member_from) {
        | Class | Array | StaticTypeVarRef =>
          match (after) {
            | Fun (from, to) =>
              match (from.Fix ()) {
                | Tuple (parms) =>

                  // I think there is one more case
                  // class A[T] { x : T; }
                  // B[T] : A[T->void]
                  // C[T] : B[T*T]
                  // but this is really perverse

                  when (is_single_arg_function (member.GetMemType ()) ||
                        is_single_arg_function (member_from.TypeOfMember (member))) {

                    def ftn = InternalType.GetFunctionType (parms.Length);
                    def info =
                      if (to.Fix () is FixedType.Void) {
                        def mt = FixedType.Class (ftn.FromTupleVoidTyCon, parms);
                        mt.GetMethodInfo(ftn.FromTupleVoidCtor, [])
                      } else {
                        def mt = FixedType.Class (ftn.FromTupleTyCon, parms + [to]);
                        mt.GetMethodInfo(ftn.FromTupleCtor, [])
                      }
                    // Message.Warning ($ "using f1->fN conversion");
                    _ilg.Emit (OpCodes.Newobj, info)
                  }

                | _ => {}
              }
            | _ => {}
          }
        | _ => {}
      }
    }

    /// If stack contains 1 it plase and on the contrary
    private InversBool() : void
    {
      _ilg.Emit(OpCodes.Ldc_I4_0); _ilg.Emit(OpCodes.Ceq);
    }

    EmitSimpleDebugLocation([NotNull] tExpr : TExpr) : void
    {
      | Sequence => ()
      | _ =>
        def pExpr = tExpr.ParsedObject;
        when (pExpr == null)
          return;

        EmitDebugLocation(pExpr.Location);
    }

    EmitDebugLocation(loc : Location) : void
    {
      def filePath = loc.File;
      when (!loc.IsGeneratedOrEmpty && loc.IsTextAvailable && filePath != "")
      {
        def debugDoc = DefineDebugDocument(filePath); // TExpr source file (possible from #line pragma)
        def start    = loc.StartLineColumn;
        def end      = loc.EndLineColumn;
        _ilg.MarkSequencePoint(debugDoc, start.Line, start.Column, end.Line, end.Column);
        _sequencePointCount++;
      }
    }

    EmitHiddenDebugLocation(loc : Location) : void
    {
      def filePath = loc.File;
      when (!loc.IsEmpty && loc.IsTextAvailable && filePath != "")
      {
        def debugDoc = DefineDebugDocument(filePath); // TExpr source file (possible from #line pragma)
        _ilg.MarkSequencePoint(debugDoc, 0xFEEFEE, 0, 0xFEEFEE, 0);
        _sequencePointCount++;
      }
    }

    /// Emits an expression.
    private emit(expr : TExpr) : void
    {
      def expr = expr;
      log (EMIT, $"{ emit: $expr");
      Util.cassert (expr != null);

      def funHeader = _method_builder.Header;
      mutable pSeq;
      _ = funHeader.Braces.TryGetValue(expr, out pSeq);
      unless (pSeq?.OpeningBracket.IsDefault)
        EmitDebugLocation(pSeq?.OpeningBracket);

      mutable pExpr;
      when (funHeader.SequenceElems.TryGetValue(expr, out pExpr))
        EmitDebugLocation(pExpr.Location.TruncateToEndLine());

      locate (expr.Location)
      match (expr)
      {
        // -- SEQUENCING ---------------------------------------------------

        | Sequence(e1, e2) => // emits a sequence of expressions
          def emitSequence(e1 : TExpr, e2 : TExpr): void
          {
            emit(e1);
            if (!e1.Throws || e2.JumpTarget)
              emit(e2);
            else
              skipped(e2);
          }
          //def loop(pExpr)
          //{
          //  | PExpr.TypeEnforcement as te => loop(te.expr)
          //  | PExpr.Sequence as seq =>
          //    EmitDebugLocation(seq.OpeningBracket);
          //    surroundwith (inScope)
          //      emitSequence(e1, e2);
          //    EmitDebugLocation(seq.ClosingBracket);
          //
          //  | _ => emitSequence(e1, e2);
          //}
          //loop(expr.ParsedObject)
          emitSequence(e1, e2);

        | DefValIn (_, let_val, body) when let_val.Throws && ! body.JumpTarget =>
          emit (let_val);
          skipped (body);

        | DefValIn(decl, TExpr.Literal, TExpr.Literal(Literal.Void())) when !decl.EverUsed && !decl.InClosure => () // ignore debug literals
        | DefValIn(decl, let_val, let_in) => // emits a local value definition

          match (let_val) {
            | DefaultValue when !decl.IsMutable =>
              unless (is_void (decl.Type))
                declare_val_local_slot_ex (decl);

            | ImplicitValueTypeCtor =>
              def slot = declare_val_local_slot (decl);
              emit_ldloca(slot);
              _ilg.Emit (OpCodes.Initobj, let_val.ToTypeSig());

            | _ =>
              emit (let_val);
              unless (is_void (decl.Type)) {
                if (!decl.EverUsed) {
                  _ilg.Emit (OpCodes.Pop);
                } else {
                  def local_slot = declare_val_local_slot(decl);
                  unless (let_val.Throws)
                    emit_stloc(local_slot);
                }
              }
          }

          emit (let_in);


        /* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ */

        /* emits the if/then/else construction */
        | If(cond_expr, then_expr, else_expr, then_debug_loc, else_debug_loc) =>
          def emit_branch(expr : TExpr, else_label : Label, debug_loc: Location)
          {
            //EmitHiddenDebugLocation(expr.Location);
            def emit_br(opcode1, opcode2)
            {
              if (true/*!IsDebugEnabled || !debug_loc.IsSourceAvailable*/)
              {
                EmitHiddenDebugLocation(expr.Location);
                _ilg.Emit(opcode1, else_label);
              }
              else
              {
                def debug_label = _ilg.DefineLabel();
                _ilg.Emit(opcode2, debug_label);
                EmitDebugLocation(debug_loc);
                _ilg.Emit(OpCodes.Br, else_label);
                _ilg.MarkLabel(debug_label);
              }
            }

            match (expr)
            {
              | MacroEnvelope(_, _, nested_cond, _)
              | TypeConversion(nested_cond, _, ConversionKind.Nop, _)
              | TypeConversion(nested_cond, _, ConversionKind.UpCast, _)
              | Call(OpCode("=="), [Param(expr = nested_cond), Param(expr = TExpr.Literal(Literal.Bool(true)))], _)
              | Call(OpCode("=="), [Param(expr = nested_cond), Param(expr = TExpr.TypeConversion(TExpr.Literal(Literal.Bool(true)), _, _, _))], _) =>
                emit_branch(nested_cond, else_label, debug_loc)

              | Call(OpCode("==.ref"), [Param(expr = TExpr.Literal(Literal.Null)), obj], _)
              | Call(OpCode("=="),     [Param(expr = TExpr.Literal(Literal.Integer(val = 0))), obj], _)
              | Call(OpCode("==.ref"), [obj, Param(expr = TExpr.Literal(Literal.Null))], _)
              | Call(OpCode("=="),     [obj, Param(expr = TExpr.Literal(Literal.Integer(val = 0)))], _) =>
                emit(obj.expr);
                emit_br(OpCodes.Brtrue, OpCodes.Brfalse);

              | Call(OpCode("!=.ref"), [Param(expr = TExpr.Literal(Literal.Null)), obj], _)
              | Call(OpCode("!="),     [Param(expr = TExpr.Literal(Literal.Integer(val = 0))), obj], _)
              | Call(OpCode("!=.ref"), [obj, Param(expr = TExpr.Literal(Literal.Null))], _)
              | Call(OpCode("!="),     [obj, Param(expr = TExpr.Literal(Literal.Integer(val = 0)))], _) =>
                emit(obj.expr);
                emit_br(OpCodes.Brfalse, OpCodes.Brtrue);

              | Call (OpCode (opcode), parms, _) =>
                emit_parms(parms);

                // NOTE: the opcodes are swapped so that the 'then' expression can be emitted before the 'else' expression
                def opcodes =
                  match (opcode)
                  {
                    | "==.ref" | "=="   => (OpCodes.Bne_Un, OpCodes.Beq)
                    | "!=.ref" | "!="   => (OpCodes.Beq,    OpCodes.Bne_Un)
                    | "<.s"    | "<.f"  => (OpCodes.Bge,    OpCodes.Blt)
                    | "<.u"             => (OpCodes.Bge_Un, OpCodes.Blt_Un)
                    | ">.s"    | ">.f"  => (OpCodes.Ble,    OpCodes.Bgt)
                    | ">.u"             => (OpCodes.Ble_Un, OpCodes.Bgt_Un)
                    | "<=.s"   | "<=.f" => (OpCodes.Bgt,    OpCodes.Ble)
                    | "<=.u"            => (OpCodes.Bgt_Un, OpCodes.Ble_Un)
                    | ">=.s"   | ">=.f" => (OpCodes.Blt,    OpCodes.Bge)
                    | ">=.u"            => (OpCodes.Blt_Un, OpCodes.Bge_Un)
                    | "bool.!"          => (OpCodes.Brtrue, OpCodes.Brfalse)
                    | _ => Util.ice ("invalid opcode '" + opcode + "' in optimized TExpr.If pattern")
                  };

                emit_br(opcodes);

              | HasType(val, ty) =>
                emit(val);
                need_reference(val.ToTypeSig());
                _ilg.Emit(OpCodes.Isinst, ty.ToTypeSig());
                emit_br(OpCodes.Brfalse, OpCodes.Brtrue);

              | If (new_cond, new_then, new_else, _, _) =>
                def my_label_else = _ilg.DefineLabel();
                def my_label_fi = _ilg.DefineLabel();
                emit_branch(new_cond, my_label_else, Location.Default);
                emit_branch(new_then, else_label, Location.Default);
                unless (new_then.Throws)
                {
                  EmitHiddenDebugLocation(new_then.Location);
                  _ilg.Emit(OpCodes.Br, my_label_fi);
                }
                _ilg.MarkLabel(my_label_else);
                emit_branch(new_else, else_label, Location.Default);
                _ilg.MarkLabel(my_label_fi);

              | e when is_always_true(e) => ()
              | e when is_always_false(e) => EmitHiddenDebugLocation(e.Location); _ilg.Emit(OpCodes.Br, else_label);
              | _ =>
                //EmitDebugLocation(expr.Location);

                //Message.Debug (e.loc, pretty_print (e));
                // most of other expressions here are TExpr.Ref
                emit(expr);

                unless (expr.Throws)
                  emit_br(OpCodes.Brfalse, OpCodes.Brtrue);
            }
          }

          def label_condition_else = _ilg.DefineLabel();
          def label_condition_fi   = _ilg.DefineLabel();

          surroundwith (inScope)
          {
            emit_branch(cond_expr, label_condition_else, else_debug_loc);

            surroundwith (inScope)
            {
              //EmitDebugLocation(then_debug_loc);
              emit(then_expr);
            }

            unless (then_expr.Throws)
            {
              EmitHiddenDebugLocation(then_expr.Location);
              _ilg.Emit(OpCodes.Br, label_condition_fi);
            }

            surroundwith(inScope)
            {
              _ilg.MarkLabel(label_condition_else);
              emit(else_expr);
            }

            _ilg.MarkLabel(label_condition_fi);
          }

        | HasType(expr, ty) => // emit a type check construction
          emit(expr);
          def label_condition_not_null = _ilg.DefineLabel();
          def label_condition_has_type = _ilg.DefineLabel();
          def label_condition_continue = _ilg.DefineLabel();

          _ilg.Emit(OpCodes.Dup);
          _ilg.Emit(OpCodes.Brtrue_S, label_condition_not_null);

          _ilg.Emit(OpCodes.Newobj, InternalType.MatchFailureException_ctor);
          _ilg.Emit(OpCodes.Throw);

          _ilg.MarkLabel(label_condition_not_null);

          need_reference(expr.ToTypeSig());
          _ilg.Emit(OpCodes.Isinst, ty.ToTypeSig());
          _ilg.Emit(OpCodes.Brtrue_S, label_condition_has_type);
          _ilg.Emit(OpCodes.Ldc_I4_0);
          _ilg.Emit(OpCodes.Br_S, label_condition_continue);
          _ilg.MarkLabel(label_condition_has_type);
          _ilg.Emit(OpCodes.Ldc_I4_1);
          _ilg.MarkLabel(label_condition_continue);


        | DefaultValue =>
          match (expr.FixedType())
          {
            | FixedType.Void => ()
            | ty when ty.Equals(InternalType.Char)
            | ty when ty.Equals(InternalType.Byte)
            | ty when ty.Equals(InternalType.SByte)
            | ty when ty.Equals(InternalType.Int16)
            | ty when ty.Equals(InternalType.Int32)
            | ty when ty.Equals(InternalType.UInt16)
            | ty when ty.Equals(InternalType.UInt32)
            | ty when ty.Equals(InternalType.Boolean) => _ilg.Emit(OpCodes.Ldc_I4_0);
            | ty when ty.Equals(InternalType.Int64)
            | ty when ty.Equals(InternalType.UInt64) =>
              _ilg.Emit(OpCodes.Ldc_I4_0);
              _ilg.Emit(OpCodes.Conv_I8);
            | ty when ty.Equals(InternalType.Single) => _ilg.Emit(OpCodes.Ldc_R4, 0.0f);
            | ty when ty.Equals(InternalType.Double) => _ilg.Emit (OpCodes.Ldc_R8, 0.0d);
            | ty when ty.Equals(InternalType.Decimal) =>
              _ilg.Emit(OpCodes.Ldc_I4_0);
              _ilg.Emit(OpCodes.Newobj, GetDecimalCtor("Int32"));
            | ty =>
              def typeSig = ty.ToTypeSig();
              if (typeSig.IsValueType || typeSig.IsGenericParameter)
              {
                def local_slot = _ilg.DeclareLocal(typeSig);
                emit_ldloca(local_slot);
                _ilg.Emit(OpCodes.Initobj, typeSig);
                emit_ldloc(local_slot);
              }
              else
                _ilg.Emit (OpCodes.Ldnull);
          }

        | CtorOf(ty, method) =>
          def sysType  = ty.ToTypeSig();
          def ctorInfo = ty.GetMethodInfo(method, []);
          _ilg.Emit(OpCodes.Ldtoken, ctorInfo);
          _ilg.Emit(OpCodes.Ldtoken, sysType);
          _ilg.Emit(OpCodes.Call,      InternalType.MethodBase_GetMethodFromHandle2);
          _ilg.Emit(OpCodes.Castclass, InternalType.ConstructorInfo.ToTypeSig());

        | MethodOf(from_type, method, typars) =>
          def methodInfo = from_type.GetMethodInfo(method, typars);
          def declTy     = methodInfo.DeclaringType;
          _ilg.Emit(OpCodes.Ldtoken, methodInfo);
          if (declTy == null)
            _ilg.Emit(OpCodes.Call, InternalType.MethodBase_GetMethodFromHandle);
          else
          {
            _ilg.Emit(OpCodes.Ldtoken, declTy);
            _ilg.Emit(OpCodes.Call, InternalType.MethodBase_GetMethodFromHandle2);
          }
          _ilg.Emit(OpCodes.Castclass, InternalType.MethodInfo.ToTypeSig());

        | ClosureObjectOf(TExpr.FieldMember(obj, _))    => emit(obj);
        | ClosureFieldOf(TExpr.FieldMember(obj, field)) => emit(TExpr.FieldOf(obj.Type, field));
        | ClosureObjectOf => assert(false, "You must put into ClosureObjectOf only TExpr.LocalRef which will be closured by compiler");
        | ClosureFieldOf  => assert(false, "You must put into ClosureFieldOf only TExpr.LocalRef which will be closured by compiler");
        | FieldOf(ty, field) =>
          def fielfInfo = ty.GetFieldInfo(field);
          def declTy = fielfInfo.DeclaringType;
          _ilg.Emit(OpCodes.Ldtoken, fielfInfo);
          if (declTy == null)
            _ilg.Emit(OpCodes.Call, InternalType.FieldInfo_GetFieldFromHandle);
          else
          {
            _ilg.Emit(OpCodes.Ldtoken, declTy);
            _ilg.Emit(OpCodes.Call, InternalType.FieldInfo_GetFieldFromHandle2);
          }
          _ilg.Emit(OpCodes.Castclass, InternalType.FieldInfo.ToTypeSig());

        | TypeOf(t) => // load runtime representation of given type
          _ilg.Emit(OpCodes.Ldtoken, t.ToTypeSig());
          _ilg.Emit(OpCodes.Call, InternalType.Type_GetTypeFromHandle);

        | Switch(indexing_expr, default_expr, cases) => // emits the TExpr.Switch instruction
          match (cases)
          {
            | [] => Message.Warning ("empty TExpr.Switch instruction");
            | _ =>
              emit(indexing_expr);
              emit_switch(default_expr, cases)
          }

        | MacroEnvelope(_, _, expr, _) =>
          emit(expr)

        | Label(id, DefaultValue as nextExpr) when nextExpr.Type is FixedType.Void with resetControlLeave = true // VladD2: This is a workaround for "dead code" hack.
                                                                                                                 // The Label(_, DefaultValue) is usually generated by macros. And macros are responsible for the lack of dead code.
        | Label(id, nextExpr) with resetControlLeave = false =>
          // insert label so TExpr.Goto can work
          if (_labels.Contains(id))
            _label_usage[id] = null;
          else
            _labels[id] = _ilg.DefineLabel();

          _ilg.MarkLabel(_labels[id], resetControlLeave);
          emit(nextExpr);


        | Goto (id, try_block) =>
          if (_labels.Contains (id))
            _label_usage[id] = null;
          else
          {
            _label_usage[id] = expr;
            _labels[id] = _ilg.DefineLabel ();
          }

          if (try_block == 0)
            _ilg.Emit (OpCodes.Br, _labels [id]);
          else
          {
            // Message.Warning (expr.loc, $"emit leave, id=$id");
            _ilg.Emit (OpCodes.Leave, _labels [id]);
          }


        /* -- TYPE CONVERSIONS --------------------------------------------- */


        // when expr throws we shouldn't emit anything
        | TypeConversion(expr, _, _, _) when expr.Throws => emit (expr)
        | TypeConversion(expr, target_type, _, _) when target_type.IsPointer => emit_value_to_ptr_conversion(expr, target_type);
        | TypeConversion(expr, cast_to_type, _, _) /* do not perform casts between same types */
          when no_cast_needed (expr.ToTypeSig(), cast_to_type.ToTypeSig()) => emit (expr)
        | TypeConversion(expr, cast_to_type, ConversionKind.Boxing, _) // special case for  'a : 'b conversion
          when cast_to_type.ToTypeSig().IsGenericParameter =>
          emit (expr);
          _ilg.Emit (OpCodes.Box, expr.ToTypeSig());
          _ilg.Emit (OpCodes.Unbox_Any, cast_to_type.ToTypeSig());

        | TypeConversion(expr, cast_to_type, _, _) when cast_to_type.ToTypeSig().IsGenericParameter =>
          emit (expr);
          when (expr.FixedType().IsValueType || expr.FixedType() is FixedType.StaticTypeVarRef)
            _ilg.Emit (OpCodes.Box, expr.ToTypeSig());
          _ilg.Emit (OpCodes.Unbox_Any, cast_to_type.ToTypeSig());

        | TypeConversion(ignored, ty, _, _) when is_void (ty) =>
          // a little trickery, so emit can be tail called sometimes
          if (is_void (ignored.Type))
            emit (ignored)
          else {
            emit (ignored);
            _ilg.Emit (OpCodes.Pop);
          }

        /* to nonvalue type */
        | TypeConversion(expr, cast_to_type, kind, _) when !cast_to_type.Fix().IsValueType =>
          emit(expr);

          if (is_void(expr.Type))
            /* special case casts from void */
            _ilg.Emit (OpCodes.Ldnull);
          else if (expr.ToTypeSig().IsGenericParameter)
          {
            _ilg.Emit (OpCodes.Box, expr.ToTypeSig());

            unless (cast_to_type.Fix().IsSystemObject)
              if (cast_to_type.Fix().IsValueType)
                _ilg.Emit(OpCodes.Unbox_Any, cast_to_type.ToTypeSig());
              else
                _ilg.Emit(OpCodes.Castclass, cast_to_type.ToTypeSig());
          }
          else if (expr.ToTypeSig().IsValueType)
          {
            // Message.Debug (k.ToString ());
            // box value types casted to non value types
            _ilg.Emit(OpCodes.Box, expr.ToTypeSig());
          }
          else
          {
            // upcast / downcast non-value types
            def castToFixedType = cast_to_type.Fix();
            def cast_to_type = castToFixedType.ToTypeSig();

            when (expr.ToTypeSig().IsArray && cast_to_type.IsArray
              && expr.ToTypeSig().Next.IsValueType != cast_to_type.Next.IsValueType)
            {
              Message.Error(expr.Location, $"attempting to cast a value type array $(expr.ToTypeSig()) to non-value type array $(cast_to_type) which cannot succeed");
            }

            def isUpCast = kind is ConversionKind.UpCast;

            when (!isUpCast || castToFixedType.IsInterface)
              _ilg.Emit(OpCodes.Castclass, cast_to_type);
          }

        // unbox value types or perform value type conversion
        | TypeConversion (val, cast_to_type, kind, _) =>
          def is_checked = ! (kind is IL (false));
          emit (val);
          def valType       = val.FixedType();
          def type_of_expr  = valType.ToTypeSig();
          def cast_to_stype = cast_to_type.ToTypeSig();

          when (type_of_expr.IsGenericParameter)
            _ilg.Emit (OpCodes.Box, type_of_expr);

          if (type_of_expr.IsValueType) {
            /* perform conversion of value types */
            emit_value_type_conversion (expr.Location, valType, cast_to_type.Fix (), is_checked)
          }
          else if (InternalType.Object.Equals(valType) && cast_to_stype.IsValueType)
            _ilg.Emit (OpCodes.Unbox_Any, cast_to_stype)
          else if (type_of_expr.IsGenericParameter ||
                   InternalType.Object.Equals(valType) ||
                   valType.IsInterface ||
                   (InternalType.Enum.Equals(valType) && cast_to_type.IsEnum)) {
            /* unboxing returns a pointer to a value */
            _ilg.Emit (OpCodes.Unbox, cast_to_stype);

            maybe_volatile (val);

            emit_ldind_for_value_type (cast_to_stype)
          }
          else
            Util.ice($"$_method_name: failed to convert non-value type $type_of_expr to a value type $cast_to_type");

        /* -- REFERENCES --------------------------------------------------- */

        /* load the value of a local variable or a method parameter */
        | LocalRef(decl) =>
          unless (is_void (decl.Type))
            emit_ce_ref (decl, get_address_for_value_types = expr.NeedAddress)

        /* load the value of a field */
        | FieldMember(base_object, field) =>
          def result_will_be_address = expr.NeedAddress;

          if (result_will_be_address)
            _ = emit_and_convert_to_address (base_object);
          else
            emit (base_object);

          maybe_volatile (expr);

          def field_info = base_object.Type.GetFieldInfo(field);

          when (base_object.ToTypeSig().IsGenericParameter)
            _ilg.Emit (OpCodes.Box, base_object.ToTypeSig());

          if (result_will_be_address)
            _ilg.Emit(OpCodes.Ldflda, field_info);
          else
            _ilg.Emit(OpCodes.Ldfld, field_info);

          emit_tuple_function_conversion (expr.FixedType(), base_object.FixedType(), field);

        /* load the value of a static field */
        | StaticRef(t, field is IField, _) =>
          def field_info = t.GetFieldInfo(field);

          assert(field.IsStatic, "GlobalRef to a non-static field");

          when (field.IsLiteral)
            // should not happen
            Message.Warning ("loading literal as field `" + field_info.ToString () + "'");

          maybe_volatile (expr);
          if (expr.NeedAddress) {
            if(field.IsMutable)
               _ilg.Emit (OpCodes.Ldsflda, field_info);
            else {
               def temp = _ilg.DeclareLocal (field.GetMemType().ToTypeSig());
               _ilg.Emit (OpCodes.Ldsfld, field_info);
               emit_stloc(temp);
               emit_ldloca(temp);
            }
          }
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);

          emit_tuple_function_conversion (expr.FixedType(), t, field);

        | PointerIndexer(ptr, index) => emit_ptr_indexing(expr.NeedAddress, ptr, index);
        | ArrayIndexer(array_obj, [index]) => // load an array element
          emit_exprs ([array_obj, index]);
          def element_type = array_obj.ToTypeSig().Next;
          assert(element_type != null, "non-array in TExpr.ArrayIndexer");

          if (expr.NeedAddress)
            _ilg.Emit (OpCodes.Ldelema, element_type)
          else
            emit_array_load_opcode (element_type);


        | ArrayIndexer(array_obj, indexes) =>
          emit_exprs ([array_obj] + indexes);
          def arrayType = GetArrayTypeSpec(array_obj);
          def method = if (expr.NeedAddress) arrayType.Address else arrayType.Get;
          emit_method_call (expr, true, method);


        /* -- ASSIGNMENTS -------------------------------------------------- */

        | Assign(LocalRef, val) when val.Throws
        | Assign(LocalRef (local_var), val) when is_void (local_var.Type) => emit(val);
        | Assign(LocalRef (decl), ImplicitValueTypeCtor as ctr) => // special case these assignments for performance
          emit_ce_ref (decl, get_address_for_value_types = true);
          _ilg.Emit (OpCodes.Initobj, ctr.ToTypeSig());


        /* assignment to ref/out parameter */
        | Assign(LocalRef (local_var), val) when local_var.IsByRefParm =>
          def vars = emit_exprs_prepare ([val]);
          emit_ldarg (local_var.Parameter);
          emit_exprs_push (vars, [val]);

          def ty = val.ToTypeSig();
          if (ty.IsValueType || ty.IsGenericParameter)
            _ilg.Emit (OpCodes.Stobj, ty)
          else
            _ilg.Emit (OpCodes.Stind_Ref);


        /* assignment to a local variable */
        | Assign(LocalRef (local_var), val) =>
          emit (val);
          unless (val.Throws)
            store_local (local_var);


        /* assignment to a field */
        | Assign(FieldMember (base_object, field) as target, val) =>
          if (val.NeedsEmptyStack) {
            def base_local = declare_expr_local_slot(base_object);
            def val_local = declare_expr_local_slot(val);

            emit (base_object);
            emit_stloc(base_local);

            emit (val);
            emit_stloc(val_local);

            emit_ldloc(base_local);
            when (base_object.ToTypeSig().IsGenericParameter)
              _ilg.Emit (OpCodes.Box, base_object.ToTypeSig());
            emit_ldloc(val_local);
          } else {
            emit (base_object);
            when (base_object.ToTypeSig().IsGenericParameter)
              _ilg.Emit (OpCodes.Box, base_object.ToTypeSig());
            emit (val);
          }
          maybe_volatile (target);

          def field_info = base_object.Type.GetFieldInfo(field);

          _ilg.Emit (OpCodes.Stfld, field_info);


        /* assignment to a static field */
        | Assign(StaticRef (t, f is IField, _) as target, val) =>
          emit (val);
          maybe_volatile (target);

          def field_info = t.GetFieldInfo(f);

          _ilg.Emit (OpCodes.Stsfld, field_info);


        /* assignment to an array element */
        | Assign(ArrayIndexer (array_obj, [index]) as target, val) =>
          def type_of_val = val.ToTypeSig();
          if (index.NeedsEmptyStack || val.NeedsEmptyStack) {
            def obj_local = declare_expr_local_slot(array_obj);
            def index_local = declare_expr_local_slot(index);
            def val_local = declare_expr_local_slot(val);

            emit (array_obj);
            emit_stloc(obj_local);

            emit (index);
            emit_stloc(index_local);

            emit (val);
            emit_stloc(val_local);

            emit_ldloc(obj_local);
            emit_ldloc(index_local);
            when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
              _ilg.Emit (OpCodes.Ldelema, type_of_val);

            emit_ldloc(val_local);
          } else {
            emit (array_obj);
            emit (index);
            when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
              _ilg.Emit (OpCodes.Ldelema, type_of_val);

            emit (val);
          }
          emit_array_store_opcode (target.ToTypeSig());

        | Assign(ArrayIndexer (array_obj, indexes), val) =>
          emit_exprs ([array_obj] + indexes + [val]);
          def method = GetArrayTypeSpec(array_obj).Set;
          emit_method_call (expr, true, method);

        | Assign(This, val) =>
          Util.cassert (_this_is_value_type,
                        "we can assign to 'this' only in valuetypes");
          def vars = emit_exprs_prepare ([val]);
          _ilg.Emit (OpCodes.Ldarg_0);
          emit_exprs_push (vars, [val]);

          _ilg.Emit (OpCodes.Stobj, _type_of_this)

        | MultipleAssign(assigns) =>
          def emit_store (local_var : LocalValue, _) {
            if (local_var.EverUsed)
              store_local (local_var)
            else
              _ilg.Emit (OpCodes.Pop);
          }
          emit_exprs (assigns.Map ((_, e) => e));
          foreach (assign in assigns.Rev())
            emit_store(assign);


        /* -- CALLS -------------------------------------------------------- */

        | Call(Base(base_ctor) as func, ctor_params, _) => // call the base constructor
          def parameters = ctor_params.Map (_.expr);
          def vars = emit_exprs_prepare (parameters);
          _ilg.Emit (OpCodes.Ldarg_0);
          emit_exprs_push(vars, parameters);

          EmitDebugLocation(func.Location);
          def ctr_inf = _type_builder.GetMemType().GetMethodInfo(base_ctor, []);
          _ilg.Emit(OpCodes.Call, ctr_inf);
          when (expr.GenerateTail)
            _ilg.Emit(OpCodes.Ret);

        | Call(StaticRef(_t, meth is IMethod, _) as func, ctor_params, _) when is_ctor(meth) => // create a new object
          emit_parms(ctor_params);

          EmitDebugLocation(func.Location);
          def ctr_inf = _t.GetMethodInfo(meth, []);
          _ilg.Emit(OpCodes.Newobj, ctr_inf);
          when (expr.GenerateTail)
            _ilg.Emit(OpCodes.Ret);

        | Call(MethodRef(This as th, method, tparms, _) as func, method_params, _) when _this_is_value_type => // emit a call to an instance method, basing on the 'this' pointer for value types
          def method_inf = th.Type.GetMethodInfo(method, tparms);

          def parameters = method_params.Map (_.expr);
          def vars = emit_exprs_prepare (parameters);

          _ilg.Emit (OpCodes.Ldarg_0);

          // it actually IS the proper way to do it --
          // if this is our method, then we do not need to box
          unless (th.FixedType().Equals(_type_builder.GetMemType()))
          {
            _ilg.Emit (OpCodes.Ldobj, _type_of_this);
            _ilg.Emit (OpCodes.Box, _type_of_this);
          }
          emit_exprs_push(vars, parameters);

          EmitDebugLocation(func.Location);
          emit_method_call(expr, true, method_inf, method, th.FixedType())

        | Call(MethodRef(base_object, method, tparms, notvirt) as func, method_params, _) => // emit a call to an instance method
          def sequencePointCount = _sequencePointCount;
          def method_inf = base_object.Type.GetMethodInfo(method, tparms);
          def parameters = method_params.Map(_.expr);
          def vars = emit_exprs_prepare (parameters);
          def is_value_type = emit_and_convert_to_address(base_object);

          emit_exprs_push(vars, parameters);

          unless (sequencePointCount == _sequencePointCount /*&& expr.IsStatement*/)
            when (func.ParsedObject != null)
              EmitDebugLocation(func.Location);

          if (base_object.NeedsConstrained)
          {
            def is_tail = expr.GenerateTail;
            when (is_tail)
            {
              expr.GenerateTail = false;
              _ilg.Emit(OpCodes.Tailcall);
            }
            _ilg.Emit(OpCodes.Constrained, base_object.ToTypeSig());
            emit_method_call(expr, false, method_inf, method, base_object.FixedType()); // constrained always need callvirt
            when (is_tail)
              _ilg.Emit (OpCodes.Ret);
          }
          else
            emit_method_call (expr, is_value_type || notvirt, method_inf, method, base_object.FixedType());


        | Call(StaticRef(_t, mi is IMethod, tparms) as func, method_parms, _) => // emit a call to a static method
          def sequencePointCount = _sequencePointCount;
          emit_parms(method_parms);

          unless (sequencePointCount == _sequencePointCount /*&& expr.IsStatement*/)
            when (func.ParsedObject != null)
              EmitDebugLocation(func.Location);
          def method_info = _t.GetMethodInfo(mi, tparms);
          Util.cassert(mi.IsStatic, $ "Call TExpr.GlobalRef to a non-static field: $(method_info.Name)");
          emit_method_call(expr, true, method_info, mi, _t)

        | Call(OpCode(opcode), parms, _) => // emit an operator
          // FIXME: seperate out
          emit_parms(parms);

          match (opcode)
          {
            | "+.s"                       => _ilg.Emit (OpCodes.Add_Ovf)
            | "+.u"                       => _ilg.Emit (OpCodes.Add_Ovf_Un)
            | "+.f"                       => _ilg.Emit (OpCodes.Add)
            | "+.p"  with inc = true
            | "-.p"  with inc = false     =>
              match (parms)
              {
                | [par1, par2] when par1.expr.Type.IsPointer && par2.expr.Type.Fix().Equals(InternalType.Int32) with type = par1.expr.Type =>
                  def size = get_elem_size(type);

                  _ilg.Emit(OpCodes.Conv_I);

                  emit_index_multiplier(size);

                  when (size > 8)
                    _ilg.Emit(OpCodes.Mul);

                  if (inc)
                    _ilg.Emit(OpCodes.Add);
                  else
                    _ilg.Emit(OpCodes.Sub);

                | _ => Util.ice(_method_name + ": incorrect args for TExpr.Opcode (" + opcode + ")")
              }

            | "<<.s" | "<<.f"
            | "<<.u"                      => _ilg.Emit (OpCodes.Shl)
            | ">>.s" | ">>.f"             => _ilg.Emit (OpCodes.Shr)
            | ">>.u"                      => _ilg.Emit (OpCodes.Shr_Un)
            | "unary.+.s"
            | "unary.+.u"
            | "unary.+.f"                 => ()
            | "-.s"                       => _ilg.Emit (OpCodes.Sub_Ovf)
            | "-.u"                       => _ilg.Emit (OpCodes.Sub_Ovf_Un)
            | "-.f"                       => _ilg.Emit (OpCodes.Sub)
            | "unary.-.s"                 =>
              _ilg.Emit (OpCodes.Ldc_I4_M1);
              emit_value_type_conversion (expr.Location, InternalType.Int32,
                                          parms.Head.expr.FixedType(), true);
              _ilg.Emit (OpCodes.Mul_Ovf)
            | "unary.-.f"                 => _ilg.Emit (OpCodes.Neg)
            | "unary.~.u"
            | "unary.~.s"                 => _ilg.Emit(OpCodes.Not);
            | "++.i4.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add);
            | "--.i4.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub);
            | "++.i4.s"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf);
            | "--.i4.s"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf);
            | "++.i4.u"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf_Un);
            | "--.i4.u"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf_Un);
            | "++.i4.s.i1"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf);     _ilg.Emit (OpCodes.Conv_Ovf_I1);
            | "--.i4.s.i1"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf);     _ilg.Emit (OpCodes.Conv_Ovf_I1);
            | "++.i4.u.i1"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf_Un);  _ilg.Emit (OpCodes.Conv_Ovf_I1_Un);
            | "--.i4.u.i1"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf_Un);  _ilg.Emit (OpCodes.Conv_Ovf_I1_Un);
            | "++.i4.s.i2"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf);     _ilg.Emit (OpCodes.Conv_Ovf_I2);
            | "--.i4.s.i2"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf);     _ilg.Emit (OpCodes.Conv_Ovf_I2);
            | "++.i4.u.i2"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf_Un);  _ilg.Emit (OpCodes.Conv_Ovf_I2_Un);
            | "--.i4.u.i2"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf_Un);  _ilg.Emit (OpCodes.Conv_Ovf_I2_Un);
            | "++.i8.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Add);
            | "--.i8.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Sub);
            | "++.i8.s"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Add_Ovf);
            | "--.i8.s"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Sub_Ovf);
            | "++.i8.u"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Add_Ovf_Un);
            | "--.i8.u"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Sub_Ovf_Un);
            | "++.r4.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_R4);     _ilg.Emit (OpCodes.Add);
            | "--.r4.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_R4);     _ilg.Emit (OpCodes.Sub);
            | "++.r8.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_R8);     _ilg.Emit (OpCodes.Add);
            | "--.r8.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_R8);     _ilg.Emit (OpCodes.Sub);
            | "++.p" with inc = true
            | "--.p" with inc = false     =>
              match (parms)
              {
                | [par] when par.expr.Type.IsPointer with type = par.expr.Type =>
                  emit_index_multiplier(type);
                  _ilg.Emit(OpCodes.Conv_I);

                  if (inc)
                    _ilg.Emit(OpCodes.Add);
                  else
                    _ilg.Emit(OpCodes.Sub);

                | _ => Util.ice (_method_name + ": incorrect args for TExpr.Opcode (" + opcode + ")")
              }

            | "unary.~.f"                 =>
              def exprType = parms.Head.expr.FixedType();
              when (exprType.Equals(InternalType.Single) ||
                    exprType.Equals(InternalType.Double) ||
                    exprType.Equals(InternalType.Decimal))
                Util.ice ("float, double or decimal as an argument for binary negation in CGIL");
              _ilg.Emit (OpCodes.Not);

            | "*.s"                       => _ilg.Emit (OpCodes.Mul_Ovf)
            | "*.u"                       => _ilg.Emit (OpCodes.Mul_Ovf_Un)
            | "*.f"                       => _ilg.Emit (OpCodes.Mul)
            | "/.s" | "/.f"               => _ilg.Emit (OpCodes.Div)
            | "/.u"                       => _ilg.Emit (OpCodes.Div_Un)
            | "%.s" | "%.f"               => _ilg.Emit (OpCodes.Rem)
            | "%.u"                       => _ilg.Emit (OpCodes.Rem_Un)
            | "|.s" | "|.u" | "|.f" | "|" => _ilg.Emit (OpCodes.Or);
            | "&.s" | "&.u" | "&.f" | "&" => _ilg.Emit (OpCodes.And);
            | "^.s" | "^.u" | "^.f" | "^" => _ilg.Emit (OpCodes.Xor);
            | "bool.!"                    =>                            InversBool()
            | "==.ref" | "=="             => _ilg.Emit(OpCodes.Ceq);
            | "!=.ref" | "!="             => _ilg.Emit(OpCodes.Ceq);    InversBool();
            | "<.s" | "<.f"               => _ilg.Emit(OpCodes.Clt)
            | "<.u"                       => _ilg.Emit(OpCodes.Clt_Un)
            | ">.s" | ">.f"               => _ilg.Emit(OpCodes.Cgt)
            | ">.u"                       => _ilg.Emit(OpCodes.Cgt_Un)
            | "<=.s"                      => _ilg.Emit(OpCodes.Cgt);    InversBool();
            | "<=.f"                      => _ilg.Emit(OpCodes.Cgt_Un); InversBool();
            | "<=.u"                      => _ilg.Emit(OpCodes.Cgt_Un); InversBool();
            | ">=.s"                      => _ilg.Emit(OpCodes.Clt);    InversBool();
            | ">=.f"                      => _ilg.Emit(OpCodes.Clt_Un); InversBool();
            | ">=.u"                      => _ilg.Emit(OpCodes.Clt_Un); InversBool();
            | _                           => Util.ice (_method_name + ": unmatched TExpr.Opcode (" + opcode + ")")
          }

          when (expr.GenerateTail)
            _ilg.Emit (OpCodes.Ret);

        /* -- EXCEPTION HANDLING ------------------------------------------- */

        /* throw an exception */
        | Throw(null) => _ilg.Emit (OpCodes.Rethrow);
        | Throw(exc) =>
          emit(exc);
          _ilg.Emit(OpCodes.Throw);

        | TryFinally (try_expr, finally_expr) => // emit the try/with construction
          def type_of_try_expr = try_expr.ToTypeSig();

          def _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          def ignore_try_result = is_void (try_expr.Type);
          mutable try_result = null;

          unless (ignore_try_result)
          {
            try_result = _ilg.DeclareLocal (type_of_try_expr);
            unless (try_expr.Throws)
              emit_stloc(try_result)
          }

          _ilg.BeginFinallyBlock ();

          emit (finally_expr);

          _ilg.EndExceptionBlock ();

          unless (ignore_try_result)
            emit_ldloc(try_result);


        | Try(try_expr, try_cases) =>
          def type_of_try_expr = expr.ToTypeSig();

          def ignore_try_result = is_void(try_expr.Type);
          mutable try_result = null;

          unless (ignore_try_result)
            try_result = _ilg.DeclareLocal(type_of_try_expr);

          _ = _ilg.BeginExceptionBlock();

          emit(try_expr);

          unless (try_expr.Throws || ignore_try_result)
            emit_stloc(try_result);

          def walk_case(case)
          {
            | TryCase.Fault(catch_expr) =>
              _ilg.BeginFaultBlock();
              emit(catch_expr);

            | TryCase.Catch(catch_val, catch_expr) =>
              _ilg.BeginCatchBlock(catch_val.Type.ToTypeSig());

              def catch_val_local_slot = declare_val_local_slot(catch_val);
              emit_stloc(catch_val_local_slot);

              emit(catch_expr);

              unless (catch_expr.Throws || ignore_try_result)
                emit_stloc(try_result);

            | TryCase.Filter (catch_val, filter_expr, catch_expr) =>
              def label_badclass = _ilg.DefineLabel ();
              def label_endfilter = _ilg.DefineLabel ();

              // emit filter preamble
              _ilg.BeginExceptFilterBlock ();
              _ilg.Emit (OpCodes.Isinst, catch_val.Type.ToTypeSig());
              _ilg.Emit (OpCodes.Dup);
              _ilg.Emit (OpCodes.Brfalse, label_badclass);

              // emit filter block
              def catch_val_local_slot = declare_val_local_slot (catch_val);
              emit_stloc(catch_val_local_slot);
              emit (filter_expr);
              _ilg.Emit (OpCodes.Br, label_endfilter);

              // when bad class return 0
              _ilg.MarkLabel (label_badclass);
              _ilg.Emit (OpCodes.Pop);
              _ilg.Emit (OpCodes.Ldc_I4_0);

              // mark end of filter
              _ilg.MarkLabel (label_endfilter);

              // emit catch block
              _ilg.BeginCatchBlock (null);
              _ilg.Emit (OpCodes.Pop); // ignore value on stack, it's already local
              emit (catch_expr);

              unless (catch_expr.Throws || ignore_try_result)
                emit_stloc(try_result);
          }

          foreach (try_case in try_cases)
            walk_case(try_case);

          _ilg.EndExceptionBlock();

          unless (ignore_try_result)
            emit_ldloc(try_result);


        /* -- TUPLES -------------------------------------------------------- */
        | Tuple(vals) =>
          emit_exprs (vals);
          def ctor = InternalType.GetTupleType(vals.Length).Ctor;
          _ilg.Emit(OpCodes.Newobj, expr.FixedType().GetMethodInfo(ctor, []));


        | TupleIndexer(obj, pos, len) =>
          def tt = InternalType.GetTupleType (len);
          //when (tt.TyCon.IsValueType && !obj.NeedAddress)
          //  obj.NeedAddress = true;
          emit(obj);
          _ilg.Emit(OpCodes.Ldfld, obj.Type.GetFieldInfo(tt.GetField(pos + 1)));


        /* -- MISC --------------------------------------------------------- */

        /* loads the 'this' pointer on the evaluation stack */
        | This =>
          Util.cassert(!_method_builder.IsStatic, "This is a static method");
          _ilg.Emit(OpCodes.Ldarg_0);

          // when we are in value type, this contains address of current
          // value type - so if value is expected instead of address, we must
          // create a copy
          when (_this_is_value_type && !expr.NeedAddress)
            _ilg.Emit(OpCodes.Ldobj, expr.ToTypeSig());


        /* loads a literal on the evaluation stack */
        | Literal(literal) =>
          Util.cassert (literal != null);
          if (literal is Literal.Null)
            match (expr.FixedType()) {
              | StaticTypeVarRef
              | Class (tc,[_]) when tc.Equals (InternalType.Generic_Nullable_tc) =>
                emit (TExpr.DefaultValue (expr.Location, expr.Type))
              | _ => emit_literal (literal);
            }
          else if (literal is Literal.Void)
            () // do nothing
          else
            emit_literal(literal);

        /* loads address of given method */
        | MethodAddress(from, meth, is_virt, typarms) =>
          def methodRef = from.GetMethodInfo(meth, typarms);
          if (is_virt && (meth :> IBackendMethod).MethodDef.IsVirtual)
          {
            // ldvirtftn expects also an object reference
            // this is always part of delegate ctor, therefore
            // we can just dup the object reference
            _ilg.Emit(OpCodes.Dup);
            _ilg.Emit(OpCodes.Ldvirtftn, methodRef);
          }
          else
            _ilg.Emit(OpCodes.Ldftn, methodRef);

        | ImplicitValueTypeCtor => // creates object of value type using implicit ctor
          def local_slot = declare_expr_local_slot(expr);
          emit_ldloca(local_slot);
          _ilg.Emit(OpCodes.Initobj, expr.ToTypeSig());
          emit_ldloc(local_slot);

        | Array (initializers, [size]) => // creates a new array, given a list of initializers
          def element_type =
            match (expr.Type.Fix())
            {
              | FixedType.Array(t, _) => t.ToTypeSig()
              | _ => Util.ice()
            };
          emit(size);
          _ilg.Emit(OpCodes.Newarr, element_type);

          def need_empty_stack = initializers.Exists(_.NeedsEmptyStack);

          mutable local_array_var = null;
          mutable local_val_var = null;
          when (need_empty_stack)
          {
            local_array_var = declare_expr_local_slot(expr);
            local_val_var = _ilg.DeclareLocal(element_type);
            emit_stloc(local_array_var);
            emit_ldloc(local_array_var);
          }

          def load_elements(index : int, elements : list [TExpr])
          {
            match (elements)
            {
              | [] => ()
              | element :: rest =>
                if (element.NeedsEmptyStack)
                {
                  _ilg.Emit (OpCodes.Pop); // stack should be empty now

                  emit(element);
                  emit_stloc(local_val_var);

                  emit_ldloc(local_array_var);
                  _ilg.Emit(index);

                  when (element_type.IsValueType && !element_type.IsPrimitive)
                    _ilg.Emit(OpCodes.Ldelema, element_type);

                  emit_ldloc(local_val_var);
                  emit_array_store_opcode(element_type);
                  emit_ldloc(local_array_var); // restore stack layout for "normal" initializers
                }
                else
                {
                  _ilg.Emit(OpCodes.Dup);
                  _ilg.Emit(index);

                  when (element_type.IsValueType && !element_type.IsPrimitive)
                    _ilg.Emit(OpCodes.Ldelema, element_type);

                  emit(element);
                  emit_array_store_opcode(element_type);
                }
                load_elements(index + 1, rest)
            }
          }
          load_elements(0, initializers);

        | Array (initializers, dimensions) =>
          emit_exprs (dimensions);

          def arrayType = GetArrayTypeSpec(expr);
          _ilg.Emit (OpCodes.Newobj, arrayType.Ctor);

          unless (initializers.IsEmpty)
          {
            def dimensions_array = array (dimensions.Length);
            mutable i = 0;
            foreach (TExpr.Literal (Literal.Integer (it, _, _)) in dimensions)
            {
              dimensions_array [i] = it;
              ++i;
            }
            Util.cassert (i == dimensions_array.Length,
                          "dimensions must be literals when initializes are supplied");

            def need_empty_stack = initializers.Exists (_.NeedsEmptyStack);

            mutable local_array_var = null;
            mutable local_val_var = null;
            when (need_empty_stack) {
              local_array_var = declare_expr_local_slot(expr);
              local_val_var = _ilg.DeclareLocal (arrayType.TypeSig.Next);
              emit_stloc(local_array_var);
              emit_ldloc(local_array_var);
            }

            def load_elements (index : array [ulong], elements : list [TExpr]) {
              match (elements) {
                | [] => ()
                | element :: rest =>
                  if (element.NeedsEmptyStack) {
                    _ilg.Emit (OpCodes.Pop); // stack should be empty now

                    emit (element);
                    emit_stloc(local_val_var);

                    emit_ldloc(local_array_var);
                    _ilg.Emit (OpCodes.Dup);

                    for (mutable j = 0; j < index.Length; ++j)
                      emit_literal (Literal.Integer ((index [j] :> int) :> ulong, false, InternalType.Int32));

                    emit_ldloc(local_val_var);
                  } else {
                    _ilg.Emit (OpCodes.Dup);
                    for (mutable j = 0; j < index.Length; ++j)
                      emit_literal (Literal.Integer ((index [j] :> int) :> ulong, false, InternalType.Int32));
                    emit (element);
                  }
                  def next (index : array [ulong])
                  {
                    ++index [index.Length - 1];
                    for (mutable j = index.Length - 1; index [j] == dimensions_array [j] && j > 0; --j)
                    {
                      index [j] = 0;
                      ++index [j - 1];
                    }
                    index
                  }
                  emit_method_call (expr, true, arrayType.Set);
                  load_elements (next (index), rest)
              }
            }
            load_elements (array (dimensions_array.Length), initializers);
          }

        | _               => Message.Warning($"FIXME: unmatched: $expr");
      }

      EmitDebugLocation(pSeq?.ClosingBracket);
      
      log(EMIT, "} emit");
    }

    private GetDecimalCtor(signature : string) : IMethod
    {
      if (InternalType.Decimal_ctors.Get(signature) is Some(ctor))
        ctor
      else
      {
        def keys = InternalType.Decimal_ctors.Keys.ConvertToArray(t => $"'$t'");
        Util.ice($"Decimal constructor '$signature' not found, known are: ..$(keys)")
      }
    }

    /*
     * Emit all expressions and push them onto the stack.
     * Take care when some expressions need an empty stack.
     */
    private emit_exprs (exprs : list[TExpr]) : void
    {
      def vars = emit_exprs_prepare (exprs);
      emit_exprs_push (vars, exprs);
    }

    /*
     * Emit all expressions up to the last which needs an empty stack and
     * return the local variables where the result is stored.
     */
    private emit_exprs_prepare (exprs : list[TExpr]) : array[Local]
    {
      def exprs_array = exprs.ToArray ();
      def len = exprs.Length;

      mutable needed_local_variables = 0;
      foreach (i in [0 .. len - 1]) {
        when (exprs_array[i].NeedsEmptyStack)
          needed_local_variables = i + 1;
      }

      def local_variables = array (needed_local_variables);

      foreach (i in [0 .. needed_local_variables - 1]) {
        def expr = exprs_array[i];
        def var_type =
          if (expr.NeedAddress)
            make_ref_type (expr.ToTypeSig())
          else
            expr.ToTypeSig();
        local_variables[i] = _ilg.DeclareLocal (var_type);
        emit (expr);
        emit_stloc(local_variables[i]);
      }

      local_variables
    }

    /*
     * Push the local variables and emit all expressions with a higher index
     * than the array length
     */
    private emit_exprs_push (local_variables : array[Local], exprs : list[TExpr]) : void {
      foreach (var in local_variables)
        emit_ldloc(var);

      mutable i = 0;
      foreach (e in exprs) {
        when (i >= local_variables.Length) {
          emit (e);
        }
        i++;
      }
    }

    private GetArrayTypeSpec(arr : TExpr) : ArrayTypeSpec
    {
      GetArrayTypeSpec(arr.ToTypeSig())
    }

    private GetArrayTypeSpec(t : DN.TypeSig) : ArrayTypeSpec
    {
      | t is DN.ArraySig => SystemTypeCache.GetArrayTypeSpec(t.Next, t.Rank :> int)
      | _ => Util.ice($"expected array signature got $t")
    }

    /*
     * Emits a local reference instruction
     */
    private emit_ce_ref (decl : LocalValue, get_address_for_value_types : bool) : void
    {
      if (decl.IsParm) {
        if (get_address_for_value_types && ! decl.IsByRefParm)
          emit_ldarga (decl.Parameter)
        else {
          emit_ldarg (decl.Parameter);
          when (! get_address_for_value_types && decl.IsByRefParm) {
            def ty = decl.Type.ToTypeSig();
            if (ty.IsGenericParameter || ty.IsValueType)
               emit_ldind_for_value_type (ty)
            else
              _ilg.Emit (OpCodes.Ldind_Ref);
          }
        }
      } else {
        if (get_address_for_value_types && !decl.IsManagedPtr)
          emit_ldloca(decl.LocalSlot)
        else
          emit_ldloc(decl.LocalSlot)
      }
    }

    /**
     * Emits the TExpr.Switch instruction
     *
     * Asserts that the first of the case indices is zero. Quietly
     * asserts that the indexer is verified to be in a valid range -- i.e.
     * that the rescaling substraction does not overflow and that we never
     * generate too long switch instructions -- assuring this should belong
     * to a higher level logic.
     */
    private emit_switch (default_expr : option [TExpr],
                         cases : list [int * TExpr]) : void
    {
      def label_default = _ilg.DefineLabel ();
      def label_next_instruction = _ilg.DefineLabel ();

      // step zero: calculate the default jump target
      def default_jump_target =
        match (default_expr)
        {
          | Some => label_default
          | None => label_next_instruction
        };

      // step one: sort the cases increasingly
      def compare_cases (l : int * TExpr, r : int * TExpr) : int
      {
        Pair.First (l).CompareTo (r [0])
      }

      def cases = cases.Sort(compare_cases);
      Util.cassert (cases.Head [0] == 0);

      // step three: generate the jump labels for the switch cases
      mutable reversed_labels = [];

      def make_labels (index : int, cases : list [int * TExpr]) : list [Label * TExpr]
      {
        Util.cassert (index >= 0);
        match (cases) {
          | (case_index, case_expr) :: rest =>
            Util.cassert (index <= case_index);

            // insert jumps to the default expression where appropriate
            if (case_index == index) {
              def case_label = _ilg.DefineLabel ();
              reversed_labels = case_label :: reversed_labels;

              (case_label, case_expr) :: make_labels (index + 1, rest)
            }
            else {
              reversed_labels = default_jump_target :: reversed_labels;
              make_labels (index + 1, cases)
            }
          | [] => []
        }
      }

      def labeled_cases = make_labels (0, cases);
      def labels_array = reversed_labels.ToArray ();
      System.Array.Reverse (labels_array);

      // step four: emit the switch instruction and the default expression
      _ilg.Emit (OpCodes.Switch, labels_array);
      _ilg.MarkLabel (label_default);

      // emit the default expression (if none present jump to the next instruction)
      match (default_expr)
      {
        | Some (default_expr) =>
          emit (default_expr);
          unless (default_expr.Throws)
            _ilg.Emit (OpCodes.Br, label_next_instruction);
        | None =>
          _ilg.Emit (OpCodes.Br, label_next_instruction);
      }

      // step five: emit the switch cases
      def walk_cases (cases : list [Label * TExpr]) : void
      {
        | (label, expr) :: rest =>
          _ilg.MarkLabel (label);
          emit (expr);
          unless (expr.Throws)
            _ilg.Emit (OpCodes.Br, label_next_instruction);
          walk_cases (rest)
        | [] => ()
      }

      walk_cases (labeled_cases);

      // step six: mark the next instruction after the switch
      _ilg.MarkLabel (label_next_instruction);
    }

    private emit_stloc(local : DN.Emit.Local) : void
    {
      match (local.Index)
      {
        | 0 => _ilg.Emit(OpCodes.Stloc_0)
        | 1 => _ilg.Emit(OpCodes.Stloc_1)
        | 2 => _ilg.Emit(OpCodes.Stloc_2)
        | 3 => _ilg.Emit(OpCodes.Stloc_3)
        | n when n <= 255 => _ilg.Emit(OpCodes.Stloc_S, local)
        | _ => _ilg.Emit(OpCodes.Stloc, local)
      }
    }

    private emit_ldloc(local : DN.Emit.Local) : void
    {
      match (local.Index)
      {
        | 0 => _ilg.Emit(OpCodes.Ldloc_0)
        | 1 => _ilg.Emit(OpCodes.Ldloc_1)
        | 2 => _ilg.Emit(OpCodes.Ldloc_2)
        | 3 => _ilg.Emit(OpCodes.Ldloc_3)
        | n when n <= 255 => _ilg.Emit(OpCodes.Ldloc_S, local)
        | _ => _ilg.Emit(OpCodes.Ldloc, local)
      }
    }

    private emit_ldloca(local : DN.Emit.Local) : void
    {
      _ilg.Emit(if (local.Index < 256) OpCodes.Ldloca_S else OpCodes.Ldloca, local)
    }

    /**
     * Emits an LDARG instruction
     */
    private emit_ldarg (p : DN.Parameter) : void
    {
      match (p.Index)
      {
        | 0 => _ilg.Emit (OpCodes.Ldarg_0)
        | 1 => _ilg.Emit (OpCodes.Ldarg_1)
        | 2 => _ilg.Emit (OpCodes.Ldarg_2)
        | 3 => _ilg.Emit (OpCodes.Ldarg_3)
        | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, p)
        | _ => _ilg.Emit (OpCodes.Ldarg, p)
      }
    }

    private store_argument (p : DN.Parameter) : void
    {
      _ilg.Emit (if (p.Index < 256) OpCodes.Starg_S else OpCodes.Starg, p)
    }

    /**
     * Emits an LDARGA instruction
     */
    private emit_ldarga (p : DN.Parameter) : void
    {
      _ilg.Emit (if (p.Index < 256) OpCodes.Ldarga_S else OpCodes.Ldarga, p)
    }

    /**
     * Performs value type conversion form l to r
     */
    private emit_value_type_conversion (loc : Location,
                                        l_t : FixedType, r_t : FixedType,
                                        is_checked : bool) : void
    {
      def fail()
      {
        Message.Warning (loc, $"failed to emit value type conversion from $l_t to $r_t")
      }

      unless (l_t.Equals (r_t))
      {
        mutable lt = l_t.TypeInfo;
        when (lt.IsEnum) lt = lt.UnderlyingType.TypeInfo;
        mutable rt = r_t.TypeInfo;
        when (rt.IsEnum) rt = rt.UnderlyingType.TypeInfo;

        match (rt, lt)
        {
          | (rt is ExternalPrimitiveTypeInfo, lt is ExternalPrimitiveTypeInfo)
            when lt.CanOmmitConversionTo(rt)
              => ()

          | (rt is ExternalPrimitiveTypeInfo, lt) =>
            def is_unsigned_l =
              match (lt.Name [0])
              {
                // UInt32, UInt64, UInt16
                | 'U'
                // Byte
                | 'B'
                // Char
                | 'C'   => true
                | _ => false
              }

            def rname = rt.Name;
            def opcode =
              match (rname)
              {
                | "Single" when is_unsigned_l => OpCodes.Conv_R_Un
                | "Single"                    => OpCodes.Conv_R4
                | "Double" when is_unsigned_l => _ilg.Emit (OpCodes.Conv_R_Un); OpCodes.Conv_R8
                | "Double"                    => OpCodes.Conv_R8
                | _ =>
                  if (is_checked)
                    match (rname)
                    {
                      | "Int64" when is_unsigned_l   => OpCodes.Conv_Ovf_I8_Un
                      | "Int64"                      => OpCodes.Conv_Ovf_I8
                      | "Int32" when is_unsigned_l   => OpCodes.Conv_Ovf_I4_Un
                      | "Int32"                      => OpCodes.Conv_Ovf_I4
                      | "Int16" when is_unsigned_l   => OpCodes.Conv_Ovf_I2_Un
                      | "Int16"                      => OpCodes.Conv_Ovf_I2
                      | "SByte" when is_unsigned_l   => OpCodes.Conv_Ovf_I1_Un
                      | "SByte"                      => OpCodes.Conv_Ovf_I1
                      | "UInt64" when is_unsigned_l  => OpCodes.Conv_Ovf_U8_Un
                      | "UInt64"                     => OpCodes.Conv_Ovf_U8
                      | "UInt32" when is_unsigned_l  => OpCodes.Conv_Ovf_U4_Un
                      | "UInt32"                     => OpCodes.Conv_Ovf_U4
                      | "UInt16" when is_unsigned_l  => OpCodes.Conv_Ovf_U2_Un
                      | "UInt16"                     => OpCodes.Conv_Ovf_U2
                      | "Boolean" when is_unsigned_l => OpCodes.Conv_Ovf_U1_Un
                      | "Boolean"                    => OpCodes.Conv_Ovf_U1
                      | "Byte" when is_unsigned_l    => OpCodes.Conv_Ovf_U1_Un
                      | "Byte"                       => OpCodes.Conv_Ovf_U1
                      | "Char" when is_unsigned_l    => OpCodes.Conv_Ovf_U2_Un
                      | "Char"                       => OpCodes.Conv_Ovf_U2

                      | _ => fail (); OpCodes.Nop
                    }
                  else match (rname)
                  {
                    | "Int64" when is_unsigned_l => OpCodes.Conv_U8
                    | "Int64"   => OpCodes.Conv_I8
                    | "Int32"   => OpCodes.Conv_I4
                    | "Int16"   => OpCodes.Conv_I2
                    | "SByte"   => OpCodes.Conv_I1
                    | "UInt64" when !is_unsigned_l => OpCodes.Conv_I8
                    | "UInt64"  => OpCodes.Conv_U8
                    | "UInt32"  => OpCodes.Conv_U4
                    | "UInt16"  => OpCodes.Conv_U2
                    | "Byte"    => OpCodes.Conv_U1
                    | "Boolean" => OpCodes.Conv_U1
                    | "Char"    => OpCodes.Conv_U2
                    | _         => fail (); OpCodes.Nop
                  }
              };

            _ilg.Emit (opcode)

          | _ when rt.Equals(InternalType.Decimal_tc) =>
            def lname = lt.Name;
            match (lname)
            {
              | "Int32" | "UInt32" | "Single" | "Int64" | "UInt64" | "Double" =>
                _ilg.Emit (OpCodes.Newobj, GetDecimalCtor(lname))

              | _ => fail ()
            }

          | _ => fail ()
        }
      }
    }


    /**
     * Emits a method call.
     *
     * If it is a tail call (which is checked based on [expr]), then we emit
     * tail modifier.
     */
    private emit_method_call (expr : TExpr,
                              base_is_value_type_or_static : bool,
                              method : DN.IMethod,
                              imethod : IMethod = null,
                              from : FixedType = null) : void
    {
      // Message.Debug ($"emc: $(method.Name)");
      when (expr.GenerateTail)
        _ilg.Emit (OpCodes.Tailcall);

      if (base_is_value_type_or_static)
      {
        _ilg.Emit (OpCodes.Call, method);
      }
      else if (method.DeclaringType.Name == "Array" && method.DeclaringType.Namespace == "System" && method.Name == "get_Length")
      {
        _ilg.Emit(OpCodes.Ldlen);
        _ilg.Emit(OpCodes.Conv_I4);
      }
      else
      {
        _ilg.Emit (OpCodes.Callvirt, method);
      }

      when (imethod != null)
        emit_tuple_function_conversion (expr.FixedType(), from, imethod);

      when (expr.GenerateTail)
        _ilg.Emit (OpCodes.Ret);
    }

    /* Emits code of given expression and converts its value to adress
       (if it is a value type) or leave it as reference (non value type).
       This is needed in various places, where we need a real reference
       (address in case of value types) to access its methods or fields.

       Returns value indicating if base_object was really a value type
    */
    private emit_and_convert_to_address (base_object : TExpr) : bool
    {
      emit (base_object);
      def stype = base_object.ToTypeSig();
      def is_value_type = stype.IsValueType;

      // we must allocate additional temporary variable if during
      // emit(base_object) address was not granted
      when ((is_value_type || stype.IsGenericParameter) && !base_object.NeedAddress)
      {
        def local_slot = _ilg.DeclareLocal(stype);
        emit_stloc(local_slot);
        emit_ldloca(local_slot);
      }
      // is_value_type is checked to decide in call vs callvirt emission
      is_value_type
    }


    /**
     * Declares a local variable
     */
    private declare_val_local_slot (val : LocalValue) : Local
    {
      def ty =
        if (val.IsManagedPtr)
          make_ref_type(val.Type.ToTypeSig())
        else val.Type.ToTypeSig();

      def local_slot =
        if (IsDebugEnabled)
          _ilg.DeclareLocal(ty, val.IsPinned, val.Name, val.Location.IsSourceAvailable)
        else
          _ilg.DeclareLocal(ty, val.IsPinned);

      val.LocalSlot = local_slot;
      local_slot
    }

    private declare_val_local_slot_ex (val : LocalValue) : void
    {
      if (val.PostponedDeclaration && IsDebugEnabled && val.Location.IsSourceAvailable)
        val.Declare = fun() { _ = declare_val_local_slot (val) };
      else
        _ = declare_val_local_slot (val)
    }

    private declare_expr_local_slot(expr : TExpr) : Local
    {
      def ty =
        if(expr.NeedAddress && expr.IsAddressable)
          make_ref_type(expr.ToTypeSig())
        else
          expr.ToTypeSig();
      _ilg.DeclareLocal(ty)
    }

    /**
     * Emits a STELEM instruction for a given type
     *
     * NOTE: there is no Stelem_U* opcodes.
     */
    private emit_array_store_opcode (ty : DN.TypeSig) : void
    {
      if (ty.IsGenericParameter) _ilg.Emit (OpCodes.Stelem, ty)
      else if (ty.IsPrimitive)
      {
        def (opcode, _ , _) = _primitiveTypeArrayOpcodes[(ty :> DN.TypeDefOrRefSig).TypeDefOrRef.Name];
        _ilg.Emit(opcode);
      }
      else if (ty.IsValueType) _ilg.Emit (OpCodes.Stobj, ty)
      else _ilg.Emit (OpCodes.Stelem_Ref);
    }

    private emit_value_to_ptr_conversion(expr : TExpr, target_type : TypeVar) : void
    {
      def type = expr.Type.Fix();

      match (type)
      {
        | Class(_, []) when type.Equals(InternalType.IntPtr) =>
          emit(expr);

        | Class(_, []) when type.Equals(InternalType.String) =>
          _ = target_type; // TODO: Add check!

          emit(expr);

          def label = _ilg.DefineLabel();

          _ilg.Emit(OpCodes.Conv_I);
          _ilg.Emit(OpCodes.Dup);
          _ilg.Emit(OpCodes.Brfalse_S, label);
          _ilg.Emit(OpCodes.Call, InternalType.RuntimeHelpers_get_OffsetToStringData);
          _ilg.Emit(OpCodes.Add);

          _ilg.MarkLabel(label);

        | FixedType.Array(t, 1) =>
          emit(expr);
          _ilg.Emit(OpCodes.Ldc_I4_0);
          _ilg.Emit(OpCodes.Ldelema, t.ToTypeSig());
          _ilg.Emit(OpCodes.Conv_I);

        | _ => assert(false, "Unsupported pointer convertion.");
      }
    }

    private static get_elem_size(ptr_type : TypeVar) : int
    {
      match (ptr_type.Fix())
      {
        | FixedType.Class(ti, [element]) when ti.IsPointer =>
          def size = element.Fix().TypeInfo.Size;
          assert(size > 0);
          size

        | _ => assert(false)
      }
    }

    private emit_index_multiplier(ptr_type : TypeVar) : void
    {
      emit_index_multiplier(get_elem_size(ptr_type))
    }

    private emit_index_multiplier(size : int) : void
    {
      | 8  => ()
      | 16 => _ilg.Emit(OpCodes.Ldc_I4_2);
      | 32 => _ilg.Emit(OpCodes.Ldc_I4_4);
      | 64 => _ilg.Emit(OpCodes.Ldc_I4_8);
      | _  => assert(false);
    }

    private emit_ptr_indexing(needAddress : bool, ptr : TExpr, index : TExpr) : void
    {
      def type = ptr.Type;

      assert(type.IsPointer);
      emit(ptr);

      def size = get_elem_size(type);

      match (index)
      {
        | TExpr.Literal(Literal.Integer(0, _, _)) => ()
        | TExpr.Literal(Literal.Integer(val, is_negative, _treat_as)) =>
          def byteOffset = (size / 8) * (val :> int) * if (is_negative) -1 else 1;

          _ilg.Emit(OpCodes.Conv_I);
          _ilg.Emit(byteOffset);
          _ilg.Emit(OpCodes.Add);

        | _ =>
          emit(index);
          _ilg.Emit(OpCodes.Conv_I);
          emit_index_multiplier(size);

          when (size > 8)
            _ilg.Emit(OpCodes.Mul);

          _ilg.Emit(OpCodes.Add);
      }

      unless (needAddress)
        match (size)
        {
          | 8  => _ilg.Emit(OpCodes.Ldind_U1);
          | 16 => _ilg.Emit(OpCodes.Ldind_U2);
          | 32 => _ilg.Emit(OpCodes.Ldind_U4);
          | 64 => _ilg.Emit(OpCodes.Ldind_I8);
          | _  => assert(false);
        }
    }

    /**
     * Emits a LDELEM instruction for a given type
     */
    private emit_array_load_opcode (ty : DN.TypeSig) : void
    {
      if (ty.IsGenericParameter)
        _ilg.Emit (OpCodes.Ldelem, ty)
      else if (ty.IsValueType && !ty.IsPrimitive)
      {
        _ilg.Emit (OpCodes.Ldelema, ty);
        _ilg.Emit (OpCodes.Ldobj, ty);
      }
      else if (ty.IsPrimitive)
      {
        def (_, opcode, _) = _primitiveTypeArrayOpcodes[(ty :> DN.TypeDefOrRefSig).TypeDefOrRef.Name];
        _ilg.Emit(opcode)
      }
      else
        _ilg.Emit(OpCodes.Ldelem_Ref)
    }


    /**
     * Emits a LDIND instruction for a given value type
     */
    private emit_ldind_for_value_type (ty : DN.TypeSig) : void
    {
      if (!ty.IsPrimitive)
        _ilg.Emit (OpCodes.Ldobj, ty)
      else
      {
        def (_, _ , opcode) = _primitiveTypeArrayOpcodes[(ty :> DN.TypeDefOrRefSig).TypeDefOrRef.Name];
        _ilg.Emit (opcode)
      }
    }

    /// Emits a literal
    private emit_literal (l : Literal) : void
    {
      match (l) {
        | Literal.Void         => ()
        | Literal.Null         => _ilg.Emit (OpCodes.Ldnull)
        | Literal.Bool (flag)  => _ilg.Emit (flag)
        | Literal.Char (k)     => _ilg.Emit (k :> int)

        | Literal.Integer (k, is_neg, t) =>
          assert(t != null);
          if (t.Equals (InternalType.UInt64)) {
            assert(!is_neg);
            unchecked (_ilg.Emit (OpCodes.Ldc_I8, k :> long));
            // i don't think this is needed here
            _ilg.Emit (OpCodes.Conv_U8)
          } else if (t.Equals (InternalType.Int64)) {
            if (is_neg)
              if (k == 0x8000000000000000UL)
                _ilg.Emit (OpCodes.Ldc_I8, System.Int64.MinValue);
              else
                _ilg.Emit (OpCodes.Ldc_I8, - (k :> long));
            else
              unchecked (_ilg.Emit (OpCodes.Ldc_I8, k :> long));
          } else if (t.Equals (InternalType.UInt32)) {
            assert(!is_neg);
            _ilg.Emit (unchecked (k :> int))
          } else
            if (k <= System.Int32.MaxValue :> ulong)
              _ilg.Emit (if (is_neg) - (k :> int) else (k :> int))
            else if (k == (- (System.Int32.MinValue : long)) :> ulong && is_neg)
              _ilg.Emit (System.Int32.MinValue)
            else {
              Message.Warning ($ "cannot emit: $l : $t");
              assert(false)
            }

        | Literal.String (s)   =>
          assert(s != null); _ilg.Emit (OpCodes.Ldstr, s)

        | Literal.Float (f)    => _ilg.Emit (OpCodes.Ldc_R4, f)
        | Literal.Double (f)   => _ilg.Emit (OpCodes.Ldc_R8, f)
        | Literal.Decimal (m)  =>
          def decimal_bits = System.Decimal.GetBits (m);

          def sign = decimal_bits[3] < 0;
          def scale = (decimal_bits[3] >> 16) & 0x00FF;

          if(decimal_bits[2] != 0 || (decimal_bits[1] < 0 && sign) || scale != 0) {
            // constant is too huge to fit in 32 or 64 bit integer

            _ilg.Emit(decimal_bits[0]);
            _ilg.Emit(decimal_bits[1]);
            _ilg.Emit(decimal_bits[2]);
            _ilg.Emit(sign);
            _ilg.Emit(scale);

            _ilg.Emit (OpCodes.Newobj, GetDecimalCtor("Int32, Int32, Int32, Boolean, Byte"));

          } else if(decimal_bits[1] != 0 || (decimal_bits[0] < 0 && sign)) {
            // constant fits into 64 bit integer

            def val : long = unchecked( (((decimal_bits[1] :> ulong) << 32) %| (decimal_bits[0] :> ulong)) :> long );
            if(sign) {
              assert(val >= 0L);
              def val : long = unchecked( (val :> ulong %| 0x800000000000000UL) :> long );
              _ilg.Emit (OpCodes.Ldc_I8, val);
              _ilg.Emit (OpCodes.Newobj, GetDecimalCtor("Int64"));
            } else {
              _ilg.Emit (OpCodes.Ldc_I8, val);
              _ilg.Emit (OpCodes.Newobj, GetDecimalCtor("UInt64"));
            }

          } else {
            // constant fits into 32 bit integer

            def val : int = decimal_bits[0];
            if(sign) {
              assert(val >= 0);
              def val : int = unchecked( (val :> uint %| 0x80000000U) :> int );
              _ilg.Emit (val);
              _ilg.Emit (OpCodes.Newobj, GetDecimalCtor("Int32"));
            } else {
              _ilg.Emit (val);
              _ilg.Emit (OpCodes.Newobj, GetDecimalCtor("UInt32"));
            }
          }

        | Literal.Enum (l, _, _) => emit_literal (l)
      }
    }

    class Label
    {
      public mutable TargetIndex      : ValueOption[int];
      public mutable ResolveCallbacks : list[Instruction -> void] = [];
    }

    class ExceptionLabels
    {
      public this(ilg : NemerleGenerator)
      {
        TryStart = ilg.DefineLabel();
        TryEnd   = ilg.DefineLabel();
        Exit     = ilg.DefineLabel();
      }

      public         TryStart : Label;
      public         TryEnd   : Label;
      public         Exit     : Label;
      public mutable Handler  : ExceptionHandler;

      private mutable _currentEnd : Label;

      public CurrentEnd : Label { get { _currentEnd ?? TryEnd } set { _currentEnd = value } }
    }

    class NemerleGenerator
    {
      private _il                          : SCG.List[Instruction]      = SCG.List();
      private _exceptions                  : SCG.List[ExceptionHandler] = SCG.List();
      private _locals                      : SCG.List[Local]            = SCG.List();
      private _jumpedLabels                : SCG.HashSet[Label]         = SCG.HashSet();
      private _markedLabels                : SCG.Queue[Label]           = SCG.Queue();
      private _exceptionLabels             : SCG.Stack[ExceptionLabels] = SCG.Stack();
      private _pdbScopes                   : SCG.Stack[DN.Pdb.PdbScope] = SCG.Stack();
      private _sequencePoints              : SCG.Queue[SequencePoint]   = SCG.Queue();
      private mutable _controlLeaved       : bool;
      private mutable _opcodeLeavesControl : bool;

      public this()
      {
        _pdbScopes.Push(PdbScope());
      }

      public CreateBody() : CilBody
      {
        def body = CilBody(true, _il, _exceptions, _locals);

        when (_il.Count > 0)
        {
          def rootScope = _pdbScopes.Peek();
          rootScope.Start = _il[0];

          def pdbMethod = PdbMethod();
          pdbMethod.Scope = rootScope;

          body.PdbMethod = pdbMethod;
        }
        body
      }

      public BeginExceptionBlock() : void
      {
        def labels = ExceptionLabels(this);
        _exceptionLabels.Push(labels);
        MarkLabel(labels.TryStart);
      }

      public BeginCatchBlock(exceptionType : DN.TypeSig) : void
      {
        def labels = _exceptionLabels.Peek();
        if (exceptionType == null)
        {
          def handler = labels.Handler;
          Util.cassert(handler != null && handler.HandlerType == ExceptionHandlerType.Filter);

          Emit(OpCodes.Endfilter);

          def handlerStart = DefineLabel();
          ResolveLabel(handlerStart, fun(target) { handler.HandlerStart = target });
          MarkLabel(handlerStart, true);
        }
        else
        {
          CloseCurrentExceptionBlock(labels);

          def handler = ExceptionHandler(ExceptionHandlerType.Catch);
          handler.CatchType = DN.Extensions.ToTypeDefOrRef(exceptionType);
          ResolveLabel(labels.TryStart,   fun(target) { handler.TryStart     = target });
          ResolveLabel(labels.TryEnd,     fun(target) { handler.TryEnd       = target });
          ResolveLabel(labels.CurrentEnd, fun(target) { handler.HandlerStart = target });
          labels.CurrentEnd = DefineLabel();
          ResolveLabel(labels.CurrentEnd, fun(target) { handler.HandlerEnd   = target });

          AddExceptionHandler(labels, handler);
        }
      }

      public BeginExceptFilterBlock() : void
      {
        def labels = EnterExceptionBlock();

        def handler = ExceptionHandler(ExceptionHandlerType.Filter);
        ResolveLabel(labels.TryStart,   fun(target) { handler.TryStart    = target });
        ResolveLabel(labels.TryEnd,     fun(target) { handler.TryEnd      = target });
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.FilterStart = target });
        labels.CurrentEnd = DefineLabel();
        ResolveLabel(labels.CurrentEnd,  fun(target) { handler.HandlerEnd = target });

        AddExceptionHandler(labels, handler);
      }

      public BeginFaultBlock() : void
      {
        def labels = EnterExceptionBlock();

        def handler = ExceptionHandler(ExceptionHandlerType.Fault);
        ResolveLabel(labels.TryStart,   fun(target) { handler.TryStart     = target });
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.TryEnd       = target;
                                                      handler.HandlerStart = target });
        labels.CurrentEnd = DefineLabel();
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.HandlerEnd   = target });

        AddExceptionHandler(labels, handler);
      }

      public BeginFinallyBlock() : void
      {
        def labels = EnterExceptionBlock();

        def handler = ExceptionHandler(ExceptionHandlerType.Finally);
        ResolveLabel(labels.TryStart,   fun(target) { handler.TryStart     = target });
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.TryEnd       = target;
                                                      handler.HandlerStart = target });
        labels.CurrentEnd = DefineLabel();
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.HandlerEnd   = target });

        AddExceptionHandler(labels, handler);
      }

      public EndExceptionBlock() : void
      {
        def labels = _exceptionLabels.Pop();
        CloseCurrentExceptionBlock(labels);
        MarkLabel(labels.Exit, true);
      }

      public BeginScope() : void
      {
        def newScope = PdbScope();
        _pdbScopes.Push(newScope);

        def label = DefineLabel();
        MarkLabel(label);
        ResolveLabel(label, fun(target) { newScope.Start = target });
      }

      public EndScope() : void
      {
        def scope = _pdbScopes.Pop();
        when (scope.HasScopes || scope.HasVariables)
        {
          _pdbScopes.Peek().Scopes.Add(scope);
          def label = DefineLabel();
          MarkLabel(label);
          ResolveLabel(label, fun(target) { scope.End = target });
        }
      }

      public DeclareLocal(localType : DN.TypeSig, pinned : bool = false, pdbName : string = null, isPdbNameVisible : bool = false) : Local
      {
        def local = Local(if (pinned) DN.PinnedSig(localType) else localType, pdbName, _locals.Count);
        _locals.Add(local);
        when (pdbName : object != null)
        {
          def attributes = if (isPdbNameVisible) PdbLocalAttributes.None else PdbLocalAttributes.DebuggerHidden;
          _pdbScopes.Peek().Variables.Add(PdbLocal(local, pdbName, attributes));
        }
        local
      }

      public DefineLabel () : Label { _ = this; Label() }

      public Emit(flag   : bool)                           : void { Emit(if (flag) OpCodes.Ldc_I4_1 else OpCodes.Ldc_I4_0) }
      public Emit(number : int)                            : void { _ = Add(Instruction.CreateLdcI4(number)) }
      public Emit(opcode : OpCode)                         : void { _ = Add(opcode.ToInstruction())    }
      public Emit(opcode : OpCode, arg : int)              : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : long)             : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : float)            : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : double)           : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : string)           : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : DN.IMethod)       : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : DN.IField)        : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : DN.TypeSig)       : void { _ = Add(opcode.ToInstruction(DN.Extensions.ToTypeDefOrRef(arg))) }
      public Emit(opcode : OpCode, arg : DN.ITypeDefOrRef) : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : Local)            : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : DN.Parameter)     : void { _ = Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : IMethod)          : void { _ = Add(opcode.ToInstruction(arg.ToMethodRef())) }

      public Emit(opcode : OpCode, arg : Label)      : void
      {
        _ = _jumpedLabels.Add(arg);

        def instruction = opcode.ToInstruction(null : Instruction);
        def index       = Add(instruction);
        ResolveLabel(arg, fun(target)
        {
          instruction.Operand = target;

          def updateFollowingInstructionsOffsets()
          {
            mutable offset = instruction.Offset + instruction.GetSize() :> uint;
            for (mutable i = index + 1; i < _il.Count; ++i)
            {
              def next = _il[i];
              next.Offset = offset;
              offset += next.GetSize() :> uint;
            }
          }

          match (instruction.OpCode.Code)
          {
            | Code.Br when (index + 1 == arg.TargetIndex.GetValueOrDefault()) =>
              // replace Br to next instruction with Nop
              instruction.OpCode = OpCodes.Nop;
              instruction.Operand = null;
              updateFollowingInstructionsOffsets();

            | Code.Beq     with shortOpCode = OpCodes.Beq_S
            | Code.Bge     with shortOpCode = OpCodes.Bge_S
            | Code.Bge_Un  with shortOpCode = OpCodes.Bge_Un_S
            | Code.Bgt     with shortOpCode = OpCodes.Bgt_S
            | Code.Bgt_Un  with shortOpCode = OpCodes.Bgt_Un_S
            | Code.Ble     with shortOpCode = OpCodes.Ble_S
            | Code.Ble_Un  with shortOpCode = OpCodes.Ble_Un_S
            | Code.Blt     with shortOpCode = OpCodes.Blt_S
            | Code.Blt_Un  with shortOpCode = OpCodes.Blt_Un_S
            | Code.Bne_Un  with shortOpCode = OpCodes.Bne_Un_S
            | Code.Br      with shortOpCode = OpCodes.Br_S
            | Code.Brfalse with shortOpCode = OpCodes.Brfalse_S
            | Code.Brtrue  with shortOpCode = OpCodes.Brtrue_S
            | Code.Leave   with shortOpCode = OpCodes.Leave_S =>
              def offsetAfterInstruction =
                if (target.Offset >= instruction.Offset)
                {
                  // Target is >= this instruction so use the offset after
                  // current instruction
                  instruction.Offset :> int + instruction.GetSize()
                }
                else
                {
                  // Target is < this instruction so use the offset after
                  // the short instruction
                  instruction.Offset :> int + shortOpCode.Size + 1;
                };

              def distance = target.Offset :> int - offsetAfterInstruction;
              when (sbyte.MinValue <= distance && distance <= sbyte.MaxValue)
              {
                instruction.OpCode = shortOpCode;
                updateFollowingInstructionsOffsets();
              }

            | _ => ()
          }
        });
      }

      public Emit(opcode : OpCode, labels : array[Label]) : void
      {
        def jumpTable = array(labels.Length);
        _ = Add(opcode.ToInstruction(jumpTable));

        foreach (label in labels with index)
        {
          _ = _jumpedLabels.Add(label);
          def cachedIndex = index;
          ResolveLabel(label, fun(target) { jumpTable[cachedIndex] = target });
        }
      }

      public MarkLabel(label : Label, resetControlLeave : bool = false) : void
      {
        Util.cassert(label.TargetIndex.IsNone, "Label already marked");

        when (resetControlLeave || _jumpedLabels.Contains(label))
          _controlLeaved = false;

        _markedLabels.Enqueue(label);
      }

      public MarkSequencePoint(document : PdbDocument, startLine : int, startColumn : int, endLine : int, endColumn : int) : void
      {
        when (document != null)
        {
          def sequencePoint         = SequencePoint();
          sequencePoint.Document    = document;
          sequencePoint.StartLine   = startLine;
          sequencePoint.StartColumn = startColumn;
          sequencePoint.EndLine     = endLine;
          sequencePoint.EndColumn   = endColumn;
          _sequencePoints.Enqueue(sequencePoint);
        }
      }

      private ResolveLabel(label : Label, callback : Instruction -> void) : void
      {
        if (label.TargetIndex is VSome(index))
          callback(_il[index]);
        else
          label.ResolveCallbacks ::= callback;
      }

      private Add(instruction : Instruction) : int
      {
        def addInstruction(newInstruction) : int
        {
          def index = _il.Count;
          _il.Add(newInstruction);
          when (index > 0)
          {
            def prevInstruction = _il[index - 1];
            newInstruction.Offset = prevInstruction.Offset + prevInstruction.GetSize() :> uint;
          }
          index
        }

        mutable jumpIndex = _il.Count;

        while (_sequencePoints.Count > 1)
        {
          def sequencePoint = _sequencePoints.Dequeue();
          when (!_controlLeaved && sequencePoint.StartLine < 0xFEEFEE)
          {
            def nop = OpCodes.Nop.ToInstruction();
            nop.SequencePoint = sequencePoint;
            _ = addInstruction(nop);
          }
        }

        def actualIndex = addInstruction(instruction);

        when (_sequencePoints.Count > 0)
          instruction.SequencePoint = _sequencePoints.Dequeue();

        while (_markedLabels.Count > 0)
        {
          def label = _markedLabels.Dequeue();
          Util.cassert(label.TargetIndex.IsNone, "Label already marked");

          label.TargetIndex = VSome(jumpIndex);
          def target = _il[jumpIndex];
          foreach (callback in label.ResolveCallbacks)
            callback(target);
          label.ResolveCallbacks = null;
        }

        match (instruction.OpCode.Code)
        {
          | Throw | Rethrow | Br | Br_S | Leave | Leave_S | Ret =>
            _controlLeaved       = true;
            _opcodeLeavesControl = true;

          | _ => _opcodeLeavesControl = false;
        }

        actualIndex
      }

      private AddExceptionHandler(labels : ExceptionLabels, handler : ExceptionHandler) : void
      {
        labels.Handler = handler;
        _exceptions.Add(handler);
        _controlLeaved       = false;
        _opcodeLeavesControl = false;
      }

      private EnterExceptionBlock() : ExceptionLabels
      {
        def labels = _exceptionLabels.Peek();
        CloseCurrentExceptionBlock(labels);
        labels
      }

      private CloseCurrentExceptionBlock(labels : ExceptionLabels) : void
      {
        when (!_controlLeaved || !_opcodeLeavesControl)
        {
          def handler = labels.Handler;
          if (handler != null && (handler.HandlerType == ExceptionHandlerType.Finally || handler.HandlerType == ExceptionHandlerType.Fault))
            Emit(OpCodes.Endfinally);
          else
            Emit(OpCodes.Leave, labels.Exit);
        }
        MarkLabel(labels.CurrentEnd);
      }
    }
  } // end of the class
} // end of the namespace
