using Nemerle.IO;
using Nemerle.Collections;

using Nemerle.Compiler.Typedtree;

using DN = dnlib.DotNet;
using SRC = System.Runtime.CompilerServices;

namespace Nemerle.Compiler
{
  [ManagerAccess]
  public class InternalTypeClass
  {
    public mutable Void_tc                              : TypeInfo;
    public mutable Array_tc                             : TypeInfo;
    public mutable Attribute_tc                         : TypeInfo;
    public mutable Boolean_tc                           : TypeInfo;
    public mutable Byte_tc                              : TypeInfo;
    public mutable Char_tc                              : TypeInfo;
    public mutable Decimal_tc                           : TypeInfo;
    public mutable Delegate_tc                          : TypeInfo;
    public mutable MulticastDelegate_tc                 : TypeInfo;
    public mutable Double_tc                            : TypeInfo;
    public mutable Enum_tc                              : TypeInfo;
    public mutable Exception_tc                         : TypeInfo;
    public mutable Int16_tc                             : TypeInfo;
    public mutable Int32_tc                             : TypeInfo;
    public mutable Int64_tc                             : TypeInfo;
    public mutable IntPtr_tc                            : TypeInfo;
    public mutable Object_tc                            : TypeInfo;
    public mutable SByte_tc                             : TypeInfo;
    public mutable Single_tc                            : TypeInfo;
    public mutable String_tc                            : TypeInfo;
    public mutable Type_tc                              : TypeInfo;
    public mutable MethodInfo_tc                        : TypeInfo;
    public mutable ConstructorInfo_tc                   : TypeInfo;
    public mutable FieldInfo_tc                         : TypeInfo;
    public mutable PropertyInfo_tc                      : TypeInfo;
    public mutable UInt16_tc                            : TypeInfo;
    public mutable UInt32_tc                            : TypeInfo;
    public mutable UInt64_tc                            : TypeInfo;
    public mutable ValueType_tc                         : TypeInfo;
    public mutable MatchFailureException_tc             : TypeInfo;
    public mutable NullMatchException_tc                : TypeInfo;
    public mutable ContainsMacroAttribute_tc            : TypeInfo;
    public mutable VariantAttribute_tc                  : TypeInfo;
    public mutable ImmutableAttribute_tc                : TypeInfo;
    public mutable ExtensionAttribute_tc                : TypeInfo;
    public mutable TypeAliasAttribute_tc                : TypeInfo;
    public mutable VariantOptionAttribute_tc            : TypeInfo;
    public mutable VolatileModifier_tc                  : TypeInfo;
    public mutable ConstantVariantOptionAttribute_tc    : TypeInfo;
    public mutable ExtensionPatternEncodingAttribute_tc : TypeInfo;
    public mutable FlagsAttribute_tc                    : TypeInfo;
    public mutable ParamArrayAttribute_tc               : TypeInfo;
    public mutable AssemblyVersionAttribute_tc          : TypeInfo;
    public mutable AssemblyKeyFileAttribute_tc          : TypeInfo;
    public mutable AssemblyCompanyAttribute_tc          : TypeInfo;
    public mutable AssemblyProductAttribute_tc          : TypeInfo;
    public mutable AssemblyTitleAttribute_tc            : TypeInfo;
    public mutable AssemblyDescriptionAttribute_tc      : TypeInfo;
    public mutable AssemblyCopyrightAttribute_tc        : TypeInfo;
    public mutable AssemblyCultureAttribute_tc          : TypeInfo;
    public mutable AssemblyFileVersionAttribute_tc      : TypeInfo;
    public mutable Nemerle_list_tc                      : TypeInfo;
    public mutable Nemerle_option_tc                    : TypeInfo;
    public mutable IList_tc                             : TypeInfo;
    public mutable ICollection_tc                       : TypeInfo;
    public mutable IEnumerable_tc                       : TypeInfo;
    public mutable IEnumerator_tc                       : TypeInfo;
    public mutable Generic_IEnumerable_tc               : TypeInfo;
    public mutable Generic_IEnumerator_tc               : TypeInfo;
    public mutable Generic_IList_tc                     : TypeInfo;
    public mutable Generic_ICollection_tc               : TypeInfo;
    public mutable Generic_Nullable_tc                  : TypeInfo;
    public mutable DllImport_tc                         : TypeInfo;
    public mutable Serializable_tc                      : TypeInfo;
    public mutable Obsolete_tc                          : TypeInfo;
    public mutable Conditional_tc                       : TypeInfo;
    public mutable IgnoreFieldAttribute_tc              : TypeInfo;
    public mutable IgnoreConstructorAttribute_tc        : TypeInfo;
    public mutable IdentityFunction_tc                  : TypeInfo;
    public mutable SecurityAttribute_tc                 : TypeInfo;
    public mutable AssemblyConfigurationAttribute_tc    : TypeInfo;
    public mutable DebuggableAttribute_tc               : TypeInfo;
    public mutable DebuggableAttribute_DebuggingModes_tc : TypeInfo;
    public mutable CompilationRelaxationsAttribute_tc   : TypeInfo;
    public mutable RuntimeHelpers_tc                    : TypeInfo;
    public mutable MethodBase_tc                        : TypeInfo;
    public mutable RuntimeTypeHandle_tc                 : TypeInfo;
    public mutable RuntimeMethodHandle_tc               : TypeInfo;
    public mutable RuntimeFieldHandle_tc                : TypeInfo;
    public mutable Pointer_tc                           : TypeInfo;

    mutable function_types                              : array [FunctionType];
    mutable tuple_types                                 : array [TupleType];
    mutable array_types                                 : array [TypeInfo];

    public mutable Void                                 : FixedType.Void;
    public mutable Array                                : FixedType.Class;
    public mutable Attribute                            : FixedType.Class;
    public mutable Boolean                              : FixedType.Class;
    public mutable Byte                                 : FixedType.Class;
    public mutable Char                                 : FixedType.Class;
    public mutable Decimal                              : FixedType.Class;
    public mutable Delegate                             : FixedType.Class;
    public mutable Double                               : FixedType.Class;
    public mutable Enum                                 : FixedType.Class;
    public mutable Exception                            : FixedType.Class;
    public mutable Int16                                : FixedType.Class;
    public mutable Int32                                : FixedType.Class;
    public mutable Int64                                : FixedType.Class;
    public mutable IntPtr                               : FixedType.Class;
    public mutable Object                               : FixedType.Class;
    public mutable SByte                                : FixedType.Class;
    public mutable Single                               : FixedType.Class;
    public mutable String                               : FixedType.Class;
    public mutable Type                                 : FixedType.Class;
    public mutable MethodInfo                           : FixedType.Class;
    public mutable ConstructorInfo                      : FixedType.Class;
    public mutable FieldInfo                            : FixedType.Class;
    public mutable PropertyInfo                         : FixedType.Class;
    public mutable UInt16                               : FixedType.Class;
    public mutable UInt32                               : FixedType.Class;
    public mutable UInt64                               : FixedType.Class;
    public mutable ValueType                            : FixedType.Class;
    public mutable MatchFailureException                : FixedType.Class;
    public mutable IObjectReference                     : FixedType.Class;
    public mutable Reflection_Missing                   : FixedType.Class;
    public mutable RuntimeTypeHandle                    : FixedType.Class;
    public mutable RuntimeFieldHandle                   : FixedType.Class;
    public mutable RuntimeMethodHandle                  : FixedType.Class;

    public mutable Delegate_Combine                     : IMethod;
    public mutable Delegate_Remove                      : IMethod;
    public mutable String_Concat                        : IMethod;

    public IntegralTypes : array [FixedType.Class]
    {
      get
      {
        array [InternalType.Int32, InternalType.SByte, InternalType.Byte,
              InternalType.Int16, InternalType.UInt16, InternalType.UInt32,
              InternalType.Int64, InternalType.UInt64]
      }
    }

    public Decimal_ctors : Hashtable [string, IMethod]
    {
      mutable table : Hashtable [string, IMethod];
      get
      {
        when (table == null)
        {
          table = Hashtable ();

          foreach (ctor is IMethod in Decimal_tc.LookupMember(".ctor"))
          {
            def signature  = System.Text.StringBuilder();
            def separator  = ", ";
            foreach (p in ctor.Header.Parameters)
            {
              def typeName = if (p.Type is FixedType.Class as c) c.TypeInfo.Name else p.Type.ToString();
              _ = signature.Append(typeName).Append(separator);
            }
            when (signature.Length > 0)
              signature.Length -= separator.Length;

            table[signature.ToString()] = ctor;
          }

          assert(table.Count >= 7)
        }
        table
      }
    }

    public MatchFailureException_ctor : IMethod
    {
      [Memoize] get { get_single_method(MatchFailureException_tc, ".ctor"); }
    }

    public RuntimeHelpers_get_OffsetToStringData : IMethod
    {
      [Memoize] get { get_single_method(RuntimeHelpers_tc, "get_OffsetToStringData"); }
    }

    public Type_GetTypeFromHandle : IMethod
    {
      [Memoize] get { get_method(Type_tc, "GetTypeFromHandle", RuntimeTypeHandle); }
    }

    public MethodBase_GetMethodFromHandle : IMethod
    {
      [Memoize] get { get_method(MethodBase_tc, "GetMethodFromHandle", RuntimeMethodHandle); }
    }

    public MethodBase_GetMethodFromHandle2 : IMethod
    {
      [Memoize] get { get_method(MethodBase_tc, "GetMethodFromHandle", RuntimeMethodHandle, RuntimeTypeHandle); }
    }

    public FieldInfo_GetFieldFromHandle : IMethod
    {
      [Memoize] get { get_method(FieldInfo_tc, "GetFieldFromHandle", RuntimeFieldHandle); }
    }

    public FieldInfo_GetFieldFromHandle2 : IMethod
    {
      [Memoize] get { get_method(FieldInfo_tc, "GetFieldFromHandle", RuntimeFieldHandle, RuntimeTypeHandle); }
    }

    public String_opEquality : IMethod 
    {
      [Memoize] get { get_single_method(String_tc, "op_Equality"); }
    }

    public Decimal_opEquality : IMethod
    {
      [Memoize] get { get_single_method(Decimal_tc, "op_Equality"); }
    }

    static get_single_method (tc : TypeInfo, name : string) : IMethod
    {
      match (tc.LookupMember(name))
      {
        | [x] => x :> IMethod
        | _ => Util.ice()
      }
    }

    static get_method(tc : TypeInfo, name : string, params parms : array[FixedType]) : IMethod
    {
      def isMatch(_)
      {
        | x is IMethod =>
          def loop(p, index)
          {
            match (p)
            {
              | [] => index == parms.Length
              | head :: tail =>
                if (index < parms.Length && head.Type.Equals(parms[index]))
                  loop(tail, index + 1)
                else
                  false
            }
          }
          loop(x.Header.Parameters, 0)
          
        | _ => false
      }
      
      match (tc.LookupMember(name).Filter(isMatch))
      {
        | [x] => x :> IMethod
        | _ => Util.ice()
      }
    }

    public GetFunctionType (len : int) : FunctionType
    {
      when (function_types.Length <= len)
        Message.FatalError ($ "function types only up to $(function_types.Length - 1) parameters are supported, sorry (got $len)");
      when (function_types [len] == null)
        function_types [len] = FunctionType (Manager, len);

      function_types [len]
    }

    public GetTupleType (len : int) : TupleType
    {
      when (tuple_types.Length <= len)
        Message.FatalError ($ "tuple types only up to $(tuple_types.Length - 1) parameters are supported, sorry (got $len)");
      when (tuple_types [len] == null)
        tuple_types [len] = TupleType (Manager, len);

      tuple_types [len]
    }

    public GetArrayType (dims : int) : TypeInfo
    {
      when (array_types [dims] == null)
        array_types [dims] = lookup ($ "Nemerle.Builtins.Array$dims");
      array_types [dims]
    }

    lookup (type_name : string) : TypeInfo
    {
      Manager.Lookup (type_name)
    }

    lookup (type_name : string, args_count : int) : TypeInfo
    {
      Manager.Lookup (type_name, args_count)
    }

    internal InitSystemTypes () : void
    {
      def pointerNode     = Manager.NameTree.NamespaceTree.Path("Nemerle.Builtins.Pointer");
      def pointerTypeInfo = PointerTypeInfo(pointerNode, Manager);
      Pointer_tc          = pointerTypeInfo;
      LibraryReferenceManager.CacheTypeInfo(null, pointerTypeInfo, pointerNode);

      // ordering is important here
      Boolean_tc = lookup ("System.Boolean"); Boolean = FixedType.Class (Boolean_tc, []);
      Int32_tc  = lookup("System.Int32");  Int32  = FixedType.Class(Int32_tc, []);

      Manager.LibrariesManager.add_buildins = true;
      (Boolean_tc :> ExternalTypeInfo).AddBuiltins ();
      (Int32_tc :> ExternalTypeInfo).AddBuiltins ();

      // and here not
      Object_tc = lookup ("System.Object"); Object = FixedType.Class (Object_tc, []);
      IntPtr_tc = lookup("System.IntPtr"); IntPtr = FixedType.Class(IntPtr_tc, []);
      (Object_tc :> ExternalTypeInfo).AddBuiltins ();
      Void_tc = lookup ("System.Void"); Void = FixedType.Void();
      Array_tc = lookup ("System.Array"); Array = FixedType.Class (Array_tc, []);
      Attribute_tc = lookup ("System.Attribute"); Attribute = FixedType.Class (Attribute_tc, []);
      Byte_tc = lookup ("System.Byte"); Byte = FixedType.Class (Byte_tc, []);
      Char_tc = lookup ("System.Char"); Char = FixedType.Class (Char_tc, []);
      Decimal_tc = lookup ("System.Decimal"); Decimal = FixedType.Class (Decimal_tc, []);
      Delegate_tc = lookup ("System.Delegate"); Delegate = FixedType.Class (Delegate_tc, []);
      MulticastDelegate_tc = lookup ("System.MulticastDelegate");
      Double_tc = lookup ("System.Double"); Double = FixedType.Class (Double_tc, []);
      Enum_tc = lookup ("System.Enum"); Enum = FixedType.Class (Enum_tc, []);
      Exception_tc = lookup ("System.Exception"); Exception = FixedType.Class (Exception_tc, []);
      Int16_tc = lookup ("System.Int16"); Int16 = FixedType.Class (Int16_tc, []);
      Int64_tc = lookup ("System.Int64"); Int64 = FixedType.Class (Int64_tc, []);
      SByte_tc = lookup ("System.SByte"); SByte = FixedType.Class (SByte_tc, []);
      Single_tc = lookup ("System.Single"); Single = FixedType.Class (Single_tc, []);
      String_tc = lookup ("System.String"); String = FixedType.Class (String_tc, []);
      Type_tc = lookup ("System.Type"); InternalType.Type = FixedType.Class (Type_tc, []);
      MethodInfo_tc = lookup ("System.Reflection.MethodInfo"); InternalType.MethodInfo = FixedType.Class (MethodInfo_tc, []);
      ConstructorInfo_tc = lookup ("System.Reflection.ConstructorInfo"); InternalType.ConstructorInfo = FixedType.Class (ConstructorInfo_tc, []);
      FieldInfo_tc = lookup ("System.Reflection.FieldInfo"); InternalType.FieldInfo = FixedType.Class (FieldInfo_tc, []);
      PropertyInfo_tc = lookup ("System.Reflection.PropertyInfo"); InternalType.PropertyInfo = FixedType.Class (PropertyInfo_tc, []);
      UInt16_tc = lookup ("System.UInt16"); UInt16 = FixedType.Class (UInt16_tc, []);
      UInt32_tc = lookup ("System.UInt32"); UInt32 = FixedType.Class (UInt32_tc, []);
      UInt64_tc = lookup ("System.UInt64"); UInt64 = FixedType.Class (UInt64_tc, []);
      ValueType_tc = lookup ("System.ValueType"); ValueType = FixedType.Class (ValueType_tc, []);
      IEnumerable_tc = lookup ("System.Collections.IEnumerable");
      IEnumerator_tc = lookup ("System.Collections.IEnumerator");
      IList_tc = lookup ("System.Collections.IList");
      ICollection_tc = lookup ("System.Collections.ICollection");
      Generic_IEnumerable_tc = lookup ("System.Collections.Generic.IEnumerable");
      Generic_IEnumerator_tc = lookup ("System.Collections.Generic.IEnumerator");
      Generic_IList_tc = lookup ("System.Collections.Generic.IList");
      Generic_ICollection_tc = lookup ("System.Collections.Generic.ICollection");
      Generic_Nullable_tc = lookup ("System.Nullable", 1);
      DllImport_tc = lookup ("System.Runtime.InteropServices.DllImportAttribute");
      Serializable_tc = lookup ("System.SerializableAttribute");
      Obsolete_tc = lookup ("System.ObsoleteAttribute");
      Conditional_tc = lookup ("System.Diagnostics.ConditionalAttribute");
      IObjectReference = FixedType.Class (lookup ("System.Runtime.Serialization.IObjectReference"), []);
      Reflection_Missing = FixedType.Class (lookup ("System.Reflection.Missing"), []);
      
      ParamArrayAttribute_tc                = lookup("System.ParamArrayAttribute");
      FlagsAttribute_tc                     = lookup("System.FlagsAttribute");
      AssemblyVersionAttribute_tc           = lookup("System.Reflection.AssemblyVersionAttribute");
      AssemblyKeyFileAttribute_tc           = lookup("System.Reflection.AssemblyKeyFileAttribute");
      AssemblyCultureAttribute_tc           = lookup("System.Reflection.AssemblyCultureAttribute");
      AssemblyCompanyAttribute_tc           = lookup("System.Reflection.AssemblyCompanyAttribute");
      AssemblyCopyrightAttribute_tc         = lookup("System.Reflection.AssemblyCopyrightAttribute");
      AssemblyDescriptionAttribute_tc       = lookup("System.Reflection.AssemblyDescriptionAttribute");
      AssemblyFileVersionAttribute_tc       = lookup("System.Reflection.AssemblyFileVersionAttribute");
      AssemblyTitleAttribute_tc             = lookup("System.Reflection.AssemblyTitleAttribute");
      AssemblyProductAttribute_tc           = lookup("System.Reflection.AssemblyProductAttribute");
      AssemblyConfigurationAttribute_tc     = lookup("System.Reflection.AssemblyConfigurationAttribute");
      SecurityAttribute_tc                  = lookup("System.Security.Permissions.SecurityAttribute");
      DebuggableAttribute_tc                = lookup("System.Diagnostics.DebuggableAttribute");
      DebuggableAttribute_DebuggingModes_tc = lookup("System.Diagnostics.DebuggableAttribute.DebuggingModes");
      CompilationRelaxationsAttribute_tc    = lookup("System.Runtime.CompilerServices.CompilationRelaxationsAttribute");
      RuntimeHelpers_tc                     = lookup("System.Runtime.CompilerServices.RuntimeHelpers");
      MethodBase_tc                         = lookup("System.Reflection.MethodBase");
      RuntimeTypeHandle_tc                  = lookup("System.RuntimeTypeHandle");   RuntimeTypeHandle  = FixedType.Class(RuntimeTypeHandle_tc, []);
      RuntimeMethodHandle_tc                = lookup("System.RuntimeMethodHandle"); RuntimeMethodHandle= FixedType.Class(RuntimeMethodHandle_tc, []);
      RuntimeFieldHandle_tc                 = lookup("System.RuntimeFieldHandle");  RuntimeFieldHandle = FixedType.Class(RuntimeFieldHandle_tc, []);

      def is_right(mem : IMember)
      {
        match (mem)
        {
          | meth is IMethod =>
            def parms = meth.GetParameters();
            def isMatched = meth.IsStatic && parms.Length == 2 && ! parms.Head.ty.Equals(Object);
            isMatched && if (mem.Name == "Concat") parms.Head.Type.TryUnify(String) else true
          | _ => false
        }
      }

      def single(tc : TypeInfo, name)
      {
        match (tc.LookupMember(name).Filter(is_right))
        {
          | [s]  => s :> IMethod
          | []   => assert(false, $"No '$name' member found in '$(tc.FullName)'")
          | null => assert(false, "tc.LookupMember(name).Filter(is_right) return null")
          | xs   => assert(false, $"More then one '$name' member found in '$(tc.FullName)': ..$xs")
        }
      }

      Delegate_Combine = single(Delegate_tc, "Combine");
      Delegate_Remove  = single(Delegate_tc, "Remove");
      String_Concat    = single(String_tc, "Concat");

      pointerTypeInfo.AddBuiltins();

      function_types   = array(21);
      tuple_types      = array(21);
      array_types      = array(20);

      InternalType.MatchFailureException_tc = null; // cleanup
    }

    // to be called after scan_globals (think about compiling nemerle.dll)
    internal InitNemerleTypes () : void
    {
      // prevent multiple execution
      when (InternalType.MatchFailureException_tc == null)
      {
        InternalType.MatchFailureException_tc = lookup ("Nemerle.Core.MatchFailureException");
        InternalType.MatchFailureException = FixedType.Class (InternalType.MatchFailureException_tc, []);

        InternalType.NullMatchException_tc = lookup ("Nemerle.Core.NullMatchException");
        InternalType.ContainsMacroAttribute_tc = lookup ("Nemerle.Internal.ContainsMacroAttribute");
        InternalType.VariantAttribute_tc = lookup ("Nemerle.Internal.VariantAttribute");
        InternalType.TypeAliasAttribute_tc = lookup ("Nemerle.Internal.TypeAliasAttribute");
        InternalType.VariantOptionAttribute_tc = lookup ("Nemerle.Internal.VariantOptionAttribute");
        InternalType.VolatileModifier_tc = lookup ("Nemerle.Internal.VolatileModifier");
        InternalType.ImmutableAttribute_tc = lookup ("Nemerle.Internal.ImmutableAttribute");
        InternalType.ExtensionAttribute_tc = lookup ("Nemerle.Internal.ExtensionAttribute");
        InternalType.ConstantVariantOptionAttribute_tc = lookup ("Nemerle.Internal.ConstantVariantOptionAttribute");
        InternalType.ExtensionPatternEncodingAttribute_tc = lookup ("Nemerle.Internal.ExtensionPatternEncodingAttribute");

        InternalType.Nemerle_list_tc = lookup ("Nemerle.Core.list", 1);
        InternalType.Nemerle_option_tc = lookup ("Nemerle.Core.option");

        InternalType.IgnoreFieldAttribute_tc = lookup ("Nemerle.Internal.IgnoreFieldAttribute");
        InternalType.IgnoreConstructorAttribute_tc = lookup ("Nemerle.Internal.IgnoreConstructorAttribute");

        InternalType.IdentityFunction_tc = lookup("Nemerle.Utility.Identity");
      }
    }

    internal this (man : ManagerClass)
    {
      Manager = man;
    }
  }
} // end ns
