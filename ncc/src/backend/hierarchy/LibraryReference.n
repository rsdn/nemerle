using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;
using Nemerle.IO;
using Nemerle.Utility;
using System.IO;
using System.Runtime.CompilerServices;
using System.Collections.ObjectModel;

using DN    = dnlib.DotNet;
using PE    = dnlib.PE;
using PT    = Nemerle.Compiler.Parsetree;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;
using SR    = System.Reflection;
using SCG   = System.Collections.Generic;

namespace Nemerle.Compiler
{
  /// This class stores information extracted from a referenced external library.
  [ManagerAccess]
  public partial class LibraryReference
  {
    /// The location of this library
    public   Location         : Location       { get; internal set; }
    public   IsFriend         : bool           { get; }
    public   IsUserReference  : bool           { get; internal set; }
    public   ReferenceManager : LibraryReferenceManager;
    internal ModuleDef        : DN.ModuleDef   { get; }
    internal AssemblyRef      : DN.AssemblyRef { get; }
    /// If set to true, the current assembly declares itself to be generated by the Nemerle compiler.
    _is_generated_by_nemerle : bool;

    /// Load an assembly. Extracts and processes the custom attributes array.
    internal this(mgr : LibraryReferenceManager, assemblyPath : string, isUserReference : bool)
    {
      def peImage                      = PE.PEImage(File.ReadAllBytes(assemblyPath), assemblyPath);
      def loadOptions                  = DN.ModuleCreationOptions(mgr.Context);
      loadOptions.CorLibAssemblyRef    = mgr.CorlibReference;
      loadOptions.TryToLoadPdbFromDisk = false;
      def moduleDef                    = DN.ModuleDefMD.Load(peImage, loadOptions);
      this(mgr, moduleDef, isUserReference)
    }

    internal this(mgr : LibraryReferenceManager, moduleDef : DN.ModuleDef, isUserReference : bool)
    {
      ReferenceManager = mgr;
      Manager          = mgr.Manager;
      ModuleDef        = moduleDef;
      IsUserReference  = isUserReference;
      def assembly     = ModuleDef.Assembly;
      def fileName     = if (moduleDef is DN.ModuleDefMD as m) m.Metadata.PEImage.Filename else assembly.Name + ".dll";
      Location         = Location(FileUtils.GetSource(fileName), 0);

      // HACK: hide platform architecture or Importer would use it in AssemblyRefs
      assembly.Attributes = assembly.Attributes & ~DN.AssemblyAttributes.PA_FullMask;
      _ = mgr.AssemblyResolver.AddToCache(assembly);

      mutable publicKeyToken = DN.PublicKeyBase.ToPublicKeyToken(assembly.PublicKeyOrToken);
      when (publicKeyToken != null && publicKeyToken.IsNullOrEmpty)
        publicKeyToken = null;

      AssemblyRef = DN.AssemblyRefUser(assembly.Name, assembly.Version, publicKeyToken, assembly.Culture);
      AssemblyRef.Attributes = assembly.Attributes & ~(DN.AssemblyAttributes.PublicKey | DN.AssemblyAttributes.PA_FullMask);
      when (mgr.CorlibReference : object == null && ModuleDef.IsCoreLibraryModule ?? false)
      {
        AssemblyRef.Culture      = DN.UTF8String.Empty;
        mgr.CorlibReference      = AssemblyRef;
        mgr.CorlibRuntimeVersion = ModuleDef.RuntimeVersion;
      }

      def currentAssemblyName = Path.GetFileNameWithoutExtension(this.Manager.Options.OutputFileName);
      def snKey() : SR.StrongNameKeyPair
      {
        using (keyFile = File.Open(this.Manager.Options.StrongAssemblyKeyName, FileMode.Open, FileAccess.Read))
          SR.StrongNameKeyPair(keyFile)
      }
      def toHexString(bytes : array[byte]) : string
      {
        def hex = System.BitConverter.ToString(bytes);
        hex.Replace("-","");
      }
      def generatePublicKeyToken(publicKey : array[byte]) : array[byte]
      {
        def sha = System.Security.Cryptography.SHA1Managed();
        def hash = sha.ComputeHash(publicKey);
        def len = 8;
        mutable result : array[byte] = array(len);
        System.Array.Copy(hash, hash.Length - len , result, 0, len);
        System.Array.Reverse(result, 0, len);
        result;
      }

      // Scans the assembly custom attributes looking for something interesting...
      foreach (a in ModuleDef.Assembly.CustomAttributes)
      {
        match (a.TypeFullName)
        {
          | "System.Reflection.AssemblyConfigurationAttribute" when !_is_generated_by_nemerle && a.HasConstructorArguments =>
            when (a.ConstructorArguments[0].Value is DN.UTF8String as configuration)
              _is_generated_by_nemerle = "ContainsNemerleTypes".Equals(configuration : string);

          | "System.Runtime.CompilerServices.InternalsVisibleToAttribute" when !IsFriend && a.HasConstructorArguments =>
            when (a.ConstructorArguments[0].Value is DN.UTF8String as assemblyName)
            {
              def parts = (assemblyName : string).Replace(" ", "").SplitToList(array[',']);
              match (parts)
              {
                | [asmName] when currentAssemblyName == asmName => IsFriend = true
                | [asmName, pKey] when string.IsNullOrEmpty(this.Manager.Options.StrongAssemblyKeyName) && currentAssemblyName == asmName =>
                  match(pKey.ToLower().SplitToList(array[',']))
                  {
                    | ["publickey", key] when toHexString(snKey().PublicKey).ToLower() == key.ToLower()
                    | ["publickeytoken", key] when toHexString(generatePublicKeyToken(snKey().PublicKey)).ToLower() == key.ToLower() => IsFriend = true
                    | _ => ()
                  }

                | _ => ()
              }
            }

          | _ => ()
        }
      }
    }

    internal ModuleRef : DN.ModuleRef
    {
      mutable _moduleRef : DN.ModuleRef;
      get
      {
        when (_moduleRef == null)
        {
          def moduleBuilder = Manager.Hierarchy.GetModuleBuilder();
          _moduleRef = DN.ModuleRefUser(moduleBuilder, ModuleDef.Name) |> moduleBuilder.UpdateRowId;
        }
        _moduleRef
      }
    }

    public FullName : string
    {
      get { ModuleDef.Assembly.FullName }
    }

    public override ToString () : string
    {
      Location.File
    }

    public TryGetResourceStream(name : string) : Stream
    {
      def resource = ModuleDef.Resources.FindEmbeddedResource(name);
      if (resource != null)
        resource.CreateReader().AsStream()
      else
        null
    }

    public GetReferencedAssemblies() : Seq[string]
    {
      foreach (r in ModuleDef.GetAssemblyRefs())
      {
        yield r.FullName
      }
    }

    /// Turns a Framework type into something edible by Nemerle's type system
    internal TypeOfType(genericResolver : DN.GenericParam -> FixedType, framework_type : DN.ITypeDefOrRef, rawInternals : bool = false) : FixedType
    {
      if (framework_type.Namespace == "System" && framework_type.Name == "Void")
        InternalType.Void
      else if (framework_type is DN.TypeSpec(TypeSig = sig))
        TypeOfType(genericResolver, sig, rawInternals)
      else
        CreateTypeSpecialization(framework_type, [], rawInternals)
    }

    /// Turns a Framework type into something edible by Nemerle's type system
    internal TypeOfType(_tenv : Map [string, StaticTypeVar], framework_type : DN.TypeSig, rawInternals : bool = false) : FixedType
    {
      TypeOfType(_tenv.ToGenericResolver(), framework_type, rawInternals)
    }

    internal TypeOfType(genericResolver : DN.GenericParam -> FixedType, framework_type : DN.TypeSig, rawInternals : bool = false) : FixedType
    {
      match (framework_type)
      {
        | t is DN.TypeDefOrRefSig => TypeOfType(genericResolver, t.TypeDefOrRef, rawInternals)
        | t is DN.ArraySigBase    => FixedType.Array(TypeOfType(genericResolver, framework_type.Next, rawInternals), t.Rank :> int)
        | _ is DN.ModifierSig
        | _ is DN.ByRefSig        => TypeOfType(genericResolver, framework_type.Next, rawInternals)
        | t is DN.GenericSig      => genericResolver(t.GenericParam)
        | t is DN.GenericInstSig =>
          def typarms = t.GenericArguments.Map(TypeOfType(genericResolver, _, rawInternals = false));
          CreateTypeSpecialization(t.GenericType.TypeDefOrRef, typarms, rawInternals)

        | t is DN.PtrSig =>
          def element = TypeOfType(genericResolver, t.Next, rawInternals);
          element.MakePointerType()

        | _ is DN.FnPtrSig => InternalType.IntPtr  // TODO: поддержать указатели на функции
        | _ =>
          assert2(false, $"Unknown type signature $framework_type");
          InternalType.Object
      }
    }

    private CreateTypeSpecialization(framework_type : DN.ITypeDefOrRef, parms : list[TypeVar], rawInternals : bool) : FixedType
    {
      def tc = ReferenceManager.TypeInfoOfType(framework_type);

      if (framework_type.Namespace == "Nemerle.Builtins" && !rawInternals)
      {
        def make_tupl(l)
        {
          | [x] => x
          | []  => InternalType.Void
          | _   => FixedType.Tuple(l)
        }

        if (tc.Name == "Tuple")
          FixedType.Tuple(parms)
        else if (tc.Name == "FunctionVoid")
          FixedType.Fun(make_tupl(parms), parms.Length, InternalType.Void)
        else
        {
          def (front, last) = parms.DivideLast();
          FixedType.Fun(make_tupl(front), front.Length, last)
        }
      }
      else FixedType.Class(tc, parms);
    }

    /// Construct TypeInfo object from given type in current assembly.
    internal ConstructTypeInfo (reflected_type : DN.TypeDef, ns_node : NamespaceTree.Node) : TypeInfo
    {
      if (_is_generated_by_nemerle)
        ExternalNemerleTypeInfo(this, reflected_type, ns_node)
      else if (reflected_type.IsPrimitive)
        ExternalPrimitiveTypeInfo(this, reflected_type, ns_node)
      else
        ExternalTypeInfo(this, reflected_type, ns_node)
    }

    internal GetInternalType(t : DN.TypeDef, node : NamespaceTree.Node) : TypeInfo
    {
      match (node.Value)
      {
        | NamespaceTree.TypeInfoCache.Cached(tc) => tc
        | NamespaceTree.TypeInfoCache.No => ConstructTypeInfo(t, node);
        | _ => Util.ice ("not loaded internal type... " + t.AssemblyQualifiedName)
      }
    }

    /// Looks for type named [name] that is internal to current assembly. Used
    /// by type attribute decoder.
    internal LookupInternalType (name : string) : option [TypeInfo]
    {
    //  Message.Debug ($"looking `$(name)'");
      def st = ModuleDef.Find(name, true);

      if (st == null)
        None ()
      else
      {
        def (ns, _) = ReferenceManager.framework_nesting (st);
        Some (GetInternalType(st, ns))
      }
    }

    public GetCustomAttributes() : list[PExpr * list[PExpr]]
    {
      ConvertCustomAttributesData(ModuleDef, this)
    }

    internal static ConvertCustomAttributesData(attributeOwner : DN.IHasCustomAttribute, library : LibraryReference) : list[PExpr * list[PExpr]]
    {
      def manager = library.Manager;
      def result = SCG.List();

      foreach (attr in attributeOwner.CustomAttributes)
      {
        def name = PExpr.FromQualifiedIdentifier(manager, attr.TypeFullName);
        def makeArg(a : DN.CAArgument) : PExpr
        {
          def lift(value : object) : PExpr
          {
            | value is bool           => <[ $(value :  bool   ) ]>
            | value is string         => <[ $(value :  string ) ]>
            | value is DN.UTF8String  => <[ $(value :  string ) ]>
            | value is double         => <[ $(value :  double ) ]>
            | value is float          => <[ $(value :  float  ) ]>
            | value is decimal        => <[ $(value :  decimal) ]>
            | value is int            => <[ $(value :  int    ) ]>
            | value is uint           => <[ $(value :  uint   ) ]>
            | value is long           => <[ $(value :  long   ) ]>
            | value is ulong          => <[ $(value :  ulong  ) ]>
            | value is short          => <[ $(value :  short  ) ]>
            | value is ushort         => <[ $(value :  ushort ) ]>
            | value is byte           => <[ $(value :  byte   ) ]>
            | value is sbyte          => <[ $(value :  sbyte  ) ]>
            | value is char           => <[ $(value :  char   ) ]>
            | value is System.Guid    => <[ System.Guid($(value.ToString() : string)) ]>
            | value is DN.TypeSig     => <[ typeof($(library.TypeOfType(null : Map[_, _], value) : typed)) ]>
            | col is SCG.IList[DN.CAArgument] => <[ array[..$(col.MapToList(e => lift(e.Value)))] ]>
            | value => Message.FatalError($"Custom atribute value ($value) of type $(value.GetType()) not suported yet.")
          }

          lift(a.Value)
        }
        def args = attr.ConstructorArguments.MapToList(makeArg);
        result.Add((name, args));
      }

      result.NToList()
    }
  }
} /* namespace */
