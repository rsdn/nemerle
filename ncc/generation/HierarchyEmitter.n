/*
 * Copyright (c) 2003-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler.Typedtree;
using Nemerle.Collections;
using Nemerle.Utility;

using System.Reflection;
using System.IO;
using System.Diagnostics.SymbolStore;
using System.Diagnostics;
using System.Security;

using NC = Nemerle.Compiler;
using SRE = System.Reflection.Emit;
using NC = Nemerle.Compiler;

namespace Nemerle.Compiler
{
  /**
   * This part of TypesManages is responsible for generation of System.Reflection.Emit structures
   * composing program hierarchy. It executes emission of all classes and their members.
   */
  [ManagerAccess]
  public partial class TypesManager : System.IDisposable
  {
    /* -- PUBLIC CONSTRUCTORS ---------------------------------------------- */

    // workaround MS.NET bugs with some specific value / generic types hierarchy
    private resolve_hack (_ : object, _ : System.ResolveEventArgs) : Assembly
    {
      //Message.Debug ($ "resolve_hack: $(args.Name)");
      _assembly_builder
    }

    public this (man : ManagerClass)
    {
      Manager = man;
      _OutputFileName = Manager.Options.OutputFileName;

      unless (Manager.Options.TargetIsLibrary)
      {
        _need_entry_point = true;
        _entry_point = None ();
      }

      unless (Manager.IsIntelliSenseMode)
        System.AppDomain.CurrentDomain.TypeResolve += resolve_hack;
    }

    public Dispose () : void
    {
      unless (Manager.IsIntelliSenseMode)
        System.AppDomain.CurrentDomain.TypeResolve -= resolve_hack;
    }

    public CreateAssembly () : void
    {
      // we need to process global assembly attributes before creating assembly name
      _assembly_name = CreateAssemblyName ();

      _assembly_name.Name = Path.GetFileNameWithoutExtension (_OutputFileName);

      def assembly_requirements =
        if (Manager.Options.CompileToMemory)
          Emit.AssemblyBuilderAccess.Run
        else
          Emit.AssemblyBuilderAccess.Save;

      def dir = Path.GetDirectoryName(Path.GetFullPath (_OutputFileName));
      unless (Directory.Exists (dir))
        Message.FatalError ($"specified output directory `$dir' does not exist");

#pragma warning disable 618

      mutable required : PermissionSet;
      mutable optional : PermissionSet;
      mutable refused : PermissionSet;

      foreach ((action, perm_set) in Manager.AttributeCompiler.GetPermissionSets (assembly_attributes)) {
        match (action) {
        | Permissions.SecurityAction.RequestMinimum  => required = perm_set
        | Permissions.SecurityAction.RequestOptional => optional = perm_set
        | Permissions.SecurityAction.RequestRefuse   => refused  = perm_set
        | _ => Message.FatalError ($"$action is not valid here")
        }
      }

      /* define a dynamic assembly */
      this._assembly_builder =
        System.AppDomain.CurrentDomain.DefineDynamicAssembly
          (this._assembly_name,
           assembly_requirements,
           dir, required, optional, refused);

      GetInformationalAssemblyAttributes().Iter(this._assembly_builder.SetCustomAttribute);
#pragma warning restore 618

      when (_assembly_name.Name == "") Message.FatalError ("name of output assembly cannot be empty");

      /* create a dynamic module */
      this._module_builder =
        if (Manager.Options.CompileToMemory)
          // we cannot give output filename if we are compiling only to Run
          this._assembly_builder.DefineDynamicModule (_assembly_name.Name, Manager.Options.EmitDebug);
        else
          this._assembly_builder.DefineDynamicModule (_assembly_name.Name,
                                                      Path.GetFileName (_OutputFileName),
                                                      Manager.Options.EmitDebug);
    
      when (Manager.Options.EmitDebug) _debug_emit = _module_builder.GetSymWriter ();
    }

    public IsEmitting : bool {
      get { _assembly_builder != null }
    }

    add_resources_to_assembly () : void
    {
      def escape_resource (x : string) {
        def cp = x.IndexOf (',');
        if (cp != -1)
          (x.Substring (0, cp), x.Substring (cp + 1))
        else
          // change name from /bar/bar/file.png to file.png namespace
          (x, Path.GetFileName (x));
      }

      /* we can embed resources only on mono or .NET 2.0 */
      foreach (element in Manager.Options.EmbeddedResources) {
        def (file, name) = escape_resource (element);
        try {
          if (File.Exists (file)) {
            def fs = File.OpenRead (file);

            def meth = _module_builder.GetType ().GetMethod ("DefineManifestResource");
            if (meth == null) {
              try {
                def res = array (fs.Length :> int);
                def loop (pos) {
                  if (res.Length == pos) {}
                  else
                    loop (pos + fs.Read(res, pos, res.Length - pos));
                }
                loop (0);

                def meth = _assembly_builder.GetType ()
                  .GetMethod ("EmbedResource", BindingFlags.NonPublic|BindingFlags.Instance);
                if (meth == null)
                  Message.Error ("cannot find API for saving resources");
                else
                  _ = meth.Invoke (_assembly_builder, array [name : object, res,
                                                             ResourceAttributes.Public]);
              }
              finally {
                fs.Dispose ();
              }
            }
            else {
              // this method does the Dispose for us
              _ = meth.Invoke (_module_builder, array [name : object,
                                                       fs, ResourceAttributes.Public])
            }
          }
          else
            Message.Error ("Could not find resource " + file);
        }
        catch {
          | e => Message.Error ("Could not embed resource: " + e.Message);
        }
      }

      foreach (element in Manager.Options.LinkedResources) {
        def (file, name) = escape_resource (element);
        try {
          _assembly_builder.AddResourceFile (name, file);
        }
        catch {
          | _ is FileNotFoundException =>
            Message.Error ("Could not find resource " + file);
          | e is System.ArgumentException =>
            Message.Error ("Could not link resource: " + e.Message);
        }
      }

      def uresource = Manager.Options.UnmanagedResource;
      if(uresource != null) {
        try {
          _module_builder.DefineUnmanagedResource(uresource);
        }
        catch {
          | _ is FileNotFoundException =>
            Message.Error("Could not find resource" + uresource);
          | e is System.ArgumentException =>
            Message.Error($"Could not embed unmanaged resource $uresource: $(e.Message)");
        }
     }
   else
   {
     this._assembly_builder.DefineVersionInfoResource();  
     }

    }

    /**
     *
     */
    public EmitAuxDecls () : void
    {
      compile_all_tyinfos (true)
    }


    /**
     *
     */
    public EmitDecls () : void
    {
      Manager.Solver.Enqueue (fun () {
        compile_all_tyinfos (false);
        foreach ((attr, shouldEmit) when shouldEmit in Manager.AttributeCompiler.GetCompiledAssemblyAttributes (assembly_attributes))
          _assembly_builder.SetCustomAttribute (attr);

        // emit debug attributes
        when (Manager.Options.EmitDebug) {
          def attr = Manager.AttributeCompiler.MakeEmittedAttribute (SystemTypeCache.DebuggableAttribute, array [SystemTypeCache.DebuggableAttribute_DebuggingModes],
            DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.Default);
          _assembly_builder.SetCustomAttribute (attr);
        }

        // do not require string literals interning
        def attr = Manager.AttributeCompiler.MakeEmittedAttribute (SystemTypeCache.CompilationRelaxationsAttribute, 8);
        _assembly_builder.SetCustomAttribute (attr);

        // wrap non exception throws
        /* uncomment it after we get dependency upon mono 1.1.10, since mono 1.1.9.x do not support this attribute
        def (_, attr) = AttributeCompiler.CompileAttribute (GlobalEnv.Core, null, <[ System.Runtime.CompilerServices.RuntimeCompatibilityAttribute (WrapNonExceptionThrows=true) ]>);
        _assembly_builder.SetCustomAttribute (attr);
        */
      })
    }

    /**
     * Returns generated assembly for runtime instantations of its types
     */
    public GeneratedAssembly : Assembly
    {
      get { _assembly_builder }
    }


    /**
     * Saves the constructed assembly to a file
     */
    public SaveAssembly () : void
    {
      add_resources_to_assembly ();

      // if there are some nemerle specific metadata encoded in attributes
      when (contains_nemerle_specifics) {
        def attr = Manager.AttributeCompiler.MakeEmittedAttribute (SystemTypeCache.Reflection_AssemblyConfigurationAttribute, "ContainsNemerleTypes");
        this._assembly_builder.SetCustomAttribute (attr);
      }

      // set the entry point
      match ((_need_entry_point, _entry_point))
      {
        | (true, Some (entry_point_method_info)) =>
          _assembly_builder.SetEntryPoint (entry_point_method_info,
                                           if (Manager.Options.TargetIsWinexe)
                                             Emit.PEFileKinds.WindowApplication
                                           else
                                             Emit.PEFileKinds.ConsoleApplication)
        | (true, None) =>
          Message.Error ("no suitable entry point (Main function) found")
        | _ => ()
      }

      // save the assembly
      try
      {
        def (portableExecutableKind, imageFileMachine) = make_platform_flags (Manager.Options.Platform);
        _assembly_builder.Save (Path.GetFileName (_OutputFileName), portableExecutableKind, imageFileMachine);
        //when (_debug_emit != null) _debug_emit.Close ();
      }
      catch
      {
        | e is System.UnauthorizedAccessException =>
          Message.Error ($"could not write to output file `$(this._OutputFileName)'"
                         " -- `$(e.Message)'")

        | e is IOException =>
          Message.Error ($"could not write to output file `$(this._OutputFileName)'"
                         " -- `$(e.Message)'")

        | e is System.Runtime.InteropServices.COMException =>
            Message.Error($"Problems saving assembly: $(e.Message)");

        | e is System.ApplicationException =>
          Message.Error (e.Message);
      }
    }

    /* -- PRIVATE METHODS -------------------------------------------------- */


    /**
     * - create S.R.E.TypeBuilders for entire hierarchy of program
     * - add members to those TypeBuilders (only stubs for methods)
     * - emit bodies of methods
     * - finalize value types
     * - finalize all types
     */
    protected virtual compile_all_tyinfos (aux_phase : bool) : void
    {
      def allow_it(ti : TypeBuilder)
      {
        !ti.IsFinalized && is_aux_decl(ti) == aux_phase
      }

      def create_type_emit_builder(ti : TypeBuilder)
      {
        when (allow_it (ti))
        {
          //Message.Debug ("make type builder for " + ti.FullName);
          ti.CreateEmitBuilder ();

          when (ti.Attributes %&& NemerleModifiers.Macro)
          {
            def attr = Manager.AttributeCompiler.MakeEmittedAttribute (SystemTypeCache.ContainsMacroAttribute, ti.GetTypeBuilder ().FullName);
            _assembly_builder.SetCustomAttribute (attr);
          }
        }
      }
      // create members' declarations in SRE.TypeBuilders
      def emit_decls (ti : TypeBuilder)
      {
        when (allow_it(ti))
        {
          // Message.Debug ("generating declarations " + ti.FullName);
          ti.CreateEmitDeclarations()
        }
      }
      def emit_impl(ti : TypeBuilder)
      {
        when (allow_it(ti))
        {
          //Message.Debug ("generating code for " + ti.FullName);
          Manager.MarkTypeBuilderCompiled();
          ti.EmitImplementation()
        }
      }

      when (!aux_phase)
        _cgil_phase = 1;

      Iter(create_type_emit_builder);
      Iter(tb => when (allow_it(tb))
                   tb.UpdateEmittedInheritance());

      when (!aux_phase)
        _cgil_phase = 2;

      // first emit fields of enum types as it is required to compute their sizes,
      // when they are used as fields
      IterConditionally(emit_decls, (x : TypeBuilder) => x.IsEnum);
      IterConditionally(emit_decls, (x : TypeBuilder) => !x.IsEnum);

      when (!aux_phase)
        _cgil_phase = 3;

      // we first finalize value types, because MS.NET runtime requires so
      IterConditionally(emit_impl,
        (x : TypeBuilder) => x.IsValueType && x.DeclaringType == null);

      // now we can finalize everything else
      Iter(emit_impl);

      // MaybeBailout inteferes with the Code Completion Engine
      //unless (Manager.IsIntelliSenseMode)
      //  Message.MaybeBailout ();

      when (!aux_phase)
        _cgil_phase = 4;
    }

    internal EnsureEmitProgress (ti : TypeBuilder) : void
    {
      // Message.Debug ($"ma: $ti -> $mem ");
      when (_cgil_phase >= 1)
      {
        ti.CreateEmitBuilder ();
        ti.UpdateEmittedInheritance ();
      }
    }


    internal MaybeCompile (ti : TypeBuilder, mem : MemberBuilder) : void
    {
      mem.CreateEmitBuilder (ti.GetTypeBuilder ());

      when (_cgil_phase >= 3)
        ti.DoBeforeFinalization(() => mem.Compile())
    }


    /**
     * Check if declaration is auxiliary, used internally etc.
     */
    private static is_aux_decl (ti : TypeBuilder) : bool
    {
      ti.FullName.StartsWith("Nemerle.Internal.")
    }

    private static make_platform_flags (platform : string) : PortableExecutableKinds * ImageFileMachine
    {
      | "x86" =>
        (PortableExecutableKinds.ILOnly | PortableExecutableKinds.Required32Bit
        , ImageFileMachine.I386)

      | "x64" =>
        (PortableExecutableKinds.ILOnly | PortableExecutableKinds.PE32Plus
        , ImageFileMachine.AMD64)

      | ""
      | "anycpu" =>
        (PortableExecutableKinds.ILOnly
        , ImageFileMachine.I386)

      | "ia64" =>
        (PortableExecutableKinds.ILOnly | PortableExecutableKinds.PE32Plus
        , ImageFileMachine.IA64)

      | _ =>
        assert(false)
    }

    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private   mutable _assembly_name              : System.Reflection.AssemblyName;
    private   mutable _assembly_builder           : Emit.AssemblyBuilder;
    internal  mutable _module_builder             : Emit.ModuleBuilder;
    public    mutable _debug_emit                 : ISymbolWriter;
    internal  mutable contains_nemerle_specifics  : bool = false;

    internal          _need_entry_point           : bool;
    /** updated when method with static Main signature is met */
    internal  mutable _entry_point                : option[MethodInfo];

    private           _OutputFileName             : string;
    private   mutable _cgil_phase                 : int;
  }


  public partial class TypeBuilder : NC.TypeInfo
  {
    /**
     * This method makes a skeleton of a class -- the class partial type and
     * partial types for the nested classes are created. The parent class and
     * the interfaces being implemented are assumed to have been processed
     * before constructing a dependant class. All the declarations and method
     * implementations will be created successively in subsequent passes.
     */
    internal CreateEmitBuilder () : void
    {
      when (system_type == null) {
        /* create optional custom attributes for this type */
        def custom_attribute =
          match (tydecl)
          {
            | TypeDeclaration.Variant (decls) =>
              make_nemerle_variant_attribute (decls)

            | TypeDeclaration.VariantOption =>
              def has_co_ctor = GetConstantObject () != null;
              make_nemerle_variant_option_attribute (has_co_ctor)

            | TypeDeclaration.Alias (t) =>
              make_nemerle_type_alias_attribute (t)

            | _ => null
          };

        /* decide the new type attributes */
        def is_nested = DeclaringType != null;

        def type_kind_attrs =
          match (tydecl)
          {
            | TypeDeclaration.Variant
            | TypeDeclaration.VariantOption
            | TypeDeclaration.Class          => TypeAttributes.Class
            | TypeDeclaration.Alias // we pretend type alias is an interface
            | TypeDeclaration.Interface      => TypeAttributes.Interface %| TypeAttributes.Abstract
            | TypeDeclaration.Enum           => TypeAttributes.Sealed %| TypeAttributes.Class
          };

        mutable attrs = make_type_attributes (Attributes, is_nested, IsStruct) %| type_kind_attrs;
        mutable typarms_len = TyparmsCount;

        when (is_nested)
          typarms_len -= DeclaringType.TyparmsCount;

        def generic_mark_suffix =
          match (typarms_len) {
            | 0 => ""
            | l => "`" + l.ToString ()
          }

        def empty_struct = IsStruct && GetFields (BindingFlags.Instance %|
                                                  BindingFlags.Public %|
                                                  BindingFlags.NonPublic).IsEmpty;

        def no_static_ctor = GetConstructors (BindingFlags.Static %|
                                              BindingFlags.Public %|
                                              BindingFlags.NonPublic).IsEmpty;

        when (no_static_ctor)
          attrs = attrs %| TypeAttributes.BeforeFieldInit; /* [DF] mimick mcs behaviour */

        /* create the type builder for a top-level or nested class declaration */
        type_builder =
          if (!is_nested)
            if(empty_struct)
              TyManager._module_builder.DefineType (FullName + generic_mark_suffix, attrs, null, 1)
            else
              TyManager._module_builder.DefineType (FullName + generic_mark_suffix, attrs)
          else
          {
            def containing_builder = (DeclaringType :> TypeBuilder).GetTypeBuilder ();
            if(empty_struct)
              containing_builder.DefineNestedType (Name + generic_mark_suffix, attrs, null, 1)
            else
              containing_builder.DefineNestedType (Name + generic_mark_suffix, attrs)
          };

        // creates and store generic parameters in our StaticTyVars

        unless (typarms.IsEmpty) {
          def names = typarms.MapToArray (fun (x) { x.Name });
          def generic_parms = type_builder.DefineGenericParameters (names);
          typarms.IterI (0, fun (idx, x) {
            x.SetGenericBuilder (generic_parms [idx]);
          });
        }

        when (custom_attribute != null) {
          TyManager.contains_nemerle_specifics = true;
          type_builder.SetCustomAttribute (custom_attribute);
        }

        when (extension_patterns.Count > 0)
          TyManager.contains_nemerle_specifics = true;

        Manager.AttributeCompiler.GetPermissionSets(GlobalEnv, modifiers.custom_attrs)
          .Iter(type_builder.AddDeclarativeSecurity);

        system_type = type_builder;
      }
    }

    /**
     * Builds a Nemerle variant attribute
     */
    private make_nemerle_variant_attribute (decls : list [NC.TypeInfo]) : Emit.CustomAttributeBuilder
    {
      def names = decls.Map (fun (decl) { decl.FullName });
      Manager.AttributeCompiler.MakeEmittedAttribute (SystemTypeCache.VariantAttribute, NString.Concat (",", names))
    }


    /**
     * Builds a Nemerle type alias
     */
    private make_nemerle_type_alias_attribute (t : FixedType) : Emit.CustomAttributeBuilder
    {
      Manager.AttributeCompiler.MakeEmittedAttribute (SystemTypeCache.TypeAliasAttribute, TyCodec.EncodeType (t))
    }


    /**
     * Builds a Nemerle variant option attribute
     */
    private make_nemerle_variant_option_attribute (is_const : bool) : Emit.CustomAttributeBuilder
    {
      Manager.AttributeCompiler.MakeEmittedAttribute (if (is_const)
                             SystemTypeCache.ConstantVariantOptionAttribute
                           else
                             SystemTypeCache.VariantOptionAttribute)
    }


    /**
     * Converts Nemerle modifiers to the Framework type attributes.
     */
    private static make_type_attributes (attrs : NemerleModifiers, is_nested : bool, is_struct : bool = false) : TypeAttributes
    {
      mutable result =
        if (is_struct)
          TypeAttributes.SequentialLayout /* [DF] default struct layout is sequential */
        else
          TypeAttributes.AutoLayout;
      when (attrs %&& NemerleModifiers.Public)
        if (is_nested) result |= TypeAttributes.NestedPublic
        else result |= TypeAttributes.Public;
      when (attrs %&& NemerleModifiers.Private)
        if (is_nested) result |= TypeAttributes.NestedPrivate
        else Message.Error ("Private is not allowed for top level types");
      when (attrs %&& NemerleModifiers.Protected)
        if (is_nested) result |= TypeAttributes.NestedFamily
        else Message.Error ("Protected is not allowed for top level types");
      when (attrs %&& NemerleModifiers.Internal && is_nested)
        result |= TypeAttributes.NestedFamORAssem;
      when (attrs %&& NemerleModifiers.Abstract) result |= TypeAttributes.Abstract;
      when (attrs %&& NemerleModifiers.Sealed) result |= TypeAttributes.Sealed;
      when (attrs %&& NemerleModifiers.SpecialName) result |= TypeAttributes.SpecialName;
      when (attrs %&& NemerleModifiers.Static) result |= TypeAttributes.Abstract | TypeAttributes.Sealed;

      result
    }


    /**
     *  Set up custom attributes on members of this TypeBuilder. Compile method's bodies.
     */
    internal EmitImplementation() : void
    {
      unless (IsFinalized)
      {
        IsFinalized = true;

        foreach (m is MemberBuilder in member_list)
          m.Compile();

        unless (modifiers.IsEmpty)
        {
          modifiers.SaveCustomAttributes(this,
            fun (target, a, shouldEmit)
            {
              def valid = target %&& System.AttributeTargets.Class
                || type_builder.IsEnum && target %&& System.AttributeTargets.Enum
                || type_builder.IsInterface && target %&& System.AttributeTargets.Interface;

              if (valid)
              {
                when(shouldEmit)
                  type_builder.SetCustomAttribute (a);
                null
              }
              else if (a != null)
                "type " + ToString()
              else
                null
            })
        }

        //Message.Debug ("finalizing " + FullName);
        unless (Message.SeenError)
          this.FinalizeType();
        //Message.Debug ("finalized " + FullName);
      }
    }

    /**
     * This methods walks the class and adds field and method declarations.
     * The method implementation will be filled in a separate pass.
     */
    internal CreateEmitDeclarations() : void
    {
      // nested types are skipped here
      foreach (m is MemberBuilder in member_list)
      {
        // Message.Debug ($ "emit $m from $type_builder");
        m.CreateEmitBuilder (type_builder);
      }
    }

    /**
     * Reads the inheritance list of a class and retrieves the base
     * type and builds the array of interfaces implemented by the class.
     */
    determine_inheritance() : (System.Type * array[System.Type])
    {
      match (tydecl)
      {
        | TypeDeclaration.Enum => (SystemTypeCache.Enum, array[])
        | _ =>
          def interfaces = InterfacesToImplement().MapToArray(i => i.GetSystemType());

          if (parent_type != null)
            (parent_type.GetSystemType(), interfaces)
          else
            (null, interfaces)
      }
    }

    internal UpdateEmittedInheritance () : void
    {
      when (! reflection_inheritance_emitted) {
        reflection_inheritance_emitted = true;

        /* determine the inheritance relation for this type
           generic builders are now properly stored */
        def (extends_class, implements_interfaces) = determine_inheritance ();

        // save inheritance information in our type builder
        when (extends_class != null) {
          if (FullName.StartsWith ("Nemerle.Builtins.Array"))
            type_builder.SetParent (SystemTypeCache.Object);
          else
            type_builder.SetParent (extends_class);
        }

        foreach (inter in implements_interfaces)
          type_builder.AddInterfaceImplementation (inter);

        foreach (gp in typarms) gp.UpdateConstraints ();
      }
    }
  }

  public partial class MethodBuilder : MemberBuilder
  {
    internal override CreateEmitBuilder (tb : Emit.TypeBuilder) : void
    {
      if (MemberKind == MemberKinds.Constructor)
        CreateConstructorBuilder (tb)
      else
        CreateMethodBuilder (tb)
    }

    /**
     * Emits a method's body
     */
    internal CompileAfterTyping () : void
    {
      def setup_method (emitter) {
        // make sure type is not finalized
        def type_builder = declaring_type.GetTypeBuilder ();
        assert(type_builder != null);

        def mb = GetMethodInfo ();
        Util.cassert (mb != null, $"method builder is null for $this");

        /* update the entry point settings, if necessary */
        when (emitter._need_entry_point && Name == "Main"
          && (Manager.Options.MainClass == null
           || declaring_type.FullName == Manager.Options.MainClass
           || Manager.Options.IsMainClassAutogenerated))
        {
          def has_correct_signature ()
          {
            mb.IsStatic &&
            (ReturnType.Equals (InternalType.Int32) ||
             ReturnType.Equals (InternalType.Void)) &&
            match (fun_header.Parameters)
            {
              // workaround bug in MS PEVerify
              | [fp] =>
                fp.ty.Fix ().Equals (FixedType.Array (InternalType.String, 1))
              | [] => true
              | _ => false
            }
          }

          if (has_correct_signature ()) {
            if (declaring_type.TyparmsCount > 0 || !Header.TypeParameters.IsEmpty)
              Message.Warning (402, this.ToString () + ": an entry point cannot be generic or in a generic type");
            else
              match (emitter._entry_point) {
                | Some (exist) =>
                  Message.Error ($ "more than one entry point (Main function) "
                                 "found, e.g. types $(exist.DeclaringType) and $(mb.DeclaringType)");
                  Message.Hint ("you can use -main TypeName switch to disambiguate selection");
                | None =>
                  when (DeclaringType.TyManager._debug_emit != null)
                    DeclaringType.TyManager._debug_emit.SetUserEntryPoint (SymbolToken (1));
                  emitter._entry_point = Some (mb : MethodInfo)
              }
          }
          else
            Message.Warning (28, $"$this has the wrong signature to be an entry point");
        }

        // update the overriding relationships
        foreach ((overriddenType, overridden) in ImplementedMethods)
        {
          // Message.Debug("override " + method_info.Name + " " + overridden_info.Name + " in " + type_builder.FullName);
          when (!mb.IsPublic || Name != overridden.Name)
          {
            // VladD2: Возможно вместо declaring_type.GetMemType() надо использовать
            def overridden_info = ILEmitter.GetMethodInfo(overriddenType, overridden);
            type_builder.DefineMethodOverride(mb, overridden_info)
          }
        }
      }

  //    Message.Debug (this.ToString ());
      match (fun_header.body)
      {
        | FunBody.ILed => {}
        | _ =>
          // maybe create additional method for implementing interface method
          // (in case of co/contravariant methods)
          CreateImplementsWrapper();

          // Message.Debug (Location, $ "compile: $this");

          Util.locate(Location,
          {
            match (fun_header.body)
            {
              | FunBody.ILed | FunBody.Parsed => Util.ice (fun_header.body.GetType().ToString ())

              | FunBody.Typed when Message.SeenError =>
                // just skip it
                fun_header.body = FunBody.ILed ()

              | FunBody.Typed =>
                assign_parameter_indexes(GetMethodBase().IsStatic);
                emit_parameter_attributes();
                unless (declaring_type.IsDelegate)
                {
                  unless (MemberKind == MemberKinds.Constructor)
                    setup_method(declaring_type.TyManager);

                  declaring_type.DoBeforeFinalization2 (
                    fun()
                    {
                      // Message.Debug ($"making il generator for $meth");
                      def gen = ILEmitter (this);

                      when (Manager.Options.EmitDebug)
                        gen.SetDocument(Location);

                      gen.Run ();
                    });
                }

              | FunBody.Abstract => emit_parameter_attributes();
            }
          });

          when (Manager.Options.EarlyExit)
            Message.MaybeBailout ();
      }
    }

    static parameter_attributes (fp : TParameter) : ParameterAttributes
    {
      (match (fp.kind)
       {
        | ParmKind.Out => ParameterAttributes.Out
        | ParmKind.Ref
        | ParmKind.Normal => ParameterAttributes.None
       }
      )
      |
      (if (fp.default_value.IsSome)
         ParameterAttributes.HasDefault | ParameterAttributes.Optional
       else
         ParameterAttributes.None)
    }


    emit_parameter_attributes() : void
    {
      foreach (parm in fun_header.Parameters)
      {
        parm.modifiers.SaveCustomAttributes (declaring_type,
          fun(target, attr, shouldEmit)
          {
            if (target %&& System.AttributeTargets.Parameter)
            {
              when(shouldEmit)
                parm.builder.SetCustomAttribute (attr);
              null
            }
            else
              "parameter " + parm.name
          })
      }
    }


    /**
     * Assigns an ordinal index to each of a method's parameter
     */
    assign_parameter_indexes (is_static : bool) : void
    {
      mutable index = if (is_static) 0 else 1;

      foreach (parm in fun_header.Parameters)
      {
        parm.decl.SetParmIndex(index, is_by_ref = parm.kind != ParmKind.Normal);
        index++;
      }
    }


    /* build the parameter types array */
    param_types () : array [System.Type]
    {
      GetParameters ().MapToArray (fun (parm) { parm.GetSystemType() });
    }


    /**
     * Converts Nemerle modifiers to the CLI method attributes.
     */
    static make_method_attributes (attrs : NemerleModifiers) : MethodAttributes
    {
      mutable result = MethodAttributes.HideBySig;

      when (attrs %&& NemerleModifiers.Public)
        result |= MethodAttributes.Public;

      when (attrs %&& NemerleModifiers.Private)
        result |= MethodAttributes.Private;

      if (attrs %&& NemerleModifiers.Protected)
        if (attrs %&& NemerleModifiers.Internal)
          result |= MethodAttributes.FamORAssem;
        else
          result |= MethodAttributes.Family;
      else when (attrs %&& NemerleModifiers.Internal)
        result |= MethodAttributes.Assembly;

      when (attrs %&& NemerleModifiers.Static)
        result |= MethodAttributes.Static;

      when (attrs %&& NemerleModifiers.Override)
        result |= MethodAttributes.Virtual %| MethodAttributes.ReuseSlot;

      // when method is static, then new is only for compile-time information
      when (!(attrs %&& NemerleModifiers.Static) && attrs %&& NemerleModifiers.New && attrs %&& NemerleModifiers.Virtual)
        result |= MethodAttributes.NewSlot | MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.Abstract)
        result |= MethodAttributes.Virtual %| MethodAttributes.Abstract;

      when (attrs %&& NemerleModifiers.Virtual)
        result |= MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.Sealed)
        result |= MethodAttributes.Final %| MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.SpecialName)
        result |= MethodAttributes.SpecialName;

      result
    }

    /**
     * Adds a method builder to a type builder
     */
    CreateMethodBuilder (tb : Emit.TypeBuilder) : void
    {
      // Message.Debug ($"-- AddMethodBuilder: $meth $(Attributes) ");

      /* update the modifiers list */
      unless (ImplementedMethods.IsEmpty)
        Attributes |= NemerleModifiers.Virtual;

      def attrs = make_method_attributes (Attributes);
      def attrs =
        if (Name == ".cctor")
          attrs | MethodAttributes.RTSpecialName | MethodAttributes.SpecialName
        else
          attrs;

      /* add the method to the type builder */
      mutable pinvoke = false;

      try
      {
        if (fun_header.TypeParameters.IsEmpty) {
          def parm_types_array = param_types ();

          method_base = Manager.AttributeCompiler.CheckPInvoking (this, tb, attrs, parm_types_array);

          if (method_base == null)
            method_base = tb.DefineMethod (Name, attrs);
          else
            pinvoke = true;
        }
        else {
          method_base = tb.DefineMethod (Name, attrs);

          def names = fun_header.TypeParameters.MapToArray(_.Name);

          def generic_parms = GetMethodInfo().DefineGenericParameters (names);
          fun_header.TypeParameters.IterI(0, (idx, x) => x.SetGenericBuilder(generic_parms[idx]));
          foreach (gp in fun_header.TypeParameters)
            gp.UpdateConstraints ();
        }
      }
      catch
      {
        | e => throw System.ApplicationException (
          $"Can't define method '$Name' (attrs: $attrs) in type '$tb'.\nError: $(e.Message)", e);
      }

      GetMethodInfo().SetSignature(
        fun_header.ReturnType.GetSystemType(),
        fun_header.GetRetTypeRequiredModifiers(),
        fun_header.GetRetTypeOptionalModifiers(),
        param_types(),
        fun_header.GetParamTypeRequiredModifiers(),
        fun_header.GetParamTypeOptionalModifiers());
        
      Manager.AttributeCompiler.GetPermissionSets(Manager.CoreEnv, modifiers.custom_attrs)
        .Iter((method_base :> SRE.MethodBuilder).AddDeclarativeSecurity);

      /* add the runtime modifiers for delegate methods */
      when (DeclaringType.IsDelegate) {
        assert(!pinvoke);
        GetMethodInfo ().SetImplementationFlags (
          MethodImplAttributes.Runtime | MethodImplAttributes.Managed
        )
      }

      when (!pinvoke && (Attributes & NemerleModifiers.Extern != 0))
        Message.Error (Location, "method is marked `extern' but do not have DllImport attribute");

      // CompileTypedMethod.compile_parms (hd);

      def name_parms (pos, parms)
      {
        match (parms) {
          | [] => ()
          | (p : TParameter) :: ps =>
            p.builder = GetMethodInfo ().DefineParameter (pos, parameter_attributes (p), p.name);

            match (p.default_value) {
              | Some (TExpr.Literal (lit)) => p.builder.SetConstant (lit.AsObject (InternalType));
              | Some (e) => Util.ice ($"complex expr $e");
              | None => {}
            }
            name_parms (pos + 1, ps)
        }
      }
      name_parms (1, GetParameters ());
    }

    /**
     * Adds a constructor builder to a type builder
     */
    CreateConstructorBuilder (tb : Emit.TypeBuilder) : void
    {
      // Message.Debug ($"-- AddConstructorBuilder: $this");

      /* create the constructor builder */
      method_base =
        tb.DefineConstructor (
          make_method_attributes (Attributes) |
          MethodAttributes.RTSpecialName |
          MethodAttributes.SpecialName,
          CallingConventions.Standard,
          param_types (),
          fun_header.GetParamTypeRequiredModifiers (),
          fun_header.GetParamTypeOptionalModifiers ());

      Manager.AttributeCompiler.GetPermissionSets(Manager.CoreEnv, modifiers.custom_attrs)
        .Iter((method_base :> SRE.ConstructorBuilder).AddDeclarativeSecurity);

      /* add the runtime modifiers for delegate constructors */
      when (DeclaringType.IsDelegate) {
        GetConstructorInfo ().SetImplementationFlags (
          MethodImplAttributes.Runtime | MethodImplAttributes.Managed
        )
      }

      def name_parms (pos, parms)
      {
        match (parms) {
          | [] => ()
          | (p : TParameter) :: ps =>
            p.builder = GetConstructorInfo ().DefineParameter (pos, parameter_attributes (p), p.name);

            match (p.default_value) {
              | Some (TExpr.Literal (lit)) => p.builder.SetConstant (lit.AsObject (InternalType));
              | Some (e) => Util.ice ($"complex expr $e");
              | None => ()
            }
            name_parms (pos + 1, ps)
        }
      }
      name_parms (1, GetParameters ());
    }

    internal override Compile () : void
    {
      try
      {
        base.Compile ();
        RunBodyTyper ();

        when(_isConditional)
          Manager.AttributeCompiler.CheckConditional(this);

        unless (modifiers.IsEmpty)
        {
          def adder =
            if (MemberKind == MemberKinds.Constructor)
              fun (target, attribute, shouldEmit)
              {
                if (target %&& System.AttributeTargets.Constructor)
                {
                  when(shouldEmit)
                    GetConstructorInfo ().SetCustomAttribute (attribute);
                  null
                }
                else if (attribute != null)
                  "constructor " + ToString ()
                else
                  null
              }
            else
              fun (target, attribute, shouldEmit)
              {
                if (target %&& System.AttributeTargets.Method)
                {
                  when(shouldEmit)
                    GetMethodInfo ().SetCustomAttribute (attribute);
                  null
                }
                else if (attribute != null)
                  "method " + ToString ()
                else
                  null
              };

          modifiers.SaveCustomAttributes (declaring_type, adder);
        }

        unless(return_value_modifiers.IsEmpty)
        {
          return_value_modifiers.SaveCustomAttributes(declaring_type,
            fun (target, attribute, shouldEmit)
            {
              if (target %&& System.AttributeTargets.ReturnValue)
              {
                when(shouldEmit)
                {
                  def ret = GetMethodInfo ().DefineParameter (0, ParameterAttributes.None, null);
                  ret.SetCustomAttribute (attribute);
                }
                null
              }
              else if (attribute != null)
                "method " + ToString ()
              else
                null
            });
        }

        CompileAfterTyping()
      }
      catch { | _ is Typer.IllegalYieldReturnType => () }
    }
  }

  public partial class FieldBuilder : MemberBuilder
  {
    /**
     * Adds a field builder
     */
    internal override CreateEmitBuilder (tb : Emit.TypeBuilder) : void
    {
      // Converts Nemerle modifiers to the CLI field attributes.
      def make_field_attributes (attrs)
      {
        mutable result = FieldAttributes.PrivateScope;

        when (attrs %&& NemerleModifiers.Public) result |= FieldAttributes.Public;
        when (attrs %&& NemerleModifiers.Private) result |= FieldAttributes.Private;

        if (attrs %&& NemerleModifiers.Internal)
          if (attrs %&& NemerleModifiers.Protected)
            result |= FieldAttributes.FamORAssem;
          else
            result |= FieldAttributes.Assembly
        else
          when (attrs %&& NemerleModifiers.Protected)
            result |= FieldAttributes.Family;

        when (attrs %&& NemerleModifiers.Static) result |= FieldAttributes.Static;
        when (attrs %&& NemerleModifiers.SpecialName) result |= FieldAttributes.SpecialName %|
            FieldAttributes.RTSpecialName;

        unless (attrs %&& (NemerleModifiers.Mutable | NemerleModifiers.CompilerMutable))
          result |= FieldAttributes.InitOnly;

        result
      }

      mutable attrs = make_field_attributes (Attributes);

      when (IsLiteral) {
        attrs |= FieldAttributes.Literal;
        attrs &= ~FieldAttributes.InitOnly;
      }

      // prevent verification failure
      when (Name != "value__")
        attrs &= ~FieldAttributes.RTSpecialName;

      field_builder = tb.DefineField (
        Name,
        GetMemType ().GetSystemType (),
        required_modifiers.ToArray (),
        optional_modifiers.ToArray (),
        attrs);

      when (IsLiteral)
        field_builder.SetConstant (const_value.AsObject (InternalType));
    }

    internal override Compile () : void
    {
      base.Compile ();
      unless (modifiers.IsEmpty) {
        modifiers.SaveCustomAttributes (declaring_type, fun (target, a, shouldEmit) {
          if (target %&& System.AttributeTargets.Field) {
            when(shouldEmit)
              field_builder.SetCustomAttribute (a);
            null
          }
          else "field " + ToString ()
        });
      }

      when (IsVolatile) {
        def volatile_attr = Manager.AttributeCompiler.MakeEmittedAttribute (SystemTypeCache.VolatileModifier);
        field_builder.SetCustomAttribute (volatile_attr)
      }

      when (!IsMutable && !IsLiteral && attributes %&& NemerleModifiers.CompilerMutable)
      {
        def imm_attr = Manager.AttributeCompiler.MakeEmittedAttribute (SystemTypeCache.ImmutableAttribute);
        field_builder.SetCustomAttribute (imm_attr)
      }
    }
  }

  public partial class PropertyBuilder : MemberBuilder, IProperty
  {
    /**
     * Adds a property builder
     */
    internal override CreateEmitBuilder (tb : Emit.TypeBuilder) : void
    {
      // Converts Nemerle modifiers to the CLI property attributes.
      def make_property_attributes (attrs)
      {
        mutable result = PropertyAttributes.None;

        when (attrs %&& NemerleModifiers.SpecialName)
          result |= PropertyAttributes.SpecialName %| PropertyAttributes.RTSpecialName;

        result
      }

      def attrs = make_property_attributes (Attributes);
      def ty = if (IsIndexer) (GetMemType () :> FixedType.Fun).to.GetSystemType () else GetMemType ().GetSystemType ();
      def parms = parms.MapToArray (_.GetSystemType ());

      def (ret_type_req_mods, ret_type_opt_mods) = {
        def getter = GetGetter ();

        if (getter == null)
          (null, null)
        else
          ( (getter :> MethodBuilder).Header.GetRetTypeRequiredModifiers (),
            (getter :> MethodBuilder).Header.GetRetTypeOptionalModifiers () )
      }

      def (param_type_req_mods, param_type_opt_mods) = {
        def setter = GetSetter () :> MethodBuilder;

        if (setter == null)
          (null, null)
        else
        {
          def chop (a) { if (a == null) null else a.ChopLastN (1) }
          ( chop (setter.Header.GetParamTypeRequiredModifiers ()),
            chop (setter.Header.GetParamTypeOptionalModifiers ()) )
        }
      }

      property_builder = tb.DefineProperty (
        Name,
        attrs,
        ty,
        ret_type_req_mods,
        ret_type_opt_mods,
        parms,
        param_type_req_mods,
        param_type_opt_mods);
    }

    internal override Compile () : void
    {
      base.Compile ();
      unless (modifiers.IsEmpty) {
        modifiers.SaveCustomAttributes (declaring_type, fun (target, a, shouldEmit) {
          if (target %&& System.AttributeTargets.Property) {
            when(shouldEmit)
              property_builder.SetCustomAttribute (a);
            null
          }
          else "property " + ToString ()
        })
      }

      def declaring = DeclaringType : object;

      // emit getter only if it was defined in this type, not derived
      when (getter != null && getter.DeclaringType == declaring)
        property_builder.SetGetMethod (getter.GetMethodInfo ());

      // emit setter only if it was defined in this type, not derived
      when (setter != null && setter.DeclaringType == declaring)
        property_builder.SetSetMethod (setter.GetMethodInfo ());
    }
  }

  public partial class EventBuilder : MemberBuilder, IEvent
  {
    /**
     * Adds an event builder
     */
    internal override CreateEmitBuilder (tb : Emit.TypeBuilder) : void
    {
      def ty = GetMemType ().GetSystemType ();
      event_builder = tb.DefineEvent (Name, EventAttributes.None, ty);
    }

    internal override Compile () : void
    {
      base.Compile ();
      unless (modifiers.IsEmpty) {
        modifiers.SaveCustomAttributes (declaring_type, fun (target, a, shouldEmit) {
          if (target %&& System.AttributeTargets.Event) {
            when(shouldEmit)
              event_builder.SetCustomAttribute (a);
            null
          }
          else "event " + ToString ()
        });
      }

      event_builder.SetAddOnMethod (adder.GetMethodInfo ());
      event_builder.SetRemoveOnMethod (remover.GetMethodInfo ());
    }
  }
}
