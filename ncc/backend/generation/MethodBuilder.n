using Nemerle.Compiler.Backend;
using Nemerle.Compiler.Typedtree;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Utility;

using System.IO;
using System.Diagnostics.SymbolStore;
using System.Diagnostics;

using DN = dnlib.DotNet;
using NC = Nemerle.Compiler;
using MethodAttributes = dnlib.DotNet.MethodAttributes;

namespace Nemerle.Compiler
{
  public partial class MethodBuilder : IBackendMember, IBackendMethod
  {
    mutable method_base : DN.MethodDef;

    public GetMethodBuilder() : DN.MethodDef
      implements IBackendMember.GetHandle, IBackendMethod.get_MethodRef, IBackendMethod.get_MethodDef
    {
      assert(method_base != null);
      method_base
    }

    /**
     * Emits a method's body
     */
    internal CompileAfterTyping () : void
    {
      when (SkipEmiting)
        return;

      def setup_method(emitter)
      {
        def mb = GetMethodBuilder();

        /* update the entry point settings, if necessary */
        when (emitter._need_entry_point && Name == "Main"
          && (Manager.Options.MainClass == null
           || declaring_type.FullName == Manager.Options.MainClass
           || Manager.Options.IsMainClassAutogenerated))
        {
          def has_correct_signature ()
          {
            mb.IsStatic &&
            (ReturnType.Equals(InternalType.Int32) ||
             ReturnType.Equals(InternalType.Void)) &&
            match (Header.Parameters)
            {
              // workaround bug in MS PEVerify
              | [fp] =>
                fp.ty.Fix ().Equals (FixedType.Array (InternalType.String, 1))
              | [] => true
              | _ => false
            }
          }

          if (has_correct_signature ()) {
            if (declaring_type.TyparmsCount > 0 || !Header.TypeParameters.IsEmpty)
              Message.Warning (402, this.ToString () + ": an entry point cannot be generic or in a generic type");
            else
              match (emitter._entry_point) {
                | Some (exist) =>
                  Message.Error ($ "more than one entry point (Main function) "
                                 "found, e.g. types $(exist.DeclaringType) and $(mb.DeclaringType)");
                  Message.Hint ("you can use -main TypeName switch to disambiguate selection");
                | None =>
                  def moduleBuilder = DeclaringType.TyManager.GetModuleBuilder();
                  when (moduleBuilder.PdbState != null)
                    moduleBuilder.PdbState.UserEntryPoint = mb;
                  emitter._entry_point = Some(mb)
              }
          }
          else
            Message.Warning (28, $"$this has the wrong signature to be an entry point");
        }

        // update the overriding relationships
        foreach ((overriddenType, overridden) in ImplementedMethods)
        {
          // Message.Debug("override " + method_info.Name + " " + overridden_info.Name + " in " + type_builder.FullName);
          when (!mb.IsPublic || Name != overridden.Name)
          {
            def methodRef = overriddenType.GetMethodInfo(overridden, []) :> DN.IMethodDefOrRef;
            mb.Overrides.Add(DN.MethodOverride(mb, methodRef));
          }
        }
      }

  //    Message.Debug (this.ToString ());
      match (Header.body)
      {
        | FunBody.ILed => {}
        | _ =>
          // maybe create additional method for implementing interface method
          // (in case of co/contravariant methods)
          CreateImplementsWrapper();

          // Message.Debug (Location, $ "compile: $this");

          Util.locate(Location,
          {
            match (Header.body)
            {
              | FunBody.ILed | FunBody.Parsed => Util.ice(Header.body.GetType().ToString ())

              | FunBody.Typed when Message.SeenError =>
                // just skip it
                Header.body = FunBody.ILed ()

              | FunBody.Typed =>
                assign_parameter_indexes();
                emit_parameter_attributes();
                // TODO: sometimes macros create abstract methods with {} body
                when (!declaring_type.IsDelegate && !IsAbstract)
                {
                  unless (MemberKind == MemberKinds.Constructor)
                    setup_method(declaring_type.TyManager);

                  declaring_type.DoBeforeFinalization2 (
                    fun()
                    {
                      // Message.Debug ($"making il generator for $meth");
                      def gen = ILEmitter (this);

                      when (Manager.Options.EmitDebug)
                        gen.SetDocument(Location);

                      gen.Run ();
                    });
                }

              | FunBody.Abstract => emit_parameter_attributes();
            }
          });

          when (Manager.Options.EarlyExit)
            Message.MaybeBailout ();
      }
    }

    static parameter_attributes (fp : TParameter) : DN.ParamAttributes
    {
      if (fp.default_value.IsSome)
        DN.ParamAttributes.HasDefault | DN.ParamAttributes.Optional
      else
        0 :> DN.ParamAttributes
    }

    emit_parameter_attributes() : void
    {
      foreach (parm in Header.Parameters)
      {
        parm.modifiers.SaveCustomAttributes (declaring_type,
          fun(target, attr, shouldEmit)
          {
            if (target %&& System.AttributeTargets.Parameter)
            {
              when (shouldEmit)
              {
                Util.cassert(parm.builder != null);
                match (attr.TypeFullName)
                {
                  | "System.Runtime.InteropServices.InAttribute" when parm.Kind == ParmKind.Out =>
                    return "parameter " + parm.name;

                  | "System.Runtime.InteropServices.InAttribute"  => parm.builder.Attributes |= DN.ParamAttributes.In
                  | "System.Runtime.InteropServices.OutAttribute" => parm.builder.Attributes |= DN.ParamAttributes.Out
                  | _ => parm.builder.CustomAttributes.Add(attr)
                }
              }
              null
            }
            else
              "parameter " + parm.name
          })
      }
    }

    /**
     * Assigns an ordinal index to each of a method's parameter
     */
    assign_parameter_indexes() : void
    {
      def paramList = method_base.Parameters;
      mutable parameterIndex = paramList.MethodSigIndexBase;
      foreach (p in Header.Parameters)
      {
        p.decl.Parameter = paramList[parameterIndex];
        ++parameterIndex;
      }
    }

    /**
     * Converts Nemerle modifiers to the CLI method attributes.
     */
    make_method_attributes (attrs : NemerleModifiers) : MethodAttributes
    {
      mutable result = MethodAttributes.HideBySig;

      when (attrs %&& NemerleModifiers.Public)
        result |= MethodAttributes.Public;

      when (attrs %&& NemerleModifiers.Private)
        result |= MethodAttributes.Private;

      if (attrs %&& NemerleModifiers.Protected)
        if (attrs %&& NemerleModifiers.Internal)
          result |= MethodAttributes.FamORAssem;
        else
          result |= MethodAttributes.Family;
      else when (attrs %&& NemerleModifiers.Internal)
        result |= MethodAttributes.Assembly;

      when (attrs %&& NemerleModifiers.Static)
        result |= MethodAttributes.Static;

      when (attrs %&& NemerleModifiers.Override)
        result |= MethodAttributes.Virtual %| MethodAttributes.ReuseSlot;

      // when method is static, then new is only for compile-time information
      when (!(attrs %&& NemerleModifiers.Static) && attrs %&& NemerleModifiers.New && attrs %&& NemerleModifiers.Virtual)
        result |= MethodAttributes.NewSlot | MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.Abstract)
        result |= MethodAttributes.Virtual %| MethodAttributes.Abstract;

      when (attrs %&& NemerleModifiers.Virtual)
        result |= MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.Sealed)
        result |= MethodAttributes.Final %| MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.SpecialName)
        result |= MethodAttributes.SpecialName;

      when (Name == ".cctor" || Name == ".ctor")
        result |= MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;

      result
    }

    /**
     * Adds a method builder to a type builder
     */
    internal override CreateEmitBuilder(tb : DN.TypeDef) : void
    {
      when (SkipEmiting)
        return;

      // Message.Debug ($"-- AddMethodBuilder: $meth $(Attributes) ");

      /* update the modifiers list */
      unless (ImplementedMethods.IsEmpty)
        Attributes |= NemerleModifiers.Virtual;

      def attrs = make_method_attributes (Attributes);

      /* add the method to the type builder */

      method_base = DN.MethodDefUser(Name, null, attrs);
      tb.Methods.Add(method_base);

      foreach (t in Header.TypeParameters with index)
      {
        def gp = DN.GenericParamUser(index :> ushort, DN.GenericParamAttributes.NonVariant, t.Name);
        method_base.GenericParameters.Add(gp);
        t.SetGenericBuilder(gp);
      }

      foreach (t in Header.TypeParameters)
        t.UpdateConstraints();

      mutable callconv = if (IsStatic) DN.CallingConvention.Default else DN.CallingConvention.HasThis;
      unless (Header.TypeParameters.IsEmpty)
        callconv |= DN.CallingConvention.Generic;

      def retType    = Header.ReturnType.ToTypeSig();
      def paramTypes = Header.Parameters.MapToArray(p => p.Type.ToTypeSig());
      method_base.MethodSig = DN.MethodSig(callconv, Header.TypeParameters.Length :> uint, retType, paramTypes);
      method_base.Parameters.UpdateParameterTypes();

      def pinvoke = Manager.AttributeCompiler.CheckPInvoking(this);

      foreach (pair in Manager.AttributeCompiler.GetPermissionSets(Manager.CoreEnv, modifiers.custom_attrs))
      {
        def declSecurity = DN.DeclSecurityUser(pair.Key, pair.Value);
        method_base.DeclSecurities.Add(declSecurity);
        method_base.HasSecurity = true;
      }

      /* add the runtime modifiers for delegate methods */
      when (DeclaringType.IsDelegate)
      {
        assert(!pinvoke);
        method_base.ImplAttributes |= DN.MethodImplAttributes.Runtime | DN.MethodImplAttributes.Managed;
      }

      when (!pinvoke && (Attributes & NemerleModifiers.Extern != 0))
        Message.Error (Location, "method is marked `extern' but do not have DllImport attribute");

      mutable sequence;
      unless (return_value_modifiers.IsEmpty)
      {
        def returnDef = DN.ParamDefUser(DN.UTF8String.Empty, sequence, DN.ParamAttributes.Retval);
        method_base.ParamDefs.Add(returnDef);
      }

      foreach (p in Header.Parameters)
      {
        ++sequence;
        p.builder = DN.ParamDefUser(p.Name, sequence, parameter_attributes(p));
        method_base.ParamDefs.Add(p.builder);

        match (p.default_value)
        {
          | Some(TExpr.Literal(lit)) => 
            def defaultValue = lit.AsObject(InternalType);
            def type = p.Type.Fix();
            when (defaultValue != null || !type.IsValueType)
              p.builder.Constant = DN.ConstantUser(defaultValue);

          | Some(e) => Util.ice($"complex expr $e");
          | None => {}
        }
      }
    }

    internal override Compile () : void
    {
      try
      {
        base.Compile ();
        RunBodyTyper ();

        when (SkipEmiting)
          return;

        when(_isConditional)
          Manager.AttributeCompiler.CheckConditional(this);

        unless (modifiers.IsEmpty)
        {
          def (mask, prefix) =
            if (MemberKind == MemberKinds.Constructor)
              (System.AttributeTargets.Constructor, "constructor ")
            else
              (System.AttributeTargets.Method, "method ");

          modifiers.SaveCustomAttributes (declaring_type,
            fun (target, attribute, shouldEmit)
            {
              if (target %&& mask)
              {
                when (shouldEmit)
                {
                  if (attribute.TypeFullName == "System.Runtime.CompilerServices.MethodImplAttribute")
                  {
                    def flags = System.Convert.ToInt32(attribute.ConstructorArguments[0].Value) :> DN.MethodImplAttributes;
                    GetMethodBuilder().ImplAttributes |= flags;
                  }
                  else
                    GetMethodBuilder().CustomAttributes.Add(attribute);
                }
                null
              }
              else if (attribute != null)
                prefix + ToString ()
              else
                null
            });
        }

        unless (return_value_modifiers.IsEmpty)
        {
          return_value_modifiers.SaveCustomAttributes(declaring_type,
            fun (target, attribute, shouldEmit)
            {
              if (target %&& System.AttributeTargets.ReturnValue)
              {
                when(shouldEmit)
                {
                  def returnParameter = GetMethodBuilder().Parameters.ReturnParameter;
                  Util.cassert(returnParameter.HasParamDef);
                  returnParameter.ParamDef.CustomAttributes.Add(attribute);
                }
                null
              }
              else if (attribute != null)
                "method " + ToString ()
              else
                null
            });
        }

        CompileAfterTyping()
      }
      catch { | _ is Typer.IllegalYieldReturnType => () }
    }
  }
}
