/*
 * Copyright (c) 2003-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Utility;
using Nemerle.Assertions;
using Obsolete = System.ObsoleteAttribute;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;
using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler.Typedtree
{
  public variant TypeDeclaration
  {
    | Class
    | Alias         { ty : FixedType; }
    | Interface
    | Variant       { members : list [TypeInfo]; }
    | VariantOption
    | Enum

    public override ToString() : string
    {
      match (this)
      {
        | Class         => "class or struct"
        | Alias(null)   => "NOT BINDED ALIAS"
        | Alias(ty)     => $"alias of '$ty'"
        | Interface     => "interface"
        | Variant       => "variant"
        | VariantOption => "variant option"
        | Enum          => "enum"
      }
    }
  }

  // PParameter
  public class TParameter : TypedBase
  {
    public AttributesAndModifiers : AttributesAndModifiers  { get { modifiers } }
    public Modifiers              : NemerleModifiers        { get { modifiers.Modifiers } }
    public CustomAttributes       : list[Parsetree.PExpr]   { get { modifiers.CustomAttributes } }
    public Name                   : string                  { get { name } }
    public NameLocation           : Location                { get; private set; }
    public Type                   : TypeVar                 { get { ty } }
    public TypeLocation           : Location                { get { ty_loc } set { ty_loc = value; } }
    public Color                  : int                     { get { color } }
    public Kind                   : ParmKind                { get { kind } }
    public DefaultValue           : option[TExpr]           { get { default_value } }
    public Declaration            : LocalValue              { get { decl } }
    public PatternHack            : PExpr                   { get; set; }
    public HasDefaultValue        : bool                    { get { default_value.IsSome } }


    public name           : string;
    public color          : int;
    public mutable ty     : TypeVar;

    public mutable ty_loc : Location;
    public kind           : ParmKind;
    public modifiers      : AttributesAndModifiers;
    public mutable required_modifiers : list[System.Type] = [];
    public mutable optional_modifiers : list[System.Type] = [];

    public mutable default_value : option [TExpr] = None ();

    public mutable decl : LocalValue;
    public mutable builder : System.Reflection.Emit.ParameterBuilder;

    public this (loc : Location, name : string, nameLocation : Location,
                 color : int, ty : TypeVar, typeLocation : Location,
                 modifiers : AttributesAndModifiers, kind : ParmKind, patternHack : PExpr = null)
    {
      base (loc);

      this.name         = name;
      this.NameLocation = nameLocation;
      this.color        = color;
      this.ty           = ty;
      this.ty_loc       = typeLocation;
      this.modifiers    = modifiers;
      this.kind         = kind;
      PatternHack       = patternHack;
    }

    public this (name : string, color : int, ty : TypeVar, modifiers : AttributesAndModifiers, kind : ParmKind)
    {
      this.name = name;
      this.color = color;
      this.ty = ty;
      this.modifiers = modifiers;
      this.kind = kind;
    }

    public Clone () : TParameter
    {
      MemberwiseClone () :> TParameter
    }

    public GetSystemType() : System.Type
    {
      ty.Fix ().GetSystemType ();
    }

    public GetParsedName() : PT.Name
    {
      PT.Name(name, NameLocation, color, ty.Manager.CoreEnv, name)
    }

    public AsParsed () : PT.PParameter
    {
      def name3 = PT.Splicable.Name(NameLocation, GetParsedName());
      def ty2 = PExpr.TypedType(ty_loc, ty);
      PT.PParameter(Location, name3, ty2, modifiers.Clone(), PatternHack);
    }

    public ReferencingExpr : PExpr
    {
      get { PExpr.Ref (Parsetree.Name (name, color, ty.Manager.CoreEnv)) }
    }

    public DefaultValueAsTExpr(solver : Solver) : TExpr
    {
      match (default_value)
      {
        | Some(TExpr.Literal(Literal.Null) as lit) => Typedtree.TExpr.DefaultValue(lit.Location, solver.FreshTypeVar())
        | Some(e) => e
        | None    => Util.ice ("there is no default value for: " + ToString ())
      }
    }

    internal GetLocalDefaultValueFromModifiers (par : Typer) : void
    {
     // store default value attribute
       foreach (<[ System.ComponentModel.DefaultValueAttribute($e) ]> in modifiers.custom_attrs)
       {
         when (default_value.IsSome)
           Message.Error (e.Location,
                          $ "default value specified twice for parameter "
                            "`$name'");
         GetLocalDefaultValueFromExpr(par, Some(e));
       }
     }
     
    internal GetLocalDefaultValueFromExpr (par : Typer, expr : option[PExpr]) : void
    {
      default_value = expr.Map(x => par.TypeExpr(x, Typer.AtLeast(ty)));
    }

    internal GetDefaultValueFromModifiers(par : TypeBuilder, tenv : TypeVarEnv) : void
    {
      // store default value attribute
      foreach (<[ System.ComponentModel.DefaultValueAttribute($e) ]> in modifiers.custom_attrs) 
        GetDefaultValueFromExpr(par, tenv, e);
    }
   
    internal GetDefaultValueFromExpr(par : TypeBuilder, tenv : TypeVarEnv, expr : PExpr) : void
    {
      // store default value attribute
        def (provided_val, typeDefault) =
          match (ConstantFolder.FoldConstants (par, expr))
          {
            | <[ $x : $t ]>    => ty = par.BindType(t); (x, false)
            | <[ default(_) ]>  =>
              when (ty == null || !ty.IsFixed)
                Message.Error(expr.Location, "You can use default(_) only for parameters which type was explicitly specified.");
               (<[ null ]>, true)

            | <[ default($t) ]> =>
              if (ty == null)
                ty = par.BindType(tenv, t);
              else
                _ = ty.Unify(par.BindType(tenv, t));

              (<[ null ]>, true)

            | x => (x, false)
          };

        match (provided_val)
        {
          | PExpr.Literal(lit) =>
            when (lit is Literal.Decimal)
              Message.Error(expr.Location, $"only `null' is allowed for default value of type `decimal' (parameter `$name')");
            when (lit is Literal.Void)
              Message.Error(expr.Location, $"the void literal is not allowed for default value of parameter `$name'");
            when (default_value.IsSome)
              Message.Error(expr.Location, $"default value specified twice for parameter `$name'");
            when (ty == null && lit is Literal.Null)
              Message.Error(expr.Location, $"type inference not supported when default value is null (parameter `$name')");

            def ok =
              if (ty == null)
              {
                ty = lit.GetInternalType(par.Manager.InternalType);
                true
              }
              else if (typeDefault)
                true
              else if (ty.IsFixed)
                Typer.LiteralConversionPossible(lit, ty.FixedValue)
              else
                ty.Provide(lit.GetInternalType(par.Manager.InternalType));

            unless (ok)
              Message.Error (expr.Location, $"invalid type for default value of parameter `$name', needed $ty, got $lit");

            def lit =
              if (ok && ty.IsFixed && !typeDefault)
                match (lit.WithType (ty.FixedValue))
                {
                  | Some (lit) => lit
                  | None =>
                    // ice?
                    Message.Error (expr.Location, $"cannot convert $lit to $ty");
                    lit
                }
              else lit;

            default_value = Some (TExpr.Literal (Typer.TypeOfLiteral (par.Manager, lit), lit));

          | _ => Message.Error (expr.Location, $"Incorrect format of parameter `$name' default value. You should use 'paramName = <literal>'");
        }
      modifiers.custom_attrs =
        modifiers.custom_attrs.Filter(x => !(x is <[ System.ComponentModel.DefaultValueAttribute($_) ]>));
        
    }

    public override ToString () : string
    {
      $ "$name : $ty"
    }
  }

  public enum FunctionUsage
  {
    | NotUsed
    | UsedJustOnce
    | Used
    | UsedAsFirstClass
  }

  public class TFunHeader : TypedBase, System.IComparable [TFunHeader], Parsetree.IParametersProvider
  {
    public Name               : string              { get; internal set; }
    public ReturnType         : TypeVar             { get; internal set; }
    public ReturnTypeLocation : Location            { get; internal set; }
    public Parameters         : list[TParameter]    { get; internal set; }
    public TypeParameters     : list[StaticTypeVar] { get; internal set; }
    public TypeVarEnv         : TypeVarEnv          { get { tenv } }
    public Body               : FunBody             { get { body } }
    public ClosureVars        : list [LocalValue]   { get { closure_vars } }
    public Declaration        : LocalValue          { get { decl } }
    public Parsed             : PT.Function_decl    { get; set; };
    
    [Obsolete("Use ReturnTypeLocation instead of RetTypeLoc")]
    public RetTypeLoc         : Location            { get { ReturnTypeLocation } }
    [Obsolete("Use ReturnType instead of RetType")]
    public RetType            : TypeVar             { get { ReturnType } }
    

    [Obsolete("Use Name instead of name")]
    public name         : string          { get { Name } }
    public         id           : int;
    [Obsolete("Use ReturnType instead of ret_type")]
    public ret_type     : TypeVar                 { get { ReturnType } }
    [Obsolete("Use ReturnTypeLocation instead of ret_type_loc")]
    public ret_type_loc : Location                { get { ReturnTypeLocation } }
    [Obsolete("Use Parameters instead of parms")]
    public parms                : list [TParameter] { get { Parameters } }
    [Obsolete("Use TypeParameters instead of typarms")]
    public typarms      : list [StaticTypeVar] { get { TypeParameters } }
    public         tenv         : TypeVarEnv;
    public mutable ret_type_required_modifiers : list[System.Type] = [];
    public mutable ret_type_optional_modifiers : list[System.Type] = [];

    public mutable usage : FunctionUsage;
    public mutable body : FunBody;
    public mutable has_1st_class_child : bool;
    public mutable cannot_inline : bool;

    /// local values defined in this function, which are closurised (used by children)
    public mutable closure_vars : list [LocalValue] = [];
    /// local value, which is declaring this function (valid for local funs)
    public mutable decl : LocalValue;
    public mutable all_locals : list [LocalValue] = [];
    internal mutable children_funs : list [TFunHeader] = [];
    internal mutable uses_try_block : bool;
    internal mutable yield_type : TypeVar;
    internal mutable is_in_closure_of : int;

    // FIXME: move to hashtables in t3
    internal mutable used_closures : list [TFunHeader];
    internal mutable static_method : IMethod;
    internal mutable typarms_to_pass : list[TypeVar]; 
    internal mutable closure_type : FixedType.Class;
    // end

    public this (loc          : Location,
                 name         : string,
       [NotNull] ret_type     : TypeVar,
                 ret_type_loc : Location,
                 parms        : list[TParameter],
                 typarms      : list[StaticTypeVar],
                 tenv         : TypeVarEnv)
    {
      base (loc);

      this.Name               = name;
      this.ReturnType         = ret_type;
      this.ReturnTypeLocation = ret_type_loc;
      this.Parameters         = parms;
      this.TypeParameters     = typarms;
      this.tenv               = tenv;

      id = Util.next_id(ret_type.Manager);
      usage = FunctionUsage.NotUsed;
    }

    public Reset() : void
    {
      body                = null;
      has_1st_class_child = false;
      cannot_inline       = false;
      closure_vars        = [];
      decl                = null;
      all_locals          = [];
      children_funs       = [];
      uses_try_block      = false;
      yield_type          = null;
      is_in_closure_of    = 0;
      used_closures       = null;
      static_method       = null;
      typarms_to_pass     = null;
      closure_type        = null;
    }

    public CompareTo (other : TFunHeader) : int
    {
      id - other.id
    }

    /**
     *  Retrieves functions in which current function is nested. Empty list if
     *  this is a plain method of some class.
     */
    public GetParents () : list [TFunHeader]
    {
      if (decl != null)
        match (decl.ValKind) {
          | LocalValue.Kind.Function (_, pars) => pars
          | _ => Util.ice ("invalid value kind for function")
        }
      else []
    }

    public override ToString () : string
    {
      $"$Name(..$Parameters) : $ReturnType"
    }

    public GetRetTypeRequiredModifiers () : array [System.Type]
    {
      ret_type_required_modifiers.ToArray ()
    }

    public GetRetTypeOptionalModifiers () : array [System.Type]
    {
      ret_type_optional_modifiers.ToArray ()
    }

    public GetParamTypeRequiredModifiers () : array [array [System.Type]]
    {
      mutable mods = [];

      foreach (p in Parameters)
        if (p.required_modifiers.IsEmpty)
          mods ::= null;
        else
          mods ::= p.required_modifiers.ToArray ();

      if (mods.ForAll (fun (x) { x == null }) )
        null
      else
        mods.Reverse ().ToArray ()
    }

    public GetParamTypeOptionalModifiers () : array [array [System.Type]]
    {
      mutable mods = [];

      foreach (p in Parameters)
        if (p.optional_modifiers.IsEmpty)
          mods ::= null;
        else
          mods ::= p.optional_modifiers.ToArray ();

      if (mods.ForAll (fun (x) { x == null }) )
        null
      else
        mods.Reverse ().ToArray ()
    }

    public ParametersDeclarations : list [Parsetree.PParameter]
    {
      get { Parameters.Map(_.AsParsed ())  }
    }

    public ParametersReferences : list [PExpr]
    {
      get { Parameters.Map(_.ReferencingExpr) }
    }

    public CreateAliasMethod(mods : NemerleModifiers, obj : PExpr, custom_subst : Subst) : Parsetree.ClassMember
    {
      def attrs = AttributesAndModifiers(mods, []);

      def parse_tr = <[ decl:
        ..$attrs $(this.Name : usesite) (..$(this.ParametersDeclarations)) : $(this.ReturnType : typed)
        {}
      ]>;
      parse_tr.header.TypeParameters = Parsetree.CopyTypedTyparms(this.TypeParameters, custom_subst);
      def tyargs = parse_tr.header.TypeParameters.ExistingTyvars.Map (x => <[ $(FixedType.StaticTypeVarRef (x) : typed) ]>);
      parse_tr.Body = <[ $obj.$(this.Name : usesite) .[..$tyargs] (..$(this.ParametersReferences)) ]>;
      parse_tr
    }
  }


  [Record]
  public variant Pattern : TypedBase
  {
    | Wildcard
    | As          { pat : Pattern; decl : LocalValue; }
    | HasType     { typ : FixedType; }
    | Tuple       { args : list [Pattern]; }
    | Record      { args : list [IMember * Pattern]; }
    | Application { name : TypeInfo; arg : Pattern; }
    | Enum        { fld : IField; val : Nemerle.Compiler.Literal; }
    | Literal     { lit : Nemerle.Compiler.Literal; }
    | Error

    public mutable ty : TypeVar;

    public this () { }
    public this (loc : Location) { base(loc) }

    public GetSystemType () : System.Type
    {
      Util.cassert (ty != null);
      ty.GetSystemType ()
    }

    public Type : TypeVar
    {
      get {
        Util.cassert (ty != null);
        ty
      }
    }

    public StripEnums () : Pattern
    {
      Walk(fun (_) {
        | Enum (_, l) => Literal (l)
        | _ => null
      })
    }


    /** Walk [this] with the function [f].

        The function is applied to each and every pattern node.

        If [f] returns a value different than [null], the value is
        returned, from this [Walk] function.

        If it returns [null], the walking function descends into tree
        elements in a map-like fashion.

        If the type of pattern returned was to be [null], it is set to
        the type of the original pattern.

        This function implements the visitor pattern.  */
    public Walk(f : Pattern -> Pattern) : Pattern
    {
      def do_walk (pat)
      {
        | Enum
        | Pattern.Literal
        | Error
        | HasType
        | Wildcard => pat

        | As (p, decl) =>
          As (pat.Location, walk (p), decl)

        | Tuple (args) =>
          Tuple (pat.Location, args.Map (walk))

        | Record (args) =>
          Record (pat.Location, args.Map (fun (f, p) { (f, walk (p)) }))

        | Application (c, a) => Application (pat.Location, c, walk (a))
      }
      and walk (pat)
      {
        def res = Util.locate (pat.Location, {
          def res = f (pat);
          if (res == null) do_walk (pat) else res;
        });
        when (res.ty == null)
          res.ty = pat.ty;
        res
      }

      walk (this)
    }


    public override ToString () : string { PrettyPrint.SprintPattern (this) }
  }

  [Record]
  public variant Try_case : TypedBase
  {
    | Fault { handler : TExpr; }
    | Catch { exn : LocalValue; handler : TExpr; }
    | Filter { exn : LocalValue; filter : TExpr; handler : TExpr; }
  }

  [Record]
  public class Match_case : TypedBase
  {
    public mutable patterns : list [Pattern * TExpr * list [LocalValue * TExpr]];
    public mutable body : TExpr;
    public mutable disable_warnings : bool;
  }

  public variant ConversionKind
  {
    | MethodCall { sr : TExpr.StaticRef; }
    | IL { is_checked : bool; }
    | UpCast
    | DownCast { InCheckedContext : bool; }
    | Implicit
    | IgnoreValue // generates a warning in Typer2
    | Unspecified // like DownCast, but avoid warnings

    // will disappear after generics bootstrap
    | GenericSim

    // Boxing and Nop are to be unused when cgexpr is killed
    | Boxing
    | Nop
  }

  [System.Flags]
  enum TExprFlags
  {
    | IsAssigned           = 0x0001
    | Visited              = 0x0002

    | Throws               = 0x0004
    | ThrowsComputed       = 0x0008

    | NeedAddress          = 0x0010

    | Addressable          = 0x0020
    | AddressableComputed  = 0x0040

    | JumpTarget           = 0x0080

    | Constrained          = 0x0100

    | GenerateTail         = 0x0200

    | SkipWriteCheck       = 0x0400

    | NeedsEmptyStack      = 0x0800
    | NeedsEmptyStackComputed = 0x1000
  }

  public class CacheDesc
  {
    p_indices : PExpr;
    [Accessor] p_expr : PExpr;

    mutable t_indices : TExpr;
    [Accessor] mutable t_expr : TExpr;
    [Accessor] mutable ref_is : TExpr;

    public Type : TypeVar
    {
      get { t_expr.Type }
    }

    public Resolve (par : Typer) : void
    {
      when (t_expr == null)
      {
        when (p_indices != null)
          t_indices = par.TypeExpr (p_indices, par.Solver.FreshTypeVar (), is_toplevel_in_seq = true);
        t_expr = par.TypeExpr (p_expr);
      }
    }

    public Finalize (fun_header : TFunHeader, mutable body : TExpr) : TExpr
    {
      assert(ref_is == null);

      def unfold (e : TExpr) : TExpr
      {
        | Delayed (Typer.DelayedTyping where (DtKind = Resolved (e))) => unfold(e)
        | Delayed => Util.ice ()
        | _ => e
      }

      when (t_indices != null) {
        match (t_indices) {
          | DefValIn as d =>
            assert(d.body == null);
            d.body = body
          | Match (_, [case]) =>
            assert(case.body == null);
            case.body = body
          | _ => Util.ice ()
        }
        body = t_indices;
      }

      def cache_obj (obj)
      {
        match (unfold (obj))
        {
          | LocalRef
          | This => obj // skip caching

          | obj =>
            def val = LocalValue (fun_header, Util.tmpname ("cached_obj"),
                                  obj.Type, LocalValue.Kind.Plain (), false);
            val.IsCache = true;
            body = TExpr.DefValIn (body.Location, body.Type, val, obj, body);
            TExpr.LocalRef (obj.Location, obj.Type, val)
        }
      }

      def get_ref (expr : TExpr)
      {
        | LocalRef
        | This
        | StaticRef
        | StaticPropertyRef
        | StaticEventRef =>
          expr

        | FieldMember   (obj, fld) => TExpr.FieldMember   (cache_obj(obj), fld)
        | PropertyMember(obj, fld) => TExpr.PropertyMember(cache_obj(obj), fld)
        | EventMember   (obj, fld) => TExpr.EventMember   (cache_obj(obj), fld)
        | ArrayIndexer  (obj, fld) => TExpr.ArrayIndexer  (cache_obj(obj), fld)

        | Call (expr, parms, tail) =>
          match (unfold (expr))
          {
            | PropertyMember (obj, fld) as expr =>
              def inner = TExpr.PropertyMember(expr.Location, expr.Type, cache_obj (obj), fld);
              TExpr.Call(inner, parms, tail)

            | _ => Util.ice ()
          }

        | DebugInfo (e, pe) =>
          def e1 = get_ref(unfold(e));
          e1.ty = t_expr.ty;
          TExpr.DebugInfo(expr.Location, e1, pe)

        | _ => Util.ice ($ "invalid cached expr: $expr")
      }

      def expr        = unfold(t_expr);
      ref_is          = get_ref(expr);
      ref_is.Location = t_expr.Location;
      ref_is.ty       = t_expr.ty;
      body
    }

    public this (e : PExpr, i : PExpr)
    {
      p_expr = e;
      p_indices = i;
    }
  }

  public variant TExpr : TypedBase
  {
    // always valid
    | StaticRef             { from : FixedType.Class; mem : IMember; type_parms : list [TypeVar]; }
    | LocalRef              { decl : LocalValue; }
    | ImplicitValueTypeCtor
    | FieldMember           { obj : TExpr; fld : IField; }
    | MethodRef             { obj : TExpr; meth : IMethod; type_parms : list [TypeVar]; notvirtual : bool; }
    | Call                  { mutable func : TExpr; mutable parms : list[Parm]; mutable is_tail : bool;
                              public override SetParsedObject([NotNull] related : ParsedBase) : void
                              {
                                match (related)
                                {
                                  | PExpr.Call(pfunc, _) => func.SetParsedObject(pfunc)
                                  | _ => ()
                                }
                                
                                base.SetParsedObject(related)
                              }
                            }
    | Assign                { target : TExpr; source : TExpr; }
    | DefValIn              { name : LocalValue; val : TExpr; mutable body : TExpr; }
    | Throw                 { exn : TExpr; }
    | TryFinally            { body : TExpr; handler : TExpr; }
    | Try                   { body : TExpr; mutable cases : list [Try_case]; }
    | Literal               { val : Nemerle.Compiler.Literal; }
    | This
    | Base                  { base_ctor : IMethod; }
    | TypeConversion        { mutable expr : TExpr; target_type : TypeVar; kind : ConversionKind;
                              mutable target_type_location : Location;

                              this (loc : Location, tv : TypeVar, expr : TExpr, target_type : TypeVar, kind : ConversionKind)
                              {
                                this (loc, tv, expr, target_type, kind, Location.Default);
                              }

                              this (tv : TypeVar, expr : TExpr, target_type : TypeVar, kind : ConversionKind)
                              {
                                this (tv, expr, target_type, kind, Location.Default);
                              }

                              this (expr : TExpr, target_type : TypeVar, kind : ConversionKind)
                              {
                                this (expr, target_type, kind, Location.Default);
                              }

                            }
    | Sequence              { mutable e1 : TExpr; mutable e2 : TExpr; }
    | Tuple                 { args : list [TExpr]; }
    | Array                 { args : list [TExpr]; dimensions : list [TExpr]; }

    | TypeOf                { target_type : TypeVar; }
    | MethodOf              { from_type : TypeVar; method : IMethod; typars : list [TypeVar] }
    | CtorOf                { @type : TypeVar; method : IMethod; }
    | FieldOf               { @type : TypeVar; field  : IField; }
    | ClosureObjectOf       { varRef : TExpr; }
    | ClosureFieldOf        { varRef : TExpr;
                              public new this(types : InternalTypeClass, varRef : TExpr)
                              {
                                _ty         = types.FieldInfo;
                                this.varRef = varRef;
                              }
                            }

    | ArrayIndexer          { obj : TExpr; args : list [TExpr]; }
    | TupleIndexer          { obj : TExpr; pos : int; len : int; } // 0-based
    | OpCode                { name : string; }
    | MacroEnvelope         { original : PExpr; the_macro : IMacro; expanded : TExpr; expandedPExpr : PExpr; }

    // invalid after T2
    | PropertyMember        { obj : TExpr; prop : IProperty; }
    | StaticPropertyRef     { from : FixedType.Class; prop : IProperty; }
    | EventMember           { obj : TExpr; ev : IEvent; }
    | StaticEventRef        { from : FixedType.Class; ev : IEvent; }
    | ConstantObjectRef     { from : FixedType.Class; mem : IField; }
    | Block                 { jump_out : LocalValue; body : TExpr; }
    | Delayed               { susp : Typer.DelayedTyping; }

    | Cache                 { desc : CacheDesc; mutable body : TExpr; }
    | CacheRef              { desc : CacheDesc; }

    | Error

    // invalid after T3
    | DefFunctionsIn        { funs : list [TFunHeader]; mutable body : TExpr; }
    | Match                 { expr : TExpr; cases : list [Match_case]; }
    | SelfTailCall          { func : TExpr; parms : list [Parm]; }
    | LocalFunRef           { decl : LocalValue; type_parms : list [TypeVar]; }

    // new CG-related stuff
    | MethodAddress         { from : TypeVar; meth : IMethod; is_virt : bool;
                              type_parms : list [TypeVar]; }
    | MultipleAssign        { assigns : list [LocalValue * TExpr]; }
    // we cannot directly reference Label from Goto, because Walk() would
    // destroy it
    | Label                 { id : int; body : TExpr; }
    // The try_block exact value has meaning only in T4, outside a value
    // different than zero means that we should use [leave] and not [br].
    // This is set in T4, if you create nodes of this type earlier, set
    // it to 1.
    | Goto                  { target : int; mutable try_block : int; }
    | DefaultValue
    | If                    { cond : TExpr; e_then : TExpr; e_else : TExpr;
                              mutable then_debug_loc : Location; mutable else_debug_loc : Location; }
    | HasType               { expr : TExpr; test_ty : FixedType; }
    | Switch                { indexing_expr : TExpr;
                              default : option [TExpr];
                              cases : list [int * TExpr]; }
    | DebugInfo             {
                              expr : TExpr; pexpr : PExpr;

                              public new this(ty : TypeVar, expr : TExpr, pexpr : PExpr)
                              {
                                base(ty);
                                this.expr = expr;
                                this.pexpr = pexpr;
                              }

                              public new this(loc : Location, ty : TypeVar, expr : TExpr, pexpr : PExpr)
                              {
                                assert(loc.IsSourceAvailable);
                                base(loc, ty);
                                this.expr = expr;
                                this.pexpr = pexpr;
                              }

                              public new this(loc : Location, expr : TExpr, pexpr : PExpr)
                              {
                                this(loc, if (expr == null) null else expr.ty, expr, pexpr)
                              }

                              public new this(expr : TExpr, pexpr : PExpr)
                              {
                                def ty1  =  if (expr  == null)
                                              null
                                            else
                                              expr.ty;
                                def loc1 =  if (pexpr == null)
                                              if (expr  == null)  Location.Default
                                              else                expr.Location;
                                            else pexpr.Location;

                                if (loc1.IsSourceAvailable)
                                  base(loc1, ty1);
                                else
                                  base(ty1);
                              }

                              public override SetParsedObject([NotNull] related : ParsedBase) : void
                              {
                                expr.SetParsedObject(related)
                              }
                            }

    // Used only by optimizer (between T3 & T4)
    | Def                   { mutable expr : TExpr; mutable into : TExpr; }
    | Use                   { mutable expr : TExpr; mutable def_of : TExpr.Def; }

    mutable _ty : TypeVar;
    public   ty : TypeVar
    {
      [System.Diagnostics.DebuggerStepThrough]
      get { _ty }
      [System.Diagnostics.DebuggerStepThrough]
      set { _ty = value }
    }

    public Type : TypeVar
    { [System.Diagnostics.DebuggerStepThrough]
      get { if (ty == null) GetType(ManagerClass.Instance) else ty }

      internal set
      {
        match (this)
        {
        | DebugInfo (e, _) when e != null => e.ty = value;
        | _ => ()
        }

        ty = value;
      }
    }

    internal CheckAfterT2 () : void
    {
      _ = Walk(
        fun (e)
        {
          | PropertyMember
          | StaticPropertyRef
          | EventMember
          | StaticEventRef
          | ConstantObjectRef
          | Block
          | Delayed
          | Cache
          | CacheRef
          | Error =>
            Util.ice ($"invalid TExpr after T2: $e");
          | Def
          | Use =>
            Util.ice ($"invalid def/use TExpr after T2: $e");
          | _ => null
        });
    }

    internal CheckAfterT3 () : void
    {
      _ = Walk(
        fun(e)
        {
          | PropertyMember
          | StaticPropertyRef
          | EventMember
          | StaticEventRef
          | ConstantObjectRef
          | Block
          | Delayed
          | Cache
          | CacheRef
          | Error       => Util.ice ($"invalid TExpr after T3(T2): $e");
          | DefFunctionsIn
          | Match
          | SelfTailCall
          | LocalFunRef => Util.ice ($"invalid TExpr after T3: $e");
          | Def
          | Use         => Util.ice ($"invalid def/use TExpr after T3: $e");
          | _           => null
        });
    }

    [FlagAccessor(IsAssigned,     flags = WantSetter | Internal)]
    [FlagAccessor(JumpTarget,     flags = WantSetter | Internal)]
    [FlagAccessor(Visited,        flags = WantSetter | Internal)]
    [FlagAccessor(GenerateTail,   flags = WantSetter | Internal)]
    [FlagAccessor(SkipWriteCheck, flags = WantSetter | Internal)]
    mutable flags : TExprFlags;

    #region Typer4 and ILGenerator stuff
    internal Throws : bool
    {
      get
      {
        Util.cassert (flags %&& TExprFlags.ThrowsComputed, $"throws not computed for $this");
        flags %&& TExprFlags.Throws
      }

      set
      {
        Util.cassert(!(flags %&& TExprFlags.ThrowsComputed), $"throws already computed for $this");
        if (value)
          flags |= TExprFlags.Throws
        else
          flags &= ~TExprFlags.Throws;

        flags |= TExprFlags.ThrowsComputed;
      }
    }

    internal NeedsEmptyStack : bool
    {
      get
      {
        Util.cassert(flags %&& TExprFlags.NeedsEmptyStackComputed, $"NeedsEmptyStack not computed for $this");
        flags %&& TExprFlags.NeedsEmptyStack
      }

      set
      {
        Util.cassert(!(flags %&& TExprFlags.NeedsEmptyStackComputed), $"NeedsEmptyStack already computed for $this");
        if (value)
          flags |= TExprFlags.NeedsEmptyStack
        else
          flags &= ~TExprFlags.NeedsEmptyStack;

        flags |= TExprFlags.NeedsEmptyStackComputed;
      }
    }

    internal NeedsConstrained : bool
    {
      get { flags %&& TExprFlags.Constrained  }
      set { when (value) flags |= TExprFlags.Constrained }
    }

    internal IsAddressable : bool
    {
      get
      {
        unless (flags %&& TExprFlags.AddressableComputed)
          match (this)
          {
            | StaticRef
            | LocalRef
            | ArrayIndexer
            | This =>
              IsAddressable = true;
            | FieldMember (obj, fld) =>
              if (fld.DeclaringType.IsValueType)
                IsAddressable = obj.IsAddressable;
              else
                IsAddressable = true;
            | _ =>
              IsAddressable = false;
          }

        flags %&& TExprFlags.Addressable
      }

      set
      {
        Util.cassert(!(flags %&& TExprFlags.AddressableComputed));

        if (value)
          flags |= TExprFlags.Addressable
        else
          flags &= ~TExprFlags.Addressable;

        flags |= TExprFlags.AddressableComputed;
      }
    }

    internal NeedAddress : bool
    {
      get { flags %&& TExprFlags.NeedAddress }
    }

    internal setNeedAddress (from_ctor : bool) : bool
    {
      Util.cassert(!NeedAddress);

      match (this)
      {
        | StaticRef
        | LocalRef
        | ArrayIndexer
        | This =>
          flags |= TExprFlags.NeedAddress;
          true

        | FieldMember (This as obj, fld) with is_mutable = from_ctor || fld.IsMutable
        | FieldMember (obj, fld) with is_mutable = fld.IsMutable || fld.Attributes %&& NemerleModifiers.CompilerMutable =>
          if (is_mutable) {
          //Message.Debug ($"am being assigned $this");
            flags |= TExprFlags.NeedAddress;
            if (fld.DeclaringType.IsValueType && !obj.NeedAddress)
              obj.setNeedAddress (from_ctor);
            else
              true
          }
          else
            false

        | _ => false
      }
    }
    #endregion

    public GetType(manager : ManagerClass) : TypeVar
    {
      when (ty == null)
      {
        TryInitType(manager);

        when (ty == null)
        {
          if (manager.IsIntelliSenseMode)
          {
            System.Diagnostics.Trace.WriteLine($"type is null for $(this.Location), $this");
            ty = manager.Solver.FreshTypeVar ()
          }
          else
            assert2(ty != null, $ "still null, $(this.Location), $this");
        }
      }

      ty
    }

    public TryInitType(manager : ManagerClass) : void
    {
      match (this)
      {
        | DebugInfo (e, _) when e != null => ty = e.GetType(manager)
        | _ =>
          when (ty == null)
          {
            def InternalType = manager.InternalType;
            match (this)
            {
              | Throw | Goto | Error =>  ty = manager.Solver.FreshTypeVar ()

              | TExpr.Literal (l)          => ty = l.GetInternalType (InternalType)
              | Assign                     => ty = InternalType.Void
              | HasType                    => ty = InternalType.Boolean
              | MacroEnvelope (_, _, e, _) => ty = e.GetType(manager)
              | Cache as c =>
                assert2(c.body != null, $ "when trying to determin type, body is null: $this");
                ty = c.body.GetType(manager)

              | TypeOf                     => ty = InternalType.Type
              | CtorOf                     => ty = InternalType.ConstructorInfo
              | MethodOf                   => ty = InternalType.MethodInfo

              | _ => ()
            }
          }
      }
    }

    // Code which change state can't be property!
    public FixedType() : FixedType
    {
      Type.Fix()
    }

    public GetSystemType () : System.Type
    {
      Type.GetSystemType ()
    }

    public this () { }

    public this (ty : TypeVar)
    {
      this.ty = ty;
    }

    public this (loc : Location, ty : TypeVar)
    {
      base (loc);
      this.ty = ty;

#if DEBUG
      assert2(!(this is DebugInfo) || loc.IsSourceAvailable);
#endif
    }


    public override ToString () : string { PrettyPrint.SprintTyExpr (this) }


    // it does not copy calls
    public Copy() : TExpr
    {
      Walk(do_copy)
    }


    static do_copy (expr : TExpr) : TExpr
    {
      match (expr)
      {
        | This                                  => This()
        | LocalRef(decl)                        => LocalRef(decl)
        | StaticRef(from, mem, parms)           => StaticRef(from, mem, parms)
        | OpCode(o)                             => OpCode(o)
        | TypeOf(t)                             => TypeOf(t)
        | MethodOf(from_type, method, typars)   => MethodOf(from_type, method, typars)
        | CtorOf(ty, m)                         => CtorOf(ty, m)
        | FieldOf(ty, f)                        => FieldOf(ty, f)
        | ClosureObjectOf(x)                    => ClosureObjectOf(x)
        | ClosureFieldOf(x)                     => ClosureFieldOf(x)
        | TExpr.Literal(l)                      => TExpr.Literal(l)
        | Base(ctor)                            => Base(ctor)
        | ImplicitValueTypeCtor                 => ImplicitValueTypeCtor()
        | MethodAddress(from, meth, v, typarms) => MethodAddress(from, meth, v, typarms)
        | Goto(id, t)                           => Goto(id, t)
        | DefaultValue                          => DefaultValue()
        | ConstantObjectRef(from, mem)          => ConstantObjectRef(from, mem)
        | _                                     => null // FIXME
      }
    }


    static walk(f : TExpr -> TExpr, expr : TExpr) : TExpr
    {
      def res = Util.locate(expr.Location,
      {
        def res = f(expr);
        def res =
          if (res == null)
            do_walk(f, expr)
          else
            res;

        if (res == null)
          expr
        else
        {
          def parsedObject = expr.ParsedObject;

          when (null != parsedObject)
            res.SetParsedObject(parsedObject);

          res
        }
      });
      when (res.ty == null)
        res.ty = expr.ty;
      //Message.Debug ($"walk: $expr -> $res");
      res
    }

    static null_walk (f : TExpr -> TExpr, expr : TExpr) : TExpr
    {
      def res = Util.locate (expr.Location, {
        def res = f (expr);
        if (res == null) do_walk (f, expr) else res;
      });
      when (res != null && res.ty == null)
        res.ty = expr.ty;
      //Message.Debug ($"null_walk: $expr -> $res");
      res
    }


    static walks (f : TExpr -> TExpr, exprs : list [TExpr]) : list [TExpr]
    {
      mutable cnt = 0;
      mutable total = 0;
      mutable first_expr = null;

      foreach (expr in exprs) {
        when (first_expr == null) {
          def expr' = null_walk (f, expr);
          when (expr' != null)
            first_expr = expr';
          cnt++;
        }
        total++;
      }

      if (first_expr == null) exprs
      else {
        def loop (res, n, l) {
            match (l) {
              | x :: xs =>
                if (n == 0)
                  xs.RevAppend (first_expr :: res)
                else
                  loop (walk (f, x) :: res, n - 1, xs)
              | [] => Util.ice ()
            }
        }
        loop ([], total - cnt, exprs.Rev ())
      }
    }

    static do_walk (f : TExpr -> TExpr, expr : TExpr) : TExpr
    {
      match (expr)
      {
        | Cache
        | CacheRef
        | Delayed
        | PropertyMember
        | StaticPropertyRef
        | EventMember
        | Block
        | StaticEventRef =>
          // this is supposed to be run after Typer2
          Message.Warning (expr.Location, $"invalid expr in walk: $(expr.GetType()): $expr");
          assert(false)


        | This
        | LocalRef
        | LocalFunRef
        | StaticRef
        | Error
        | OpCode
        | TypeOf
        | MethodOf | CtorOf | FieldOf
        | TExpr.Literal
        | Base
        | ImplicitValueTypeCtor
        | MethodAddress
        | Goto
        | DefaultValue
        | ConstantObjectRef => null


        | DefFunctionsIn (funs, body) =>
          foreach (fn in funs)
            match (fn.body) {
              | FunBody.Typed (e) =>
                fn.body = FunBody.Typed (walk (f, e))
              | _ => {}
            }
          DefFunctionsIn (funs, walk (f, body))

        | ClosureObjectOf(e)  => ClosureObjectOf(walk(f, e))
        | ClosureFieldOf(e)   => ClosureFieldOf(walk(f, e))

        | MethodRef (obj, meth, tp, notvirt) =>
          def obj = null_walk (f, obj);
          if (obj == null) null
          else
            MethodRef (obj, meth, tp, notvirt)


        | FieldMember (obj, fld) =>
          def obj = null_walk (f, obj);
          if (obj == null) null
          else
            FieldMember (obj, fld)


        | Call (func, parms, is_tail) =>
          def func = walk (f, func);
          mutable rev_parms = [];
          foreach (p in parms)
            rev_parms = Parm (p.kind, walk (f, p.expr), p.name, p.required_type) :: rev_parms;
          Call (func, rev_parms.Rev (), is_tail)


        | SelfTailCall (_, parms) =>
          foreach (p in parms)
            p.expr = walk (f, p.expr);
          null


        | Assign (target, source) =>
          def target' = walk (f, target);
          def source' = walk (f, source);
          if (target' : object == target && source' : object == source)
            null
          else
            Assign (target', source')


        | MultipleAssign (assigns) =>
          MultipleAssign (assigns.Map (fun (s, t) { (s, walk (f, t)) }))


        | DefValIn (name, val, body) =>
          def val' = walk (f, val);
          def body' = walk (f, body);
          if (val' : object == val && body' : object == body)
            null
          else
            DefValIn (name, val', body')


        | Match (matched_value, cases) =>
          foreach (case in cases) {
            mutable pats = [];
            foreach ((pat, expr, assigns) in case.patterns) {
              def assigns =
                assigns.Map (fun (v, e) { (v, walk (f, e)) });
              pats = (pat, walk (f, expr), assigns) :: pats
            }
            case.patterns = pats.Rev ();
            case.body = walk (f, case.body);
          }
          def matched_value = null_walk (f, matched_value);
          if (matched_value == null) null
          else
            Match (matched_value, cases)


        | If (cond, e1, e2, l1, l2) =>
          def cond' = walk (f, cond);
          def e1'   = walk (f, e1);
          def e2'   = walk (f, e2);

          if (cond' : object == cond &&
              e1'   : object == e1   &&
              e2'   : object == e2)
            null
          else
            If (cond', e1', e2', l1, l2)


        | Switch (ind, defl, cases) =>
          Switch (walk (f, ind),
                  match (defl) {
                    | Some (d) => Some (walk (f, d))
                    | None => defl
                  },
                  cases.Map (fun (n, e) { (n, walk (f, e)) }))


        | HasType (e, t) =>
          def e = null_walk (f, e);
          if (e == null) null
          else
            HasType (e, t)


        | Throw (exn) =>
          // exception can be null for `throw;' rethrow expression
          if (exn != null) {
            def exn = null_walk (f, exn);
            if (exn == null) null
            else Throw (exn)
          } else
            null

        | TryFinally (body, handler) =>
          TryFinally (walk (f, body), walk (f, handler))

        | Try (body, cases) =>
          def walk_case(case) {
            | Try_case.Fault (handler) => Try_case.Fault (walk (f, handler))
            | Try_case.Catch (exn, handler) => Try_case.Catch (exn, walk (f, handler))
            | Try_case.Filter (exn, filter, handler) => Try_case.Filter (exn, walk (f, filter), walk (f, handler))
          }
          Try (walk (f, body), cases.Map (walk_case))

        | TypeConversion (expr, t, kind, tl) =>
          def expr = null_walk (f, expr);
          if (expr == null) null
          else
            TypeConversion (expr, t, kind, tl)


        | DebugInfo (null, _) => null


        | DebugInfo (e, pe) =>
          def e1 = walk (f, e);

          if (e1 : object == e)
            null
          else
            DebugInfo (expr.Location, e1.ty, e1, pe)


        | Sequence (e1, e2) =>
          def e1' = walk (f, e1);
          def e2' = walk (f, e2);
          if (e1' : object == e1 && e2' : object == e2)
            null
          else
            Sequence (e1', e2')


        | Tuple (args) =>
          Tuple (walks (f, args))


        | TupleIndexer (obj, k, n) =>
          def obj = null_walk (f, obj);
          if (obj == null) null
          else
            TupleIndexer (obj, k, n)


        | Array (args, dimensions) =>
          Array (walks (f, args), walks (f, dimensions))


        | ArrayIndexer (obj, args) =>
          ArrayIndexer (walk (f, obj), walks (f, args))


        | MacroEnvelope (id, orig, body, epe) =>
          def body = null_walk (f, body);
          if (body == null) null
          else
            MacroEnvelope (id, orig, body, epe)

        | Label (id, body) =>
          def body = null_walk (f, body);
          if (body == null) null
          else
            Label (id, body)

        | Def
        | Use
           => assert(false)
      }
    }

    /** Walk [this] with the function [f].

        The function is applied to each and every expression node.

        If [f] returns a value different than [null], the value is
        returned, from this [Walk] function.

        If it returns [null], the walking function descends into tree
        elements in a map-like fashion.

        If the type of expression returned was to be [null], it is set
        to the type of the original expression.

        This function implements the visitor pattern.  */
    public Walk(f : TExpr -> TExpr) : TExpr
    {
      walk (f, this)
    }


    public static BoolLiteral (mgr : ManagerClass, val : bool) : TExpr
    {
      TExpr.Literal (mgr.InternalType.Boolean,
                     Nemerle.Compiler.Literal.Bool (val));
    }

    public static TrueLiteral (mgr : ManagerClass) : TExpr { BoolLiteral (mgr, true) }
    public static FalseLiteral (mgr : ManagerClass) : TExpr { BoolLiteral (mgr, false) }
  }

  public enum ParmKind {
    | Normal
    | Ref
    | Out
  }

  [Record]
  public class Parm
  {
    public kind : ParmKind;
    public mutable expr : TExpr;
    public name : string;  // "" if no name given
    [RecordIgnore] public IsByDefault : bool; // if parameter passed as default value
    public mutable required_type : TypeVar;
    [RecordIgnore]
    public NameToComplete : string { get; set; }

    public this(expr : TExpr, is_default : bool)
    {
      this(expr);
      IsByDefault = is_default;
    }
    
    public this(expr : TExpr)
    {
      kind = ParmKind.Normal;
      this.expr = expr;
      name = "";
    }

    override public ToString() : string
    {
      $<#$(if (name == "") "" else name + "=") $expr#>
    }
  }
} // Nemerle.Compiler.Typedtree
