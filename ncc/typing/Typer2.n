/*
 * Copyright (c) 2005-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using PT = Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler
{
  [ManagerAccess]
  public class Typer2
  {
            top_level_fun : MethodBuilder;
    mutable this_ptr_decl : LocalValue;
            typer         : Typer;
    mutable current_fun   : TFunHeader;

    mutable field_inits_typed : bool = false;
    IsCurrentFunInstanceCtor() : bool
    {
      top_level_fun.MemberKind == MemberKinds.Constructor &&
      !top_level_fun.IsStatic &&
      0 == top_fun.CompareTo(current_fun);
    }

    top_fun : TFunHeader;
    current_type : TypeBuilder;
    messenger : Messenger;
    inside_yielding_function : bool;

    [System.Flags]
    internal enum Context
    {
      | Clean              = 0x0000
      | IsTail             = 0x0001
      | NeedLValue         = 0x0002
      | IsCalledValue      = 0x0004
      | IsIndexerRef       = 0x0008
      | IsDelegeteCtorParm = 0x0010
      | AllowGoto          = 0x0020
      | AllowTry           = 0x0040
      | AllowTryAtFuncLev  = 0x0080
      | AllowEmptyThrow    = 0x0100

      | AllowGotoAndSuch   = AllowGoto %| AllowTry
      | AllowGotoAndAllThrows = AllowGoto %| AllowTry %| AllowEmptyThrow

      | TopLevel           = IsTail %| AllowGoto %| AllowTry
    }

    public this(ty : TypeBuilder, fn : MethodBuilder, typer : Typer)
    {
      this.typer = typer;
      Manager = ty.Manager;
      current_fun = fn.GetHeader();
      top_fun = current_fun;
      current_fun.usage = FunctionUsage.Used;
      top_level_fun = fn;
      current_type = ty;

      messenger = Manager.Solver.CurrentMessenger;

      inside_yielding_function =  current_fun.yield_type != null;
    }

    private MarkAsUsed(mem : IMember, loc : Location) : void
    {
      Manager.MarkAsUsed(mem, loc, !top_level_fun.IsObsolete && !current_type.IsObsolete);
    }
    private MarkAsAssigned(mem : IField, loc : Location) : void
    {
      Manager.MarkAsAssigned(mem, loc, !top_level_fun.IsObsolete && !current_type.IsObsolete);
    }

    public Run() : void
    {
      foreach (parm in current_fun.Parameters)
        parm.decl.Register();

      when (IsCurrentFunInstanceCtor() && !field_inits_typed)
        match (current_type.init_list)
        {
          | [q] =>
            match (q)
            {
              | PT.PExpr.Typed(e) =>
                 current_type.init_list = PT.PExpr.Typed(Walk(Context.TopLevel, e)) :: [];
                 field_inits_typed = true

              | _ => Util.ice("bad field initializers");
            }
          | [] => ()
          | _ => Util.ice("bad field initializers");
        }

      match (current_fun.body)
      {
        | FunBody.Typed(expr) =>
          def e = Walk(Context.TopLevel, expr);
          unless (Message.SeenError)
            e.CheckAfterT2();
          current_fun.body = FunBody.Typed(e);
          FixupCurrentFunction();

        | _ => ()
      }
    }


    Walk(expr : TExpr) : TExpr
    {
      Walk(Context.Clean, expr)
    }


    Walks(exprs : list [TExpr]) : list [TExpr]
    {
      NList.Map(exprs, Walk)
    }


    internal Walk(ctx : Context, expr : TExpr) : TExpr
    {
      assert(expr != null);
      Util.locate(expr.Location,
      {
        messenger.CleanLocalError();
        def expr = PushConversionDown(expr);
        def res = DoWalk(ctx, expr);
        def res =
          if (res == null)
            expr
          else
          {
            def parsedObject = expr.ParsedObject;

            when (null != parsedObject)
              res.SetParsedObject(parsedObject);

            match (res)
            {
              | _ when res.ty != null =>
                // Message.Debug($ "type for $res ($(res.GetType())) already set to $(res.ty), "
                //                 "would set to $(expr.ty)");
                ()

              | Sequence(_, e)
              | DefValIn(_, _, e) => res.ty = e.Type;
              | _ => res.ty = expr.ty;
            }
            res
          };

        when (ctx %&& Context.IsTail)
          match (res)
          {
            | TExpr.Call as call => call.is_tail = true;
            | _ => ()
          }
        res
      })
    }


    static AreSelfMethodTyParms(meth : IMethod, typarms : list [TypeVar]) : bool
    {
      if (typarms.IsEmpty)
        true
      else
      {
        def Manager = typarms.Head.Manager;
        def is_ok =
          try
          {
            Manager.Solver.PushState();
            NList.ForAll2(meth.GetHeader().TypeParameters, typarms,
             (st, tv) => tv.Unify(FixedType.StaticTypeVarRef(st)))
          }
          finally
            Manager.Solver.PopState();

        if (is_ok)
        {
          NList.Iter2(meth.GetHeader().TypeParameters, typarms,
            (st, tv) => tv.ForceUnify(FixedType.StaticTypeVarRef(st)));
          true
        }
        else
          false
      }
    }

    IsSelfCall(func : TExpr) : bool
    {
      match (Unfold(func))
      {
        | TExpr.LocalFunRef(decl, _) =>
          match (decl.ValKind)
          {
            | LocalValue.Kind.Function(hd, _) => hd.id == current_fun.id
            | _ => false
          }

        | TExpr.StaticRef(Class(tc, _) as from, meth is IMethod, typarms) =>
          meth.GetHeader().id == current_fun.id 
          && tc.GetMemType().Equals(from) && AreSelfMethodTyParms(meth, typarms)

        | TExpr.MethodRef(th, meth : IMethod, typarms, _) =>
          (!(meth.Attributes %&& NemerleModifiers.Virtual) || meth.Attributes %&& NemerleModifiers.Sealed)
          && meth.GetHeader().id == current_fun.id && Unfold(th) is TExpr.This 
          && AreSelfMethodTyParms(meth, typarms)

        | _ => false
      }
    }

    Unfold(expr : TExpr) : TExpr
    {
      match (expr)
      {
        | TExpr.Delayed(dt) =>
          match (dt.DtKind)
          {
            | Typer.DelayedTyping.Kind.Resolved(expr) => Unfold(expr)
            | _ =>
              if (Manager.IsIntelliSenseMode)
              {
                System.Diagnostics.Trace.WriteLine(dt);
                TExpr.Error()
              }
              else
                Util.ice($"unresolved expression: $dt");
          }
        | TExpr.CacheRef(d)    => Unfold(d.RefIs)
        | TExpr.TypeConversion => PushConversionDown(expr)
        | _                    => expr
      }
    }


    IsOperator(expr : TExpr) : bool
    {
      match (Unfold(expr))
      {
        | TExpr.StaticRef(_, meth is IMethod, _) => !(meth.BuiltinKind is BuiltinMethodKind.NotBuiltin)
        | _ => false
      }
    }

    OperatorKind(expr : TExpr) : BuiltinMethodKind
    {
      match (Unfold(expr))
      {
        | TExpr.StaticRef(_, meth is IMethod, _) => meth.BuiltinKind
        | _ => assert(false)
      }
    }


    IsCurrentType(tv : TypeVar) : bool
    {
      match (tv.Fix())
      {
        | FixedType.Class(ti, _) => ti.Equals(current_type)
        | _ => false
      }
    }


    GetEventObj(expr : TExpr) : option[IEvent * TExpr * FixedType.Class]
    {
      def expr = match (Unfold(expr))
      {
        | TExpr.DebugInfo(e, _) | e => e
      }
      match (expr)
      {
        | TExpr.StaticEventRef(ty, ev) => Some((ev, null, ty))
        | TExpr.EventMember(obj, ev)   => Some((ev, obj, null))
        | _                            => None()
      }
    }



    TheSame(e1 : TExpr, e2 : TExpr) : bool
    {
      e1 : object == e2 : object
        ||
        match ((Unfold(e1), Unfold(e2)))
        {
          | (TExpr.LocalRef(d1), TExpr.LocalRef(d2)) =>
            d1.Equals(d2)

          | (TExpr.StaticRef(t1, m1, l1), TExpr.StaticRef(t2, m2, l2)) =>
            t1.Equals(t2) && m1.Equals(m2) && l1.Equals(l2)

          | (TExpr.This, TExpr.This) => true
          | _ => false
        };
    }

    PushConversionDown(expr : TExpr) : TExpr
    {
      match (expr)
      {
        | TExpr.Delayed => PushConversionDown(Unfold(expr))
        | TExpr.TypeConversion(e, t, k, tl) =>
          if (k is ConversionKind.Implicit && t.TryUnify(e.Type))
          {
            t.ForceUnify(e.Type);
            e
          }
          else
          {
            def pushConversionDown(expr : TExpr, e : TExpr, t, k, tl) : TExpr
            {
              match (e)
              {
                | DebugInfo(Sequence(_, DebugInfo(null, _)), _) => expr
                | DebugInfo(e, _) when e != null => pushConversionDown(expr, Unfold(e), t, k, tl)
                | DefValIn(n, v, b) =>
                  def b = VoidIfNull(b);
                  TExpr.DefValIn(e.ty, n, v, PushConversionDown(TExpr.TypeConversion(expr.ty, b, t, k, tl)))

                | DefFunctionsIn(funs, b) =>
                  def b = VoidIfNull(b);
                  TExpr.DefFunctionsIn(e.ty, funs, PushConversionDown(TExpr.TypeConversion(expr.ty, b, t, k, tl)))

                | Sequence(e, b) =>
                  def b = VoidIfNull(b);
                  TExpr.Sequence(e.ty, e, PushConversionDown(TExpr.TypeConversion(expr.ty, b, t, k, tl)))

                | Block(j, b) =>
                  def b = VoidIfNull(b);
                  TExpr.Block(e.ty, j, PushConversionDown(TExpr.TypeConversion(expr.ty, b, t, k, tl)))

                | Throw
                | Goto
                | Call(LocalRef(LocalValue where (ValKind = BlockReturn)), _, _) =>
                  // just skip the cast as it is not going to be executed anyway
                  e

                | _ => expr
              }
            }

            pushConversionDown(expr, Unfold(e), t, k, tl)
          }
        | _ => expr
      }
    }


    ConvertEventExpr(target : TExpr, source : TExpr) : TExpr
    {
      match (GetEventObj(target))
      {
        | Some((ev1, obj1, ty1)) =>
          match (Unfold(source))
          {
            | TExpr.Call(meth, [p1, p2], _)
              when IsOperator(meth) =>
              match (OperatorKind(meth))
              {
                | BuiltinMethodKind.CallWithCast(meth)
                  when meth.Equals(InternalType.Delegate_Combine) || meth.Equals(InternalType.Delegate_Remove) =>
                  match (GetEventObj(p1.expr))
                  {
                    | Some((ev2, obj2, _ty2)) when ev1.Equals(ev2) && TheSame(obj1, obj2) =>
                      def ev_meth =
                        if (meth.Equals(InternalType.Delegate_Combine))
                          ev1.GetAdder()
                        else
                          ev2.GetRemover();

                      assert(ev_meth != null);
                      
                      MarkAsUsed(ev_meth, source.Location);
                      def ev_meth_ref =
                        if (obj1 == null)
                        {
                          def (ty, vars) = ty1.Fix().TypeOfMethodWithTyparms(ev_meth);
                          TExpr.StaticRef(ty, ty1, ev_meth, vars)
                        }
                        else
                        {
                          def obj1 = Walk(obj1);
                          def (ty, vars) = obj1.Type.Fix().TypeOfMethodWithTyparms(ev_meth);
                          TExpr.MethodRef(ty, obj1, ev_meth, vars, IsBaseRef(obj1));
                        };
                      p2.expr = Walk(p2.expr);
                      TExpr.Call(ev_meth_ref, [p2], false)

                    | _ => null
                  }
                | _ => null
              }
            | _ => null
          }
        | _ => null
      }
    }


    WalkPattern(pat : Pattern) : Pattern
    {
      pat.Walk(fun(_)
      {
        | Pattern.HasType(tc) =>
          when (pat.ty.TryRequire(tc) && messenger.NeedMessage)
            Message.Warning(10013, pat.Location, "using the ``is'' pattern here is redundant, please use ``:''");
          null

        | Pattern.As(_, decl) =>
          unless (decl.IsRegistered)
            decl.Register();
          null

        | _ => null
      })
    }


    FixupCurrentFunction() : void
    {
      match (current_fun.Parameters)
      {
        | [] => ()
        | [p] when p.Type.Fix() is FixedType.Void && p.Name.StartsWith("_N_wildcard_") =>
          // Spetial case for "fun(_) { }" when expected type is "void -> ?"
          current_fun.Parameters = [];

        | _ =>
          foreach (parm in current_fun.Parameters)
            when (parm.Type.Fix() is FixedType.Void)
              Message.Error(parm.TypeLocation, $"method `$(current_fun.Name)' has void argument");
      }

      def warned = Hashtable(50);

      def locals = NList.Rev(current_fun.all_locals);
      current_fun.all_locals = []; // GC it

      unless (current_type.IsDelegate)
      {
        foreach (v in locals)
          when (!v.EverUsed && v.Name[0] != '_' && !warned.Contains(v))
          {
            Message.Warning(168, v.Location, $ "$(v) was never used");
            Message.HintOnce(168, v.Location, "replace name with `_' or prefix it like `_bar' to avoid the warning");
            warned.Set(v, null)
          }

        when (this_ptr_decl == null && current_fun : object == top_level_fun.GetHeader())
          unless (top_level_fun.Attributes %&& (NemerleModifiers.Static | NemerleModifiers.Virtual
                                              | NemerleModifiers.Override | NemerleModifiers.SpecialName)
                  || top_level_fun.MemberKind == MemberKinds.Constructor
          )
            Message.Warning(10006, $"`this' was never used, consider making `$top_level_fun' static");
      }

      // check for duplicate parameter names
      def loop(_ : list[TParameter])
      {
        | x :: xs =>
          foreach (y when (y.Name == x.Name) in xs)
            Message.Error(y.Location, "duplicate parameter name: " + y.Name);

          loop(xs)

        | _ => ()
      }

      loop(current_fun.Parameters);

      // move closure vars of loops to their parent function
      foreach (v in locals)
        match (v.ValKind)
        {
          | LocalValue.Kind.Function(h, _) =>
            when (h.usage == FunctionUsage.UsedJustOnce || (inside_yielding_function && top_fun.id == current_fun.id))
              if (h.TypeParameters is [])
              {
                current_fun.closure_vars += h.closure_vars;
                h.closure_vars = [];
              }
              else
                h.usage = FunctionUsage.Used // we cannot yet deal with expanding these to loops

          | _ => ()
        }

      foreach (v in locals)
      {
        // FIXME: this is wrong (performance problems) if we're inside
        // some real local function in yielding function
        mutable in_clo = inside_yielding_function && !v.NeverClosurise;

        foreach (h in v.UsedIn)
        {
          unless (in_clo)
          {
            // check if all functions from h to current_fun are used_just_once
            def find_defining(header : TFunHeader)
            {
              match (header.usage)
              {
                | _ when header.id == current_fun.id => ()
                | FunctionUsage.UsedJustOnce         => find_defining(header.decl.DefinedIn)
                | _                                  => in_clo = true;
              }
            }

            find_defining(h)
          }
        }

        when (in_clo)
        {
          // check if we are not closuring some invalid things
          match (v.ValKind)
          {
            | LocalValue.Kind.FunParm(k) when k != ParmKind.Normal =>
              Message.Error(v.Location, $ "cannot store ref/out parameters in closures ($v)");

            | _ => ()
          }

          v.InClosure = true;
          v.DefinedIn.closure_vars ::= v;
        }
      }

      // Message.Debug($ "$(current_fun.name): $(current_fun.usage) $(current_fun.has_1st_class_child) $(current_fun.closure_vars)");

      //when (current_fun.has_1st_class_child && !(current_fun.closure_vars is []))
      //  current_fun.cannot_inline = true;
    }


    PolyLocalToLambdaTransform (expr : TExpr.LocalFunRef) : TExpr
    {
      def (ret_type, parms_types) =
        match (expr.Type.Fix())
        {
          | FixedType.Fun(from, to) =>
            (to, from.Fix().GetFunctionArguments())
          | _ => assert(false)
        };
      def polyHeader = (expr.decl.ValueKind :> LocalValue.Kind.Function).header;
      def polyParams = polyHeader.Parameters;
      def parms =
          if (parms_types.Length == polyParams.Length) // use real perametr names if has no parametrs transformation
            NList.Map2(parms_types, polyParams, (ty, pp) => TParameter(pp.Name, 0, ty, AttributesAndModifiers(), ParmKind.Normal))
          else
            parms_types.Map(ty => TParameter(Util.tmpname("fp"), 0, ty, AttributesAndModifiers(), ParmKind.Normal));

      def lambda_header = TFunHeader(expr.Location, $"_N_poly_lambda_for_$(polyHeader.Name)", ret_type, Location.Default,
                                     parms, [], current_fun.tenv);
      def parms_refs =
        parms.Map(
          fun(fp : TParameter)
          {
            fp.decl =
              LocalValue(lambda_header, fp.name, fp.ty,
                         LocalValue.Kind.FunParm(ParmKind.Normal),
                         is_mutable = false);
            def p = Parm(TExpr.LocalRef(fp.ty, fp.decl));
            p.required_type = fp.ty;
            p
          });
      def lambda_body = TExpr.Call(ret_type, expr, parms_refs, false);
      def parents = current_fun :: current_fun.GetParents();
      def lambda_value =
        LocalValue(current_fun, lambda_header.Name, expr.Type,
                   LocalValue.Kind.Function(lambda_header, parents),
                   is_mutable = false);

      lambda_header.body = FunBody.Typed(lambda_body);
      lambda_header.decl = lambda_value;

      def res = TExpr.DefFunctionsIn(expr.Type, [lambda_header], TExpr.LocalFunRef(expr.Type, lambda_value, []));

      Walk(res)
    }


    MethodToLambdaTransform(expr : TExpr, obj : TExpr, meth : IMethod,
                            type_parms : list [TypeVar], notvirt : bool) : TExpr
    {
      def obj_cache = LocalValue(current_fun, "_N_obj_cache", obj.Type, LocalValue.Kind.Plain(), is_mutable = false);
      def (ret_type, parms_types) =
        match (expr.Type.Fix())
        {
          | FixedType.Fun(from, to) => (to, from.Fix().GetFunctionArguments())
          | _ => assert(false)
        };
      //FixMe: ValdD2: seem, we lose parameter name here! Fix it!
      def parms = parms_types.Map(ty => TParameter(Util.tmpname("fp"), 0, ty, AttributesAndModifiers(), ParmKind.Normal));
      def lambda_header = TFunHeader(obj.Location, "_N_method_lambda", ret_type, Location.Default,
                                     parms, [], current_fun.tenv);
      def parms_refs =
        NList.Map(parms,
          fun(fp : TParameter)
          {
            fp.decl =
              LocalValue(lambda_header, fp.name, fp.ty,
                         LocalValue.Kind.FunParm(ParmKind.Normal),
                         is_mutable = false);
            def p = Parm(TExpr.LocalRef(fp.ty, fp.decl));
            p.required_type = fp.ty;
            p
          });
      def lambda_body =
        TExpr.Call(ret_type,
           TExpr.MethodRef(expr.Type,
              TExpr.LocalRef(obj_cache.Type, obj_cache),
              meth, type_parms,
              notvirt), parms_refs, false);
      def parents = current_fun :: current_fun.GetParents();
      def lambda_value =
        LocalValue(current_fun, lambda_header.Name, expr.Type,
                    LocalValue.Kind.Function(lambda_header, parents),
                    is_mutable = false);
      lambda_header.body = FunBody.Typed(lambda_body);
      lambda_header.decl = lambda_value;

      def res = TExpr.DefFunctionsIn(expr.Type, [lambda_header], TExpr.LocalFunRef(expr.Type, lambda_value, []));
      def res = TExpr.DefValIn(expr.Type, obj_cache, obj, res);

      Walk(res)
    }


    VoidIfNull(expr : TExpr) : TExpr
    {
      if (expr == null)
        TExpr.Literal(InternalType.Void, Literal.Void())
      else
        expr
    }


    IsBaseRef(expr : TExpr) : bool
    {
      match (Unfold(expr))
      {
        | TExpr.This as ex => ! IsCurrentType(ex.Type)
        | TExpr.LocalRef(decl) as ex =>
          // assert(decl.ValKind != null);
          !IsCurrentType(ex.Type) && decl.ValKind is LocalValue.Kind.ClosurisedThisPointer

        | _ => false
      }
    }


    IgnoreExpr(expr : TExpr) : TExpr
    {
      def solver = Manager.Solver;
      solver.PushState();
      def ok = expr.Type.Unify(InternalType.Void);
      solver.PopState();
      if (ok)
      {
        def res = expr.Type.Unify(InternalType.Void);
        assert(res);
        expr
      }
      else
      {
        Message.Warning(10005, expr.Location, $"ignored computed value of type $(expr.Type)");
        Message.HintOnce(10005, expr.Location, "use `_ = ...'; or -nowarn:10005 to avoid the warning");

        BuildEnforcement(expr, InternalType.Void);
      }
    }


    BuildEnforcement(expr : TExpr, target : FixedType) : TExpr
    {
      BuildConversion(expr, target, ConversionKind.UpCast())
    }


    BuildConversion(expr : TExpr, target : TypeVar, kind : ConversionKind) : TExpr
    {
      // Message.Debug($ "bc: $expr -> $target($kind)");

      assert(expr != null);

      def target = target.Fix();
      def is_ignore = kind is ConversionKind.IgnoreValue;

      def kind =
        match (target)
        {
          | FixedType.Void when ! is_ignore => ConversionKind.IL(true)
          | _ => kind
        };

      if (kind is ConversionKind.Implicit && target.TryUnify(expr.Type))
      {
        target.ForceUnify(expr.Type);
        expr
      }
      else if (is_ignore)
        IgnoreExpr(expr)
      else match (kind)
      {
        | ConversionKind.MethodCall(sr) =>
          MarkAsUsed(sr.mem, expr.Location);
          TExpr.Call(expr.Location, target, sr, [Parm(expr)], false)

        | ConversionKind.DownCast =>
          def exprType = expr.Type;

          if (exprType.TryRequire(target))
          {
            exprType.ForceRequire(target);
            Message.Warning(10001, $"there is no check needed to cast $exprType to $target");
            Message.HintOnce(10001, "consider using : instead of :>");
            BuildEnforcement(expr, target)
          }
          else
            TExpr.TypeConversion(expr.Location, target, expr, target, kind)

        | ConversionKind.Unspecified =>
          if (expr.Type.TryRequire(target))
          {
            expr.Type.ForceRequire(target);
            BuildEnforcement(expr, target)
          }
          else
            TExpr.TypeConversion(expr.Location, target, expr, target, ConversionKind.DownCast(false))

        | _ => TExpr.TypeConversion(expr.Location, target, expr, target, kind)
      }
    }


    BuildBlockReturn(ctx : Context, ty : TypeVar, decl : LocalValue, parms : list [Parm]) : TExpr
    {
      def (result_decl, label) =
        match (decl.ValKind)
        {
          | LocalValue.Kind.BlockReturn(res, lab) => (res, lab)
          | _ => Util.ice()
        };

      match (parms)
      {
        | [] =>
          result_decl.Type.ForceUnify(InternalType.Void);
          TExpr.Goto(ty, label, 1)

        | [parm] =>
          parm.expr.Type.ForceRequire(result_decl.Type);
          TExpr.Sequence(ty, TExpr.Assign(InternalType.Void, TExpr.LocalRef(result_decl), parm.expr),
                         Walk(ctx, TExpr.Goto(ty, label, 1)))
        | _ =>
          result_decl.Type.ForceUnify(FixedType.Tuple(parms.Map(_.required_type)));
          TExpr.Sequence(ty,
                          TExpr.Assign(InternalType.Void,
                                       TExpr.LocalRef(result_decl),
                                       TExpr.Tuple(result_decl.Type, parms.Map(_.expr))),
                          Walk(ctx, TExpr.Goto(ty, label, 1)))
      }
    }


    /* block(foo)
       {
         ...
         when (...) foo(33);
         ...
         77
       }

       is translated to:

       mutable result;
       result =
         {
           ...
           when (...) { result = 33; goto end; }
           ...
           77
         };
       end: result

       However the second part -- foo(33) --> result = 33; goto end; --
       is done in BuildBlockReturn, not here.
    */
    ExpandBlock(expr : TExpr.Block) : TExpr
    {
      if (! expr.jump_out.EverUsed)
        expr.body
      else
      {
        def expected = expr.Type;
        def result =
          LocalValue(current_fun, expr.jump_out.Name,
                     expected, LocalValue.Kind.Plain(),
                     is_mutable = true);
        result.NeverClosurise      = true;
        result.ExpandedBlockReturn = true;

        def label_id = Util.next_id(Manager);

        def ret = expr.jump_out.ValKind :> LocalValue.Kind.BlockReturn;
        ret.result_val = result;
        ret.block_label = label_id;

        def label  = TExpr.Label(expected, label_id, TExpr.LocalRef(expected, result));
        def assign = TExpr.Assign(InternalType.Void,
                                  TExpr.LocalRef(result.Type, result),
                                  expr.body);
        def seq    = TExpr.Sequence(label.Type, assign, label);
        def deflt  = TExpr.DefaultValue(result.Type);

        TExpr.DefValIn(expected, result, deflt, seq)
      }
    }


    static CheckTypeArguments(loc : Location, meth : IMember, type_parms : list[TypeVar]) : void
    {
      when (found :
      {
        foreach (typeParm in type_parms)
          when (typeParm.IsFree)
            found(true);
        false
      })
        Message.Warning(10008, loc, $"type arguments for $meth could not be inferred");
    }

    DoWalk(ctx : Context, expr : TExpr) : TExpr
    {
      //Message.Debug($ "dowalk: $(expr.GetType()) : $expr");
      match (expr)
      {
        | TExpr.LocalFunRef(decl, _)
        | TExpr.LocalRef(decl) =>
          when (decl.ValKind is LocalValue.Kind.BlockReturn)
          {
            ReportError(messenger, $"Block $(decl.Name) was used as a first class value, this is not supported");
            decl.Register();
          }

          unless (decl.IsRegistered)
          {
            Message.Warning($"unregistered local $decl, $(decl.GetHashCode())");
            assert2(false, "!decl.IsRegistered");
          }

          decl.UseFrom(current_fun);

          match (decl.ValKind)
          {
            | LocalValue.Kind.Function(hd, _) =>
              if (ctx %&& Context.IsCalledValue)
              {
                match (hd.usage)
                {
                  | FunctionUsage.NotUsed =>
                    // we may set just-once flag only if referencing
                    // from the outer function
                    if (decl.DefinedIn.id == current_fun.id
                      && (! hd.uses_try_block || ctx %&& Context.AllowTryAtFuncLev)
                      && !hd.cannot_inline)
                    {
                      //Message.Debug($ "mark $(hd.name) just once");
                      hd.usage = FunctionUsage.UsedJustOnce
                    }
                    else
                    {
                      //Message.Debug($ "mark $(hd.name) used");
                      hd.usage = FunctionUsage.Used;
                    }

                  | FunctionUsage.UsedJustOnce => hd.usage = FunctionUsage.Used
                  | FunctionUsage.Used | FunctionUsage.UsedAsFirstClass => ()
                }
                null
              }
              else match (expr)
              {
                | TExpr.LocalFunRef(_, []) =>
                  hd.usage = FunctionUsage.UsedAsFirstClass;

                  def mark(fn)
                  {
                    fn.has_1st_class_child = true;

                    unless (fn.decl == null)
                      mark (fn.decl.DefinedIn)
                  }

                  mark(hd.decl.DefinedIn);
                  null

                | TExpr.LocalFunRef as e =>
                  hd.usage = FunctionUsage.Used;
                  PolyLocalToLambdaTransform(e)

                | _ => Util.ice()
              }

            | _ => null
          }

        | TExpr.StaticRef(f, mem, type_parms) =>
         //Message.Debug($"from=$f, mem=$mem, tp=$type_parms");
          match (mem)
          {
            | f is IField when ctx & Context.NeedLValue != 0 => MarkAsAssigned(f, expr.Location);
            | _ => MarkAsUsed(mem, expr.Location);
          }

          when (mem.IsConstructor && !mem.CanAccess(f.Fix().TypeInfo, current_type, false))
            Message.Error($"Cannot access protected '$mem' via a qualifier of type '$(mem.DeclaringType)'; the qualifier must be of type '$(current_type)' (or derived from it)");

          CheckTypeArguments(expr.Location, mem, type_parms);
          CheckTypeArguments(expr.Location, mem, f.args);
          null

        | TExpr.DefFunctionsIn(funs, body) =>
          foreach (fn in funs)
            fn.decl.Register();

          foreach (fn in funs)
          {
            def last_fun = current_fun;
            current_fun = fn;

            foreach (parm in fn.Parameters)
              parm.decl.Register();

            match (fn.body)
            {
              | FunBody.Typed(expr) =>
                fn.body = FunBody.Typed(Walk(Context.TopLevel, expr))
              | _ => assert(false)
            }

            FixupCurrentFunction();
            current_fun = last_fun;
          }

          def body = Walk(ctx & ~Context.IsCalledValue, VoidIfNull(body));
          TExpr.DefFunctionsIn(body.Type, funs, body)

        | TExpr.ImplicitValueTypeCtor =>
          match (expr.FixedType())
          {
            | Fun(_, FixedType.Class(tycon, _))
            | Class(tycon, _) => MarkAsUsed(tycon, expr.Location)
            | t => Util.ice($"unexpected type $t")
          }

          null

        | TExpr.FieldMember(obj, fld) =>
          if (ctx %&& Context.NeedLValue)
            MarkAsAssigned(fld, expr.Location);
          else
            MarkAsUsed(fld, expr.Location);

          TExpr.FieldMember(Walk(obj), fld)

        | TExpr.ConstantObjectRef(_, mem) =>
          MarkAsUsed(mem, expr.Location);
          def meth = Typer3.SingleMemberLookup(mem.DeclaringType, "_N_constant_object_generator");
          def res =
            match (expr.ty.Hint)
            {
              | Some(FixedType.Fun(FixedType.Void, FixedType.Class as to)) =>
                // FIXME this doesn't seem to be the right place for such a message
                Message.Warning(10009, $"Using a constant object reference directly. You probably have meant to write `$(mem.DeclaringType.FullName)()'");
                TExpr.StaticRef(expr.Location, expr.ty, to, meth, [])

              | _ => Util.ice("Wrong type of constant object!")
            };
          res

        | TExpr.PropertyMember(obj, prop) =>
          MarkAsUsed(prop, expr.Location);
          def obj2 = Walk(obj);
          def meth =  if (ctx %&& Context.NeedLValue) prop.GetSetter()
                      else                            prop.GetGetter();
          when (meth == null)
          {
            assert(!(ctx %&& Context.NeedLValue), "should be rejected by Typer");
            ReportError(messenger, $ "the get accessor is unavailable for property $(prop.Name)");
          }

          def objType = obj2.Type;

          def (memberTypeInfo, isFromThis) = match(obj)
          {
            | TExpr.This => (prop.DeclaringType, true)
            | TExpr.Base with isFromThis = true
            | _          with isFromThis = false => (objType.Fix().TypeInfo, isFromThis)
          };

          unless (meth.CanAccess(memberTypeInfo, current_type, isFromThis))
            if (isFromThis)
              Message.Error($"property accessor $meth is inaccessible");
            else
              Message.Error($"Cannot access protected member '$(prop.DeclaringType).$(prop.Name)' via a qualifier of type '$(prop.DeclaringType)'; the qualifier must be of type '$(current_type)' (or derived from it)");

          // for setters the argument list is fixed later
          def ty = objType.Fix().TypeOfMember(meth);
          def is_base = IsBaseRef(obj2);
          // Message.Debug($ "prop $meth ty=$ty $obj2 $(IsBaseRef(obj2))");

          when (is_base &&  meth.IsAbstract)
            ReportError(messenger, $"cannot call an abstract base $meth");

          def the_ref = TExpr.MethodRef(ty, obj2, meth, [], is_base);

          if (ctx %&& Context.IsIndexerRef)
            the_ref
          else if (prop.IsIndexer)
          {
            ReportError(messenger, $"Property `$(prop.Name)' was used as a first class value");
            the_ref
          }
          else TExpr.Call(the_ref, [], false)


        | TExpr.StaticPropertyRef(from, prop) =>
          MarkAsUsed(prop, expr.Location);
          def meth =  if (ctx %&& Context.NeedLValue) prop.GetSetter()
                      else                            prop.GetGetter();
          assert(meth != null);

          def the_ref = TExpr.StaticRef(from.TypeOfMember(meth), from, meth, []);

          if (ctx %&& Context.IsIndexerRef)
            the_ref
          else if (prop.IsIndexer)
          {
            ReportError(messenger, $ "Property `$(prop.Name)' was used as a first class value");
            the_ref
          }
          else TExpr.Call(the_ref, [], false)

        | TExpr.EventMember(obj, ev) =>
          MarkAsUsed(ev, expr.Location);

          def obj = Walk(obj);
          mutable field = null;

          when (ev.DeclaringType.Equals(current_type))
            field = (ev :> EventBuilder).storage_field;

          if (field != null)
            TExpr.FieldMember(obj, field);
          else
          {
            ReportError(messenger, $"$(ev) can only appear on the left-side of a += or -=");
            TExpr.Error()
          }

        | TExpr.StaticEventRef(from, ev) =>
          MarkAsUsed(ev, expr.Location);

          mutable field = null;

          when (ev.DeclaringType.Equals(current_type))
            field = (ev :> EventBuilder).storage_field;

          if (field != null)
            TExpr.StaticRef(from, field, [])
          else
          {
            ReportError(messenger, $"$(ev) can only appear on the left-side of a += or -=");
            TExpr.Error()
          }

        | TExpr.MethodRef(obj, meth, type_parms, notvirt) =>
          MarkAsUsed(meth, expr.Location);
          def is_base = IsBaseRef(obj);
          def notvirt = notvirt || is_base;

          //Message.Debug($"$(ctx %&& (Context.IsCalledValue | Context.IsDelegeteCtorParm)) obj=$(obj.GetType())/$obj ");

          when (is_base && meth.IsAbstract)
            ReportError(messenger, $"cannot call an abstract base $meth");

          def isFromThis = obj is TExpr.This || obj is TExpr.Base;
          def objType = obj.Type;
          def fixedTy = objType.Fix();

          def memberTypeInfo =
            match (fixedTy)
            {
              | FixedType.StaticTypeVarRef => meth.DeclaringType
              | _                          => fixedTy.TypeInfo ?? meth.DeclaringType
            };

          unless (meth.CanAccess(memberTypeInfo, current_type, isFromThis))
            if (isFromThis)
              Message.Error($"$meth is inaccessible");
            else
              Message.Error($"Cannot access protected method '$(meth.DeclaringType).$(meth.Name)' via a qualifier of type '$objType'; the qualifier must be of type '$(current_type)' (or derived from it)");

          CheckTypeArguments(expr.Location, meth, type_parms);

          if (ctx %&& (Context.IsCalledValue | Context.IsDelegeteCtorParm))
            TExpr.MethodRef(Walk(obj), meth, type_parms, notvirt)
          else
            MethodToLambdaTransform(expr, obj, meth, type_parms, notvirt)

        | TExpr.Call(TExpr.Delayed(dt), parms, is_tail) =>
          // when typing overloads we put actual parameters into DtKind. Try extract and use it...
          def res = match(dt.DtKind)
          {
            | Typer.DelayedTyping.Kind.Resolved(expr = expr2, parms = parms2) =>
              def expr3 = Unfold(expr2);
              if (parms2 == null)
                TExpr.Call(expr.Location, expr.Type, expr3, parms, is_tail)
              else // typing was infer new parameters expressions (for example, when typing extension methods). See teg: SetResolvedCallParameters
                TExpr.Call(expr.Location, expr.Type, expr3, parms2, is_tail);

            | _ => Util.ice("not resolved delayed typing?");
          };
          DoWalk(ctx, res)

        | TExpr.Call(func, parms, false) =>
          match (Unfold(func))
          {
            | TExpr.StaticRef(_, meth, _) as sr
              when meth.DeclaringType.IsDelegate && meth.MemberKind == MemberKinds.Constructor =>
              def invokeArgsCount =
                {
                  assert(sr.mem.DeclaringType.LookupMemberAvailable);
                  def mems = sr.mem.DeclaringType.LookupMemberImpl("Invoke");
                  def mems = $[x | x is IMethod in mems];
                  match (mems)
                  {
                    | [one] => one.GetParameters().Length
                    | _ => Util.ice("not exactly one Invoke method?")
                  }
                };

              match (parms)
              {
                | [parm] =>
                  match (Unfold(parm.expr))
                  {
                    | TExpr.MethodRef(_, meth, _, _)
                        when meth.GetParameters().Length == invokeArgsCount =>
                        //tuple/detuple case is handled by method->lambda transform
                      parm.expr = Walk(Context.IsDelegeteCtorParm, parm.expr)

                    | TExpr.StaticRef(_, meth is IMethod, _)
                        when meth.GetParameters().Length != invokeArgsCount =>
                        //to handle tuple/detuple force creation of wrapper
                      def e = parm.expr;
                      parm.expr = Walk(TExpr.TypeConversion(e.Location, e.ty, e, e.ty, ConversionKind.UpCast()));

                    | _ => parm.expr = Walk(parm.expr)
                  }
                | _ => Util.ice()
              }

            | TExpr.MethodRef(_, IMethod where (BuiltinKind = ExtensionMethod), _, _) => ()
            | TExpr.OpCode as f when Typer.IsNullableBinaryOperator(f.Type) => () // Prevent walking parameters
            | unfold =>
              match (parms)
              {
                | p :: ps =>
                  mutable check_ps = parms;
                  when (unfold is TExpr.StaticRef)
                  {
                    p.expr = Walk(ctx & Context.AllowTry, p.expr);
                    check_ps = ps;
                  }
                  foreach (p in check_ps)
                    if (p.kind == ParmKind.Out)
                      p.expr = Walk(Context.NeedLValue, p.expr);
                    else
                    {
                      def get_default_value(e)
                      {
                        | TExpr.MacroEnvelope(expanded = e) as t => 
                          def n = get_default_value(e);
                          if (n : object != e) n else t

                        // if function already registered we take its call, not whole creation
                        | DefFunctionsIn(_, LocalFunRef(decl = d) as e) when d.IsRegistered => e
                        | e => e
                      }
                      // if we call local function and parameter is default, we must split lambda default parameters creation and call, creation only one time
                      def expr = if (p.IsByDefault) get_default_value(p.expr) else p.expr;
                      p.expr = Walk(expr);
                    }
                | [] => ()
              }
          }

          if (IsOperator(func))
          {
            match (OperatorKind(func))
            {
              | BuiltinMethodKind.CallWithCast(meth') =>
                assert(meth' != null);
                // XXX possibly wrong type
                def (ty, vars) = meth'.GetFreshType();
                BuildConversion(
                  TExpr.Call(meth'.ReturnType,
                              TExpr.StaticRef(ty,
                                               meth'.DeclaringType.GetMemType(),
                                               meth', vars), parms, false),
                  expr.Type.Fix(), ConversionKind.Unspecified())

              | _ => assert(false)
            }
          }
          else match (Unfold(func))
          {
            | TExpr.PropertyMember(_, prop) when prop.IsIndexer
            | TExpr.StaticPropertyRef(_, prop) when prop.IsIndexer =>
              def ctx = Context.IsCalledValue %| Context.IsIndexerRef  %| (ctx & Context.NeedLValue);
              TExpr.Call(Walk(ctx, func), parms, false)

            | TExpr.ConstantObjectRef(from, mem) =>
              TExpr.StaticRef(from, mem, []) // skip the call

            | TExpr.ImplicitValueTypeCtor as ivtc =>
              ivtc.ty = expr.ty;
              ivtc

            | TExpr.MethodRef(obj, IMethod where (BuiltinKind = ExtensionMethod(impl)) as im, type_parms, _) as func =>
              //Message.Debug($"expand to $impl");
              def from = impl.DeclaringType.GetMemType();
              def fnt =
                {
                  def (parms, ret) = func.FixedType().FunReturnTypeAndParms().Value;
                  FixedType.ConstructFunctionType(obj.Type :: parms, ret)
                };
              def type_parms =
                ( match (obj.Type.Fix().GetInstantiatedSuperType(im.DeclaringType))
                  {
                    | FixedType.Class(_, parms) => parms
                  }) + type_parms;
              def fn = TExpr.StaticRef(fnt, from, impl, type_parms);
              Walk(Context.IsCalledValue,
                    TExpr.Call(expr.Type, fn, Parm(obj) :: parms, false))

            | TExpr.LocalRef(LocalValue where (ValKind = LocalValue.Kind.BlockReturn) as decl) =>
              BuildBlockReturn(ctx, expr.Type, decl, parms)

            | TExpr.OpCode("==.ref")
            | TExpr.OpCode("!=.ref") =>
              //assert2(false, "==.ref");
              match (parms)
              {
                | [p1, p2] =>
                  def e1 = StripImplicitConversion(p1.expr);
                  def e2 = StripImplicitConversion(p2.expr);

                  def t1 = e1.Type.Fix();
                  def t2 = e2.Type.Fix();

                  def prob =
                    if (t1.IsSystemObject && !t2.CanBeNull)
                      t2
                    else if (t2.IsSystemObject && !t1.CanBeNull)
                      t1
                    else
                      null;

                  if (prob != null)
                    Message.Warning(10011, $"comparing a value type $prob to System.Object (a `null' literal?) with reference equality");
                  else when (!t1.IsSystemObject && !t2.IsSystemObject)
                    Message.Warning(10011, $"comparing values of types $t1 and $t2 with reference equality");

                  TExpr.Call(Unfold(func), parms, false)

                | _ => assert(false)
              }

            | TExpr.OpCode(opCode) as f when Typer.IsNullableBinaryOperator(f.Type) => TransformNullableOperators(ctx, f.Location, expr.Type, opCode, parms)
            | _ =>
              if ((ctx %&& Context.IsTail) && IsSelfCall(func) && parms.ForAll(p => p.kind == ParmKind.Normal))
                TExpr.SelfTailCall(func, parms)
              else
              {
                def ctx =
                  if (ctx %&& Context.AllowTry)
                    Context.AllowTryAtFuncLev | Context.IsCalledValue
                  else
                    Context.IsCalledValue;

                TExpr.Call(Walk(ctx, func), parms, false)
              }
          }

        | TExpr.Call
        | TExpr.SelfTailCall => assert(false)


        | TExpr.Assign(target, source) =>
          def event_expr = ConvertEventExpr(target, source);
          if (event_expr != null)
            event_expr
          else
          {
            def transform_call =
              match (Unfold(target))
              {
                | TExpr.PropertyMember
                | TExpr.StaticPropertyRef
                | TExpr.Call
                | TExpr.DebugInfo(TExpr.PropertyMember, _)
                | TExpr.DebugInfo(TExpr.StaticPropertyRef, _)
                | TExpr.DebugInfo(TExpr.Call, _)
                    => true
                | _ => false
              };

            def target = Walk(Context.NeedLValue, target);
            def src_ctx =
              match (target)
              {
                | TExpr.DebugInfo(TExpr.LocalRef(decl), _)
                | TExpr.LocalRef(decl) =>
                  if (decl.ExpandedBlockReturn)
                    ctx & Context.AllowGotoAndAllThrows
                  else
                    ctx & Context.AllowGotoAndAllThrows & ~Context.AllowGoto

                | _ => Context.Clean
              };
            def source = Walk(src_ctx, source);

            match (target)
            {
              | TExpr.DebugInfo(TExpr.Call as t, _) when transform_call
              | TExpr.Call as t when transform_call =>
                //TODO: this case also should be done in Typer3.TupleParms
                match (t.func.FixedType())
                {
                  //pack to tuple
                  | FixedType.Fun(FixedType.Tuple([_key, _value]), FixedType.Void) when t.parms.Length > 1 =>
                    def types = t.parms.Map(
                      fun(fp)
                      {
                        assert(fp.required_type != null);
                        fp.required_type
                      });
                    def exprs = t.parms.Map(fp => Typer.ImplicitCast(fp.expr, fp.required_type));
                    def parm = TExpr.Tuple(FixedType.Tuple(types), exprs);
                    t.parms = [Parm(parm)];
                    t.parms += [Parm(source)];
                    t.ty = InternalType.Void;
                    t

                  //unpack tuple
                  | FixedType.Fun(FixedType.Tuple(_a1 :: _a2 :: _more :: _ as lst), FixedType.Void) when t.parms.Length == 1 =>
                    def tupled = NList.Hd(t.parms).expr;
                    def cache =
                      LocalValue(current_fun, Util.tmpname("tupl_cache"),
                                  tupled.Type, LocalValue.Kind.Plain(),
                                  is_mutable = false);
                    cache.Register();
                    cache.UseFrom(current_fun);

                    def types =
                      match (tupled.FixedType())
                      {
                        | Tuple(lst) => lst
                        | _ => Util.ice()
                      };

                    def len = types.Length;
                    Util.cassert(lst.Length == len + 1);
                    mutable pos = -1;
                    def PlainRef(decl : LocalValue) : TExpr
                    {
                      assert(decl != null);
                      TExpr.LocalRef(decl.Type, decl)
                    }
                    def parms = types.Map(
                      fun(ty)
                      {
                        pos++;
                        Parm(TExpr.TupleIndexer(ty, PlainRef(cache), pos, len))
                      });
                    t.parms = parms;
                    t.parms += [Parm(source)];
                    t.ty = InternalType.Void;
                    TExpr.DefValIn(cache, tupled, t)

                  | _ =>
                    t.parms += [Parm(source)];
                    t.ty = InternalType.Void;
                    t
                }

              | _ when transform_call => assert(false)
              | _ => TExpr.Assign(target, source)
            }
          }


        | TExpr.DefValIn(name, val, body) =>
          name.Register();
          // goto is allowed inside value definition, because
          // we do the store at the end anyway
          def val = Walk(ctx & Context.AllowGotoAndAllThrows, val);
          def body = Walk(ctx, VoidIfNull(body));
          TExpr.DefValIn(name, val, body)

        | TExpr.Cache(d, body) =>
          def body = d.Finalize(current_fun, body);
          Walk(ctx, body)


        | TExpr.Match(matched_value, cases) =>
          def cast_to = expr.Type.Fix();
          foreach (case in cases)
          {
            mutable pats = [];
            foreach ((pat, expr, assigns) in case.patterns)
            {
              def pat = WalkPattern(pat);
              def assigns = assigns.Map(
                fun(decl, val)
                {
                  unless (decl.IsRegistered)
                    decl.Register();
                  (decl, Walk(val))
                });
              pats = (pat, Walk(expr), assigns) :: pats;
            }
            case.patterns = NList.Rev(pats);
            case.body =
              BuildEnforcement(Walk(ctx, VoidIfNull(case.body)), cast_to);
          }
          // We allow try here because matched value is pushed on the
          // stack first so it is clean (if it was).
          def matched = Walk(ctx & Context.AllowTry, matched_value);
          TExpr.Match(expr.Location, null, matched, cases)


        | TExpr.Throw(exn) =>
          // exception can be null for `throw;' rethrow expression
          if (exn != null)
            TExpr.Throw(Walk(exn))
          else
          {
            unless (ctx %&& Context.AllowEmptyThrow)
              ReportError(messenger, "rethrow expression is only allowed in catch clause");
            expr
          }

        | TExpr.TryFinally(body, handler) =>
          current_fun.uses_try_block = true;

          TExpr.TryFinally(Walk(ctx & Context.AllowGotoAndAllThrows, body),
                            IgnoreExpr(Walk(Context.AllowTry, handler)))

        | TExpr.Try(body, cases) =>
          def register_case(case)
          {
            | Try_case.Catch(exn, _)
            | Try_case.Filter(exn, _, _) =>
              exn.Register();
            | Try_case.Fault => ()
          }
          foreach (case in cases)
            register_case(case);
          current_fun.uses_try_block = true;

          def walk_case(case)
          {
            | Try_case.Catch(exn, handler) =>
              Try_case.Catch(exn, Walk(Context.AllowGotoAndAllThrows, handler))
            | Try_case.Filter(exn, filter, handler) =>
              Try_case.Filter(exn, Walk(Context.AllowGotoAndSuch, filter),
                               Walk(Context.AllowGotoAndAllThrows, handler))
            | Try_case.Fault(handler) =>
              Try_case.Fault(Walk(ctx & Context.AllowGotoAndAllThrows, handler))
          }
          TExpr.Try(Walk(ctx & Context.AllowGotoAndAllThrows, body), cases.Map (walk_case))

        | TExpr.Literal(Literal.Integer as i) =>
          def t = expr.Type.Fix();
          unless (i.treat_as.Equals(t))
          {
            if (Typer.LiteralConversionPossible(i, t))
              i.treat_as = t :> FixedType.Class;
            else
            {
              Message.Warning ($ "literal type $(i.treat_as), expression type $t, literal is $i");
              assert(false);
            }
          }
          null


        | TExpr.Literal => null
        | TExpr.This =>
          when (this_ptr_decl == null)
          {
            this_ptr_decl =
              LocalValue(
                top_level_fun.GetHeader(),
                "_N_closurised_this_ptr",
                // cannot use expr.Type, because this can be base
                current_type.GetMemType(),
                LocalValue.Kind.ClosurisedThisPointer(),
                is_mutable = false);
            this_ptr_decl.Register();
          }
          this_ptr_decl.UseFrom(current_fun);
          TExpr.LocalRef(this_ptr_decl);


        | TExpr.Base(meth) =>
          MarkAsUsed (meth, expr.Location);
          null


        | TExpr.TypeConversion(expr, t, ConversionKind.UpCast, _) when t.Equals(InternalType.Void) && expr.Type.TryUnify(InternalType.Void)
        | TExpr.TypeConversion(expr, _, ConversionKind.IgnoreValue, _)
          when expr.Type.TryUnify(InternalType.Void) =>
          expr.Type.ForceUnify(InternalType.Void);
          Walk(ctx, expr)

        | TExpr.TypeConversion(expr, t, DownCast(inCheckedContext), _) when t.IsNullable && !expr.Type.Equals(InternalType.Object) => 
          WrapToNullable(ctx, expr, t, inCheckedContext)

        | TExpr.TypeConversion(expr, t, DownCast(inCheckedContext), _) when expr.Type.IsNullable => 
          UnwrapNullable(ctx, expr, t, inCheckedContext)

        | TExpr.TypeConversion(expr, t, Implicit, _) when t.IsNullable => NullableImplicitConversion(ctx, expr, t)
        | TExpr.TypeConversion(expr, t, kind, _) => BuildConversion(Walk(expr), t, kind)
        | TExpr.Sequence(e1, DebugInfo(null, _) as e2) => TExpr.Sequence(Walk(ctx, e1), e2);
        | TExpr.Sequence(e1, e2) =>
          def e1 = IgnoreExpr(Walk(ctx & Context.AllowGotoAndAllThrows, e1));
          TExpr.Sequence(e1, Walk(ctx & ~Context.IsCalledValue, e2))


        | TExpr.Tuple(args) =>
          TExpr.Tuple(Walks(args))


        | TExpr.TupleIndexer(obj, k, n) =>
          TExpr.TupleIndexer(Walk(obj), k, n)


        | TExpr.Array(args, dimensions) =>
          TExpr.Array(Walks(args), Walks(dimensions))


        | TExpr.TypeOf | TExpr.MethodOf | TExpr.CtorOf | TExpr.FieldOf  => null

        | TExpr.ClosureObjectOf(e) => TExpr.ClosureObjectOf(Walk(e))
        | TExpr.ClosureFieldOf(e)  => TExpr.ClosureFieldOf(Walk(e))

        | TExpr.ArrayIndexer(obj, args) =>
          TExpr.ArrayIndexer(Walk(obj), Walks(args))


        | TExpr.OpCode => null

        | TExpr.CacheRef
        | TExpr.Delayed => Walk(ctx, Unfold(expr))
        | TExpr.Error => null
        | TExpr.DebugInfo(null, _) => null

        | TExpr.DebugInfo(e, pe) =>
            def e = Walk(ctx, e);
            TExpr.DebugInfo(expr.Location, e.ty, e, pe);

        | TExpr.Goto =>
          unless (ctx %&& Context.AllowGoto)
            ReportError(messenger, "goto (block return?) is not allowed inside expressions");

          null


        | TExpr.Label(lab, body) =>
          TExpr.Label(lab, Walk(ctx, body))


        | TExpr.MacroEnvelope(lab, orig, body, epe) =>
          TExpr.MacroEnvelope(lab, orig, Walk(ctx, body), epe)


        | TExpr.Block as b =>
          Walk(ctx, ExpandBlock(b))


        | TExpr.If(cond, e1, e2, l1, l2) =>
          TExpr.If(Walk(cond), Walk(ctx, e1), Walk(ctx, e2), l1, l2)


        | TExpr.HasType(e, t) =>
          TExpr.HasType(Walk(e), t)


        | TExpr.DefaultValue => null

        | TExpr.Switch
        | TExpr.MultipleAssign
        | TExpr.MethodAddress
        | TExpr.Def
        | TExpr.Use => assert(false)
      }
    }


    static StripImplicitConversion(expr : TExpr) : TExpr
    {
      match (expr)
      {
        | TExpr.TypeConversion(e, _, ConversionKind.MethodCall(m), _) when m.from.IsNullable && m.mem.Name == "op_Implicit" => e
        | TExpr.TypeConversion(e, _, ConversionKind.Implicit, _) => e
        | TExpr.Call(TExpr.StaticRef(_, IMethod where (Name="op_Implicit"), []), [parm], _) => parm.expr
        | e => e
      }
    }

    UnwrapNullable(ctx : Context, expr : TExpr, target : TypeVar, inCheckedContext : bool) : TExpr
    {
      assert2(!target.IsNullable);
      assert2(target.IsValueType);
      assert2(expr.Type.IsNullable);

      def resExpr1 = <[ $(expr : typed).Value :> $(target : typed) ]>;
      def resExpr2 = if (inCheckedContext) <[ checked($resExpr1) ]> else <[ unchecked($resExpr1) ]>;
      def resExpr3 = typer.TypeExpr(resExpr2, target);
      def resExpr4 = Walk(ctx, resExpr3);
      resExpr4
    }

    WrapToNullable(ctx : Context, expr : TExpr, target : TypeVar, inCheckedContext : bool) : TExpr
    {
      assert2(target.IsNullable);
      assert2(expr.Type.IsValueType);

      def unwrappedTargetType = (target.Fix() :> FixedType.Class).args.Head;
      def exprIsNullable = expr.Type.IsNullable;

      def v = if (exprIsNullable) <[ x ]> else <[ $(expr : typed) ]>;

      def resExpr1 = if (exprIsNullable) <[ $v.Value ]> else v;
      def resExpr2 = <[ System.Nullable.[$(unwrappedTargetType : typed)]($resExpr1 :> $(unwrappedTargetType : typed)) ]>;
      def resExpr3 = if (inCheckedContext) <[ checked($resExpr2) ]> else <[ unchecked($resExpr2) ]>;

      def resExpr4 = 
        if (exprIsNullable)
          <[ 
            def x = $(expr : typed);
          
            if (x.HasValue)
              $resExpr3
            else
              System.Nullable.[$(unwrappedTargetType : typed)]() // null
          ]>
        else
          resExpr3;

      def resExpr5 = typer.TypeExpr(resExpr4, target);
      def resExpr6 = Walk(ctx, resExpr5);
      resExpr6
    }

    NullableImplicitConversion(ctx : Context, expr : TExpr, target : TypeVar) : TExpr
    {
      assert2(target.IsNullable);

      def exprType      = expr.Type;
      def wrappedType   = target.Fix() :> FixedType.Class;
      def unwrappedType = wrappedType.args.Head;

      assert(exprType.IsValueType);

      def resExpr1 = 
        if (exprType.IsNullable)
          <[ 
            def x = $(expr : typed);
            if (x.HasValue) 
              System.Nullable.[$(unwrappedType : typed)](x.GetValueOrDefault() : $(unwrappedType : typed))
            else
              System.Nullable.[$(unwrappedType : typed)]()
          ]>
        else
          <[ System.Nullable.[$(unwrappedType : typed)]($(expr : typed) : $(unwrappedType : typed)) ]>;

      def resExpr2 = typer.TypeExpr(resExpr1, wrappedType);
      def resExpr3 = Walk(ctx, resExpr2);
      resExpr3
    }

    TransformNullableOperators(ctx : Context, loc : Location, retType : TypeVar, opCodeName : string, parms : list[Parm]) : TExpr
    {
      def opCode = Typer.GetBinaryOperatorSymbolOrDefault(opCodeName);
      match (parms)
      {
        | [p1, p2] =>
          def e1 = StripImplicitConversion(p1.expr);
          def e2 = StripImplicitConversion(p2.expr);

          def t1 = e1.Type.Fix();
          def t2 = e2.Type.Fix();

          def is1Nullable = t1.IsNullable;
          def is2Nullable = t2.IsNullable;

          def retTypeIsBool = retType.Fix().Equals(InternalType.Boolean);

          def warnDangerousOperator(opCode)
          {
            def ch = if (opCode.Length > 0) opCode[0] else '\0';

            when ((ch == '<' || ch == '>') && retTypeIsBool)
              Message.Warning(10012, loc, $"Using the '$opCode' operator with nullable types is dangerous. They are implemented only for compatibility with C#.");
          }

          //def nullableTi = InternalType.Generic_Nullable_tc;

          match (e1, e2)  // is1Nullable || is2Nullable
          {
            | (TExpr.Literal(Literal.Null), e) when is2Nullable && retTypeIsBool
            | (e, TExpr.Literal(Literal.Null)) when is1Nullable && retTypeIsBool =>
              def resExpr1 =
                match (opCode)
                {
                  | "==" => typer.TypeExpr(<[ ! $(e : typed).HasValue ]>)
                  | "!=" => typer.TypeExpr(<[   $(e : typed).HasValue ]>)
                  | _ =>
                    Message.Warning(458, loc, "The result of the expression is always false.");
                    typer.TypeExpr(<[ false ]>)
                };
              def resExpr2 = Walk(ctx, resExpr1);
              resExpr2

            | _ when is1Nullable && is2Nullable =>
              warnDangerousOperator(opCode);

              def op = <[ $(opCode : dyn) ]>;
              def cmpExpr =
                match (opCode)
                {
                  | "<" 
                  | "<=" 
                  | ">" 
                  | ">=" => <[ (v1.HasValue && v2.HasValue) && $op(v1.GetValueOrDefault(), v2.GetValueOrDefault()) ]>
                  | "==" => <[ v1.GetValueOrDefault() == v2.GetValueOrDefault() && v1.HasValue == v2.HasValue ]>
                  | "!=" => <[ v1.GetValueOrDefault() != v2.GetValueOrDefault() || v1.HasValue != v2.HasValue ]>
                  | _    => 
                    <[  if (v1.HasValue && v2.HasValue)
                          System.Nullable.[_]($op(v1.GetValueOrDefault(), v2.GetValueOrDefault()))
                        else
                          System.Nullable.[_]()
                    ]>
                };

              def finalExpr = 
                <[
                  def v1 = $(e1 : typed);
                  def v2 = $(e2 : typed);

                  $cmpExpr
                ]>;

              def resExpr1 = typer.TypeExpr(finalExpr);
              def resExpr2 = Walk(ctx, resExpr1);
              resExpr2

            | _ when retTypeIsBool =>
              warnDangerousOperator(opCode);

              def (nullableExpr, valueExpr) = if (is1Nullable) (e1, e2) else (e2, e1);
              def rewritenExpr =
                if (opCode == "!=")
                  <[
                    def nullableVal = $(nullableExpr : typed);
                    !nullableVal.HasValue || $(opCode : dyn)($(valueExpr : typed), nullableVal.GetValueOrDefault())
                  ]>
                else if (is1Nullable)
                  <[
                    def nullableVal = $(nullableExpr : typed);
                    nullableVal.HasValue && $(opCode : dyn)(nullableVal.GetValueOrDefault(), $(valueExpr : typed))
                  ]>
                else
                  <[
                    def nullableVal = $(nullableExpr : typed);
                    nullableVal.HasValue && $(opCode : dyn)($(valueExpr : typed), nullableVal.GetValueOrDefault())
                  ]>;

              def resExpr1 = typer.TypeExpr(rewritenExpr);
              def resExpr2 = Walk(ctx, resExpr1);
              resExpr2

            | _ when !is1Nullable && !is2Nullable =>
              def rewritenExpr = <[ System.Nullable.[_]($(opCode : dyn)($(e1 : typed), $(e2 : typed))) ]>;
              def resExpr1 = typer.TypeExpr(rewritenExpr, retType);
              def resExpr2 = Walk(ctx, resExpr1);
              resExpr2

            | _ =>
              def (nullableExpr, valueExpr) = if (is1Nullable) (e1, e2) else (e2, e1);
              def calcExpr =
                if (is1Nullable)
                  <[ $(opCode : dyn)(nullableVal.GetValueOrDefault(), $(valueExpr : typed)) ]>
                else
                  <[ $(opCode : dyn)($(valueExpr : typed), nullableVal.GetValueOrDefault()) ]>;
              def rewritenExpr =
                  <[
                    def nullableVal = $(nullableExpr : typed);

                    if (nullableVal.HasValue)
                      System.Nullable.[_]($calcExpr)
                    else
                      System.Nullable.[_]()
                  ]>;

              def resExpr1 = typer.TypeExpr(rewritenExpr, retType);
              def resExpr2 = Walk(ctx, resExpr1);
              resExpr2
          }

        | _ => assert(false, "Wrong number of arguments.")
      }
    }
  }
}
