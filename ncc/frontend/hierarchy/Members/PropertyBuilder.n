using System;
using System.Diagnostics;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Utility;

using SR  = System.Reflection;
using SRE = System.Reflection.Emit;
using PT  = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  public partial class PropertyBuilder : MemberBuilder, IProperty, IBackendMember
  {
    is_mutable : bool;
    getter : MethodBuilder;
    setter : MethodBuilder;
    internal parms : list [FixedType];
    mutable parent_property : IProperty = null;
    [Accessor(flags = Override)]
    protected mutable _bodyLocation : Location;

    internal mutable property_builder : SRE.PropertyBuilder;

    /// Parsed representation (AST) of property.
    /// Note: available only in CompletionMode
    /// (if Manager.IsIntelliSenseMode = true)
    public new Ast : PT.ClassMember.Property { get { base.Ast :> PT.ClassMember.Property } }

    // Contains refernce to autogenerated field for automatic properties.
    [Accessor] autoPropertyField : option[IMember] = None();
    [Accessor] isAutoProperty : bool;

    public this (par : TypeBuilder, propertyAst : PT.ClassMember.Property)
    {
      base (par, propertyAst);

      when (propertyAst.getter.IsNone && propertyAst.setter.IsNone)
        Message.Error(propertyAst.BodyLocation, "expecting property getter/setter");

      //TODO: Add BodyLocation support to fields and event
      _bodyLocation = propertyAst.BodyLocation;
      is_mutable = Option.IsSome (propertyAst.setter);
      ty = par.BindFixedType (propertyAst.SignatureType);

      parms = propertyAst.parameters.Map(parm => par.BindFixedType(parm.Type));

      if (par.IsInterface)
      {
        when (propertyAst.initializer.IsSome)
          Message.Error("initializer cannot be used in interfaces");
      }
      else
      {
        def field = Nemerle.Compiler.MainParser.TryExpandAutoproperty(propertyAst);

        when (field != null)
        {
          isAutoProperty = true;
          def memberBuilder = par.DefineAndReturn(field);

          // Set automatic property field.
          when (memberBuilder != null)
            autoPropertyField = Some(memberBuilder);
        }
      }

      def process_accessor (_ : option [PT.ClassMember.Function])
      {
        | Some (fn) =>
          when (fn.Env == null)
            fn.SetEnv(this.Env);
          Util.locate (fn.Location, UpdateEmbeddedModifiers (attributes, ref fn.modifiers.mods));
          def method = Manager.ComponentsFactory.CreateMethodBuilder (par, fn, is_property = true);
          method.MarkWithSpecialName();
          declaring_type.AddMember (method);
          method
        | None => null
      }

      getter = process_accessor (propertyAst.getter);
      setter = process_accessor (propertyAst.setter);

      ty.CheckAccessibility (this, accessibility);

      // we'll check for the get/set usage methods instead
      m_has_been_used = true
    }

    public IsMutable : bool
    {
      get { is_mutable }
    }

    public IsIndexer : bool
    {
      get
      {
        !(parms is [])
      }
    }

    public override MemberKind : MemberKinds {  get { MemberKinds.Property } }

    public override HasBeenUsed : bool {
      set {
        base.HasBeenUsed = value;
        // FIXME: only one of them should be used, but typing knows it a
        //        little bit too late
        when (setter != null) setter.HasBeenUsed = value;
        when (getter != null) getter.HasBeenUsed = value;
      }
    }

    public GetPropertyInfo() : SRE.PropertyBuilder
    {
      assert(property_builder != null);
      property_builder
    }

    public Getter : IMethod { get { GetGetter() } }
    public CanRead : bool { get { Getter != null } }

    public GetGetter() : IMethod
    {
      if (getter == null && parent_property != null)
        parent_property.GetGetter()
      else
        getter
    }

    public Setter : IMethod { get { GetSetter() } }
    public CanWrite : bool { get { Setter != null } }

    public GetSetter() : IMethod
    {
      if (setter == null && parent_property != null)
        parent_property.GetSetter()
      else
        setter
    }

    public GetParameters() : list [FixedType]
    {
      parms
    }

    public UpdateParentProperty (parent_property : IProperty) : void
    {
      this.parent_property = parent_property;
    }

    GetHandle() : SR.MemberInfo implements IBackendMember.GetHandle
    {
      assert(property_builder != null);
      property_builder
    }

    /**
     * Performs attributes checks for properties definitions.
     */
    public override CheckAttributes() : void
    {
      // make sure no static indexers get defined
      when (IsStatic && IsIndexer)
        Message.FatalError2(loc, $"indexer properties are not allowed to be static in $this");

      // most of the checks are common with the methods and events:
      check_method_like_attributes("property", "properties");
    }

    protected override MacroTarget : MacroTargets
    {
      get { MacroTargets.Property }
    }

    protected override MacroSelfParams : list [PT.SyntaxElement]
    {
      get { [PT.SyntaxElement.TypeBuilder (declaring_type), PT.SyntaxElement.PropertyBuilder (this)] }
    }
  }
}
