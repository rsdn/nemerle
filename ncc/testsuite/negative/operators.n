using Nemerle.Collections;

module M {
  [Record]
  class X {}
  Main () : void
  {
    def _ = 1 * null; // E: in argument #2 \(right\), needed a int, got.*null
    def _ = "foo" + X(); // E: in argument #2 \(right\), needed a string, got M.X
    def _ = X() + "foo"; // E: in argument #1 \(left\), needed a string, got M.X

    def h = Hashtable (); // OK
    h [ "foo" ] = "bar"; // OK
    h [ "dupa" ] = 3; // E: expected .*string.*got int in assignment
    def _ = "foo" : System.Type; // E: expected System.Type.* got .*string.*in type-enforced expression

          def loop (x, x2) {
            match ((x, x2)) {
              | [] => x // E: the matched value.*was expected to be compatible with.*list
            }
          }

          loop ([], []);


         def loop (x, x2) {
            | [] => x // E: the matched value.*was expected to be compatible with.*list
          }

          loop ([], []);

    ()
  }
}

namespace Undefined {
  public class Foo {

          public static FooRun () :  void
          {
                  mutable  k =  Foo ();

                  mutable  i = ~ k; (); // E: cannot find the operator

          }
  }
}
