// NO-TEST

(*
public variant list ('a) 
{
  | Cons { hd : 'a; tl : list ('a); }
  | Nil {}
}

  
namespace Nemerle.Collections 
{
  public module List
  {
    public 'a is_empty (l : list ('a)) : bool {
      match (l) {
        | Nil => true
        | _ => false
      }
    }

    public 'a length (x : list ('a)) : int {
      def loop (acc : int, x : list ('a)) : int {
        match (x) {
          | _ :: xs => loop (acc + 1, xs)
          | _ => acc
        }
      };
      loop (0, x)
    }
        
    public 'a head (l : list ('a)) : 'a {
      match (l) {
        | x :: _ => x
        | [] => raise Invalid_argument ("List.head")
      }
    }
    
    public 'a hd (l : list ('a)) : 'a {
      head (l)
    }
    
    public 'a tail (l : list ('a)) : list ('a) {
      match (l) {
        | _ :: tl => tl
        | [] => raise Invalid_argument ("List.tail")
      }
    }
    
    public 'a tl (l : list ('a)) : list ('a) {
      tail (l)
    }    

    public 'a nth (l : list ('a), n : int) : 'a {
      match (l) {
        | h :: t => 
          if ( n == 0 )
            h
          else
            nth(t, n-1)
        | [] => raise Invalid_argument ("List.nth")
      }
    }

    public 'a last (l : list ('a)) : 'a {
      match (l) {
        | [x] => x
        | _ :: xs => last (xs)
        | [] => raise Invalid_argument ("List.last")
      }
    }
    
    public 'a rev (l : list ('a)) : list ('a) {
      def loop (acc : list ('a), l : list ('a)) : list ('a) {
        match (l) {
          | x :: xs => loop (x :: acc, xs)
          | [] => acc
        }
      };
      loop ([], l)
    }
    
    public 'a append (x : list ('a), y : list ('a)) : list ('a) {
      match (x) {
        | [] => y
        | x :: xs => x :: append (xs, y)
      }
    }
    
    public 'a rev_append (x : list ('a), y : list ('a)) : list ('a) {
      match (x) {
        | h :: t => rev_append(t, h :: y)
        | [] => y
      }
    }
    
    public 'a concat (l : list (list ('a))) : list ('a) {
      fold_left(append, [], rev(l))
    }    

    public 'a flatten (l : list (list ('a))) : list ('a) {
      concat(l)
    }
  
    public 'a iter (f : 'a -> void, l : list ('a)) : void {
      match (l) {
        | x :: xs => f (x); iter (f, xs)
        | [] => ()
      }
    }

    public 'a, 'b map (f : 'a -> 'b, x : list ('a)) : list ('b) {
      match (x) {
        | [] => []
        | x :: xs => f (x) :: map (f, xs)
      }
    }

    public 'a, 'b rev_map (f : 'a -> 'b, x : list ('a)) : list ('b) {
      def loop (acc : list ('b), x : list ('a)) : list ('b) {
        match (x) {
          | h :: t => loop (f (h) :: acc, t)
          | [] => acc
        }
      };
      loop ([], x)
    }

    public 'a, 'b fold_left (f : 'b * 'a -> 'b, acc : 'b, l : list ('a)) : 'b {
      match (l) {
        | [] => acc
        | x :: xs => fold_left (f, f (acc, x), xs)
      }
    }

    public 'a, 'b fold_right (f : 'a * 'b -> 'b, l : list ('a), b : 'b) : 'b {
      match (l) {
        | [] => b
        | x :: xs => f (x, fold_right (f, xs, b))
      }
    }
  
    public 'a, 'b iter2 (f : 'a  * 'b -> void, a : list ('a), b : list ('b)) : void {
      match ((a, b)) {
        | ([], []) => ()
        | (x :: xs, y :: ys) => f (x, y); iter2 (f, xs, ys)
        | _ => raise Invalid_argument("List.iter2")
      }
    }

    public 'a, 'b, 'c map2 (f : 'a * 'b -> 'c, x : list ('a), y : list ('b)) : list ('c) {
      match ((x, y)) {
        | ([], []) => []
        | (x :: xs, y :: ys) => f (x, y) :: map2 (f, xs, ys)
        | _ => raise Invalid_argument("List.map2")
      }
    }

    public 'a, 'b, 'c rev_map2 (f : 'a * 'b -> 'c, x : list ('a), y : list ('b)) : list ('c) {
      def loop (acc : list ('c), x : list ('a), y : list ('b)) : list ('c) {
        match ((x, y)) {
          | ([], []) => []
          | (x :: xs, y :: ys) => loop (f (x, y) :: acc, xs, ys)
          | _ => raise Invalid_argument("List.rev_map2")
        }
      };
      loop([], x, y)
    }

    public 'a, 'b, 'c fold_left2 (f : 'c * 'a  * 'b -> 'c, acc : 'c, a : list ('a), b : list ('b)) : 'c {
      match ((a, b)) {
        | ([], []) => acc
        | (x :: xs, y :: ys) => fold_left2 (f, f (acc, x, y), xs, ys)
        | _ => raise Invalid_argument("List.fold_left2")
      }
    }

    public 'a, 'b, 'c fold_right2 (f : 'a * 'b  * 'c -> 'c, a : list ('a), b : list ('b), c : 'c) : 'c {
      match ((a, b)) {
        | ([], []) => c
        | (x :: xs, y :: ys) => f (x, y, fold_right2 (f, xs, ys, c))
        | _ => raise Invalid_argument("List.fold_right2")
      }
    }


    public 'a forall (f : 'a -> bool, l : list ('a)) : bool {
      match (l) {
        | x :: xs => f (x) && forall (f, xs)
        | [] => true
      }
    }

    public 'a for_all (f : 'a -> bool, l : list ('a)) : bool {
      forall(f, l)
    }

    public 'a exists (f : 'a -> bool, l : list ('a)) : bool {
      match (l) {
        | [] => false
        | h :: t => f (h) || exists (f, t)
      }
    }

    public 'a, 'b forall2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      match ((a, b)) {
        | ([], []) => true
        | (x :: xs, y :: ys) => f (x, y) && forall2 (f, xs, ys)
        | _ => raise Invalid_argument("List.forall2")
      }
    }

    public 'a, 'b for_all2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      forall2(f,a,b)
    }

    public 'a, 'b exists2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      match ((a,b)) {
        | ([], []) => false
        | (x :: xs, y :: ys) => f(x,y) || exists2(f,xs,ys)
        | _ => raise Invalid_argument ("List.exists2")
      }
    }

    // FIXME: we don't have mem, as == is physical equality
    public 'a memq (a : 'a, l : list ('a)) : bool {
      match (l) {
        | h :: t  => h == a || memq (a,t)
        | [] => false
      }
    }

        
    public 'a find (pred : 'a -> bool, l : list ('a)) : 'a {
      match (l) {
        | h :: t => if ( pred(h) ) h else find (pred, t)
        | [] => raise Not_found ()
      }
    }

    public 'a filter (f : 'a -> bool, l : list ('a)) : list ('a) {
      match (l) {
        | x :: xs =>
          if (f (x)) x :: filter (f, xs)
          else filter (f, xs)
        | [] => []
      }
    }

    public 'a find_all (f : 'a -> bool, l : list ('a)) : list ('a) {
      filter(f, l)
    }

    public 'a partition ( pred : 'a -> bool, l : list ('a)) : list ('a) * list ('a) {
      def loop (l : list ('a), sat : list ('a), notsat : list ('a)) 
            : list ('a) * list ('a) 
      {
        match (l) {
          | h :: t => 
            if (pred (h)) 
              loop (t, h :: sat, notsat)
            else 
              loop (t, sat, h :: notsat)
          | [] => (rev (sat), rev (notsat))
        }
      };
      loop (l, [], [])  
    }


    public 'a group (cmp : ('a * 'a) -> int, l : list ('a)) : list (list ('a))
    {
      def walk (l : list ('a), acc : list ('a)) : list (list ('a)) {      

        def h = List.head (acc);
      
        match (l) {
          | e :: rest =>
            if (cmp (e, h) == 0)
              walk (rest, e :: acc)
            else
              acc :: walk (rest, [e])
          | [] => [acc]
        }
      };

      if (List.is_empty (l)) []
      else {
        def sorted = List.sort (cmp, l);
      
        walk (List.tail (sorted), [List.head (sorted)])
      }
    }

    
    // FIXME: == is physical equality
    public 'a, 'b assoc (key : 'a, l : list ('a * 'b)) : 'b {
      match (l) {
        | (k, v) :: t =>
          if (key == k)
            v
          else
            assoc (key, t)
        | [] => raise Not_found ()
      }
    }

    public 'a, 'b mem_assoc (key : 'a, l : list ('a * 'b)) : bool {
      match (l) {
        | (k, v) :: t =>
          if (key == k)
            true
          else
            mem_assoc (key, t)
        | [] => false
      }
    }

    public 'a, 'b remove_assoc (key : 'a, l : list ('a * 'b)) : list ('a * 'b) {
      def loop (acc : list ('a * 'b), l : list ('a * 'b)) : list ('a * 'b)
      {
        match (l) {
          | (k, v) :: t => 
              if (key == k)
                loop (acc, t)
              else
                loop ((k, v) :: acc, t)
          | [] => rev (acc)
        }
      };
      loop ([], l)  
    }


    
    public 'a, 'b split(l : list ('a * 'b)) : list ('a) * list ('b) {
      def loop (acc1 : list ('a), acc2 : list ('b), l : list ('a * 'b)) : list ('a) * list ('b) 
      {
        match (l) {
          | (a, b) :: t => loop (a :: acc1, b :: acc2, t)
          | [] => (rev (acc1), rev (acc2))
        }
      };
      loop([], [], l)
    }

    public 'a, 'b combine(a : list ('a), b : list ('b)) : list ('a * 'b) {
      def loop (acc : list ('a * 'b), a : list ('a), b : list ('b)) : list ('a * 'b) 
      {
        match ((a, b)) {
          | (x :: xs, y :: ys) => loop((x, y) :: acc, xs, ys)
          | ([], []) => rev (acc)
          | _ => raise Invalid_argument ("List.combine")
        }
      };
      loop ([],a,b)
    }

    'a mergesort (cmp : ('a * 'a) -> int, l : list ('a)) : list ('a) {
      def split (l : list ('a)) : (list ('a) * list ('a)) {
        def aux (l : list ('a), acc : list ('a), n : int) : (list ('a) * list ('a)) {
          if (n == 0) 
            (List.rev (acc), l)
          else 
            match (l) {
              | Nil => aux (l, acc, 0)
              | Cons(x, xs) => aux (xs, Cons (x, acc), (n - 1))
            }
        };
        aux (l, Nil(), (List.length (l) / 2))
      };
      def merge (cmp : ('a * 'a) -> int, l1 : list ('a), l2 : list ('a)) : list ('a) {
        def aux (l1 : list ('a), l2 : list ('a), acc : list ('a)) : list ('a) {
          match ((l1,l2)) {
            | (Nil, _) => List.append (List.rev (acc), l2)
            | (_, Nil) => List.append (List.rev (acc), l1)
            | (Cons (x, xs), Cons (y, ys)) => 
              if (cmp(x, y) > 0)
                aux (xs, Cons (y, ys), Cons (x, acc))
              else
                aux (Cons (x, xs), ys, Cons (y, acc))
          }
        };
        aux (l1, l2, Nil ())
      };

      match (l) {
        | Nil => l
        | Cons (x, Nil) => l
        | _ =>
          match (split (l)) {
            | (l1, l2) => merge (cmp, mergesort (cmp, l1), mergesort (cmp, l2))
        }
      }
    }

    public 'a sort (cmp : ('a * 'a) -> int, l : list ('a)) : list ('a) 
    {
      mergesort (cmp, l)
    }
  }
}

*)

(*
public class ImplementsTest implements Nemerle.Func1
{
  public this () { }

  public apply (parm1 : object) : object
  {
    System.Console.WriteLine ("Hello world, my name is not Jan B.!");
    null
  }
}
*)

public class CGILTest
{
  public this () { }

(*  
	public method_a (index : int) : int
	{
		mutable x <- 650;
		def y = false;
		def z = "Alamakota";
		
		this.method_b (index)
  }
  
  public method_b (index : int) : int
  {
		mutable x <- 650;

    x <- 750;
    
    x
  }

  public method_c (index : int) : int
  {
		def x = 255;
		def y = false;

    def z =
      if (true)
  		  x * 2
      else
        x * 3;
    
    def text = "Ala ma kota!";

    def sb = System.Text.StringBuilder (text, x);
  
    def _ = sb.Append (' ');
    def _ = sb.Append ("I psa!");
  
    def text = sb.ToString ();
    
    System.Console.WriteLine (text);
    
    z
	}

  public method_d () : void
  {
    def x = [1; 2; 3];
    
    match (x) {
      | [] => System.Console.WriteLine ("Ojoj 1");
      | [_] => System.Console.WriteLine ("Ojoj 2");
      | _ => System.Console.WriteLine ("Ojoj 3");
    }
  }

  public method_e (x : int) : void
  {
    match (x) {
      | 0 => System.Console.Write ("zero, ")
      | 1 => System.Console.Write ("jeden, ")
      | 2 => System.Console.Write ("dwa, ")
      | 3 => System.Console.Write ("Trzy, ")
      | _ => System.Console.WriteLine ("START!")
    }
  }

  public method_f () : void
  {
    def x = ((10 :> System.Object), (20 :> System.Object));
    def y = ("ala", "ma", (2 :> System.Object), "koty");

    def (a, b) = x;

    System.Console.WriteLine ("Powinno byc 10 20: {0} {1}",
      (a :> System.Object), (b :> System.Object));
    
    ()
  }

  public method_g () : void {
    def loop (x : System.Object, y : System.Object) : void {
      ()
    };
    loop (null, null)
  }
*)

	public static Main () : void
	{
(*
    def x = CGILTest ();

    def y = x.method_c (10);

    when (y != 5) { def _ = x.method_b (7); () };

    System.Console.WriteLine ("{0}", (y :> System.Object));

    x.method_e (3);
    x.method_e (2);
    x.method_e (1);
    x.method_e (0);
    x.method_e (42);
    
    def oa = None ();

    def ob = Some ((10 :> System.Object));
    def oc = Some ("Ala ma psa!");

    
    match (oc) {
      | None => System.Console.WriteLine ("Ojoj!");
      | Some (x) => System.Console.WriteLine ("Nie ma strachu: " + x);
    };
    
    when (Option.is_some (oa)) { System.Console.WriteLine ("Ojoj!"); };
    when (Option.is_none (ob)) { System.Console.WriteLine ("Ojoj!"); };
    when (Option.is_some (ob)) { System.Console.WriteLine ("To jest 10: {0}", ((Option.unsome (ob)) :> System.Object)); };

    def it = ImplementsTest ();
    def _ = it.apply (it);

    def map_test (x : System.Object) : void {
      System.Console.WriteLine ("To jest 10 po raz drugi (Option.map): {0}", x);
    };

    def _ = Option.map (map_test, ob);
    x.method_f ();

    def l0 = [1; 2; 3; 4];

    def lf (i : int) : void {
      System.Console.WriteLine ("List.iter (lf, [1,2,3,4]): {0}", i)
    };
    
    Nemerle.Collections.List.iter (lf, l0);
    
    System.Console.WriteLine ("Powinno byæ 1 i 4: {0} i {1}",
      Nemerle.Collections.List.head (l0), Nemerle.Collections.List.length (l0));

    def a0 = mkarray [1; 2; 3; 4; 5];

    def a1 = a0 [0] + a0 [1] + a0 [2] + a0 [3] + a0 [4];
    
    System.Console.WriteLine ("1 + 2 + 3 + 4 + 5 = {0}", a1);
  
    a0 [0] <- 69;

    def a2 = a0 [0] + a0 [1] + a0 [2] + a0 [3] + a0 [4];

    System.Console.WriteLine ("69 + 2 + 3 + 4 + 5 = {0}", a2);
    
    System.Console.WriteLine ("Powinno byc 5: {0}", (a0 :> System.Array).Length);
*)

    def ind0 = "Ala ma kota!";
    def ind1 = System.Text.StringBuilder (ind0);

    ind1 [0] <- 'E';
    def ind2 = ind1 [0];
    System.Console.WriteLine ("Powinno byc E: {0}", ind2);
    
    ()
	}
}
